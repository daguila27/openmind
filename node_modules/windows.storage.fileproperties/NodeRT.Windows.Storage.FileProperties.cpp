// Copyright (c) Microsoft Corporation
// All rights reserved. 
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 
//
// See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.

#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include <string>
#include <node_object_wrap.h>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using namespace v8;
using namespace node;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Storage { namespace FileProperties { 
  v8::Handle<v8::Value> WrapStorageItemThumbnail(::Windows::Storage::FileProperties::StorageItemThumbnail^ wintRtInstance);
  ::Windows::Storage::FileProperties::StorageItemThumbnail^ UnwrapStorageItemThumbnail(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageItemExtraProperties(::Windows::Storage::FileProperties::IStorageItemExtraProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::IStorageItemExtraProperties^ UnwrapIStorageItemExtraProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapMusicProperties(::Windows::Storage::FileProperties::MusicProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::MusicProperties^ UnwrapMusicProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapVideoProperties(::Windows::Storage::FileProperties::VideoProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::VideoProperties^ UnwrapVideoProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapImageProperties(::Windows::Storage::FileProperties::ImageProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::ImageProperties^ UnwrapImageProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapDocumentProperties(::Windows::Storage::FileProperties::DocumentProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::DocumentProperties^ UnwrapDocumentProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapStorageItemContentProperties(::Windows::Storage::FileProperties::StorageItemContentProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::StorageItemContentProperties^ UnwrapStorageItemContentProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapBasicProperties(::Windows::Storage::FileProperties::BasicProperties^ wintRtInstance);
  ::Windows::Storage::FileProperties::BasicProperties^ UnwrapBasicProperties(Handle<Value> value);
  


  static v8::Handle<v8::Value> InitPropertyPrefetchOptionsEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("PropertyPrefetchOptions"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("musicProperties"), Integer::New(1));
    enumObject->Set(String::NewSymbol("videoProperties"), Integer::New(2));
    enumObject->Set(String::NewSymbol("imageProperties"), Integer::New(3));
    enumObject->Set(String::NewSymbol("documentProperties"), Integer::New(4));
    enumObject->Set(String::NewSymbol("basicProperties"), Integer::New(5));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitThumbnailTypeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ThumbnailType"), enumObject);

    enumObject->Set(String::NewSymbol("image"), Integer::New(0));
    enumObject->Set(String::NewSymbol("icon"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitThumbnailModeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ThumbnailMode"), enumObject);

    enumObject->Set(String::NewSymbol("picturesView"), Integer::New(0));
    enumObject->Set(String::NewSymbol("videosView"), Integer::New(1));
    enumObject->Set(String::NewSymbol("musicView"), Integer::New(2));
    enumObject->Set(String::NewSymbol("documentsView"), Integer::New(3));
    enumObject->Set(String::NewSymbol("listView"), Integer::New(4));
    enumObject->Set(String::NewSymbol("singleItem"), Integer::New(5));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitThumbnailOptionsEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ThumbnailOptions"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("returnOnlyIfCached"), Integer::New(1));
    enumObject->Set(String::NewSymbol("resizeThumbnail"), Integer::New(2));
    enumObject->Set(String::NewSymbol("useCurrentScale"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitPhotoOrientationEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("PhotoOrientation"), enumObject);

    enumObject->Set(String::NewSymbol("unspecified"), Integer::New(0));
    enumObject->Set(String::NewSymbol("normal"), Integer::New(1));
    enumObject->Set(String::NewSymbol("flipHorizontal"), Integer::New(2));
    enumObject->Set(String::NewSymbol("rotate180"), Integer::New(3));
    enumObject->Set(String::NewSymbol("flipVertical"), Integer::New(4));
    enumObject->Set(String::NewSymbol("transpose"), Integer::New(5));
    enumObject->Set(String::NewSymbol("rotate270"), Integer::New(6));
    enumObject->Set(String::NewSymbol("transverse"), Integer::New(7));
    enumObject->Set(String::NewSymbol("rotate90"), Integer::New(8));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitVideoOrientationEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("VideoOrientation"), enumObject);

    enumObject->Set(String::NewSymbol("normal"), Integer::New(0));
    enumObject->Set(String::NewSymbol("rotate90"), Integer::New(1));
    enumObject->Set(String::NewSymbol("rotate180"), Integer::New(2));
    enumObject->Set(String::NewSymbol("rotate270"), Integer::New(3));

    return scope.Close(Undefined());
  }



  
  class StorageItemThumbnail : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageItemThumbnail"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInputStreamAt"), FunctionTemplate::New(GetInputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getOutputStreamAt"), FunctionTemplate::New(GetOutputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("seek"), FunctionTemplate::New(Seek)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cloneStream"), FunctionTemplate::New(CloneStream)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("size"), SizeGetter, SizeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canRead"), CanReadGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canWrite"), CanWriteGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("position"), PositionGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("contentType"), ContentTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("originalHeight"), OriginalHeightGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("originalWidth"), OriginalWidthGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("returnedSmallerCachedSize"), ReturnedSmallerCachedSizeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("type"), TypeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("StorageItemThumbnail"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageItemThumbnail(::Windows::Storage::FileProperties::StorageItemThumbnail^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::StorageItemThumbnail^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::StorageItemThumbnail^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageItemThumbnail *wrapperInstance = new StorageItemThumbnail(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[0]));
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> GetInputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IInputStream", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetOutputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IOutputStream", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Seek(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->Seek(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CloneStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IRandomAccessStream", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }




    static Handle<Value> SizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Size;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SizeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsNumber())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return;
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        
        unsigned __int64 winRtValue = static_cast<unsigned __int64>(value->IntegerValue());

        wrapper->_instance->Size = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CanReadGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanRead;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CanWriteGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanWrite;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PositionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Position;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ContentTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->ContentType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OriginalHeightGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->OriginalHeight;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OriginalWidthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->OriginalWidth;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ReturnedSmallerCachedSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        bool result = wrapper->_instance->ReturnedSmallerCachedSize;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> TypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemThumbnail^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageItemThumbnail *wrapper = StorageItemThumbnail::Unwrap<StorageItemThumbnail>(info.This());

      try 
      {
        ::Windows::Storage::FileProperties::ThumbnailType result = wrapper->_instance->Type;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::FileProperties::StorageItemThumbnail^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageItemThumbnail(::Windows::Storage::FileProperties::StorageItemThumbnail^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::StorageItemThumbnail^ UnwrapStorageItemThumbnail(Handle<Value> value);
    friend bool IsStorageItemThumbnailWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageItemThumbnail::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageItemThumbnail(::Windows::Storage::FileProperties::StorageItemThumbnail^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageItemThumbnail::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::StorageItemThumbnail^ UnwrapStorageItemThumbnail(Handle<Value> value)
  {
     return StorageItemThumbnail::Unwrap<StorageItemThumbnail>(value.As<Object>())->_instance;
  }

  void InitStorageItemThumbnail(Handle<Object> exports)
  {
    StorageItemThumbnail::Init(exports);
  }

  class IStorageItemExtraProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageItemExtraProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageItemExtraProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageItemExtraProperties(::Windows::Storage::FileProperties::IStorageItemExtraProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::IStorageItemExtraProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::IStorageItemExtraProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::IStorageItemExtraProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageItemExtraProperties *wrapperInstance = new IStorageItemExtraProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::IStorageItemExtraProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItemExtraProperties *wrapper = IStorageItemExtraProperties::Unwrap<IStorageItemExtraProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::IStorageItemExtraProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItemExtraProperties *wrapper = IStorageItemExtraProperties::Unwrap<IStorageItemExtraProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::FileProperties::IStorageItemExtraProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageItemExtraProperties(::Windows::Storage::FileProperties::IStorageItemExtraProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::IStorageItemExtraProperties^ UnwrapIStorageItemExtraProperties(Handle<Value> value);
    friend bool IsIStorageItemExtraPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageItemExtraProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageItemExtraProperties(::Windows::Storage::FileProperties::IStorageItemExtraProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageItemExtraProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::IStorageItemExtraProperties^ UnwrapIStorageItemExtraProperties(Handle<Value> value)
  {
     return IStorageItemExtraProperties::Unwrap<IStorageItemExtraProperties>(value.As<Object>())->_instance;
  }

  void InitIStorageItemExtraProperties(Handle<Object> exports)
  {
    IStorageItemExtraProperties::Init(exports);
  }

  class MusicProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("MusicProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("year"), YearGetter, YearSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("trackNumber"), TrackNumberGetter, TrackNumberSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("title"), TitleGetter, TitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("subtitle"), SubtitleGetter, SubtitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("rating"), RatingGetter, RatingSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("publisher"), PublisherGetter, PublisherSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("artist"), ArtistGetter, ArtistSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("albumArtist"), AlbumArtistGetter, AlbumArtistSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("album"), AlbumGetter, AlbumSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bitrate"), BitrateGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("composers"), ComposersGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("conductors"), ConductorsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("duration"), DurationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("genre"), GenreGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("producers"), ProducersGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("writers"), WritersGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("MusicProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    MusicProperties(::Windows::Storage::FileProperties::MusicProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::MusicProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::MusicProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      MusicProperties *wrapperInstance = new MusicProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> YearGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Year;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void YearSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Year = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> TrackNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->TrackNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void TrackNumberSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->TrackNumber = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> TitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Title;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void TitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Title = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> SubtitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Subtitle;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SubtitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Subtitle = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> RatingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Rating;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void RatingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Rating = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> PublisherGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Publisher;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void PublisherSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Publisher = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ArtistGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Artist;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ArtistSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Artist = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> AlbumArtistGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->AlbumArtist;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void AlbumArtistSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->AlbumArtist = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> AlbumGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Album;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void AlbumSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return;
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Album = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> BitrateGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Bitrate;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ComposersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Composers;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ConductorsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Conductors;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DurationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->Duration;
        return scope.Close(Number::New(result.Duration/10000.0));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> GenreGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Genre;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProducersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Producers;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> WritersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::MusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      MusicProperties *wrapper = MusicProperties::Unwrap<MusicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Writers;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::FileProperties::MusicProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapMusicProperties(::Windows::Storage::FileProperties::MusicProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::MusicProperties^ UnwrapMusicProperties(Handle<Value> value);
    friend bool IsMusicPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> MusicProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapMusicProperties(::Windows::Storage::FileProperties::MusicProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(MusicProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::MusicProperties^ UnwrapMusicProperties(Handle<Value> value)
  {
     return MusicProperties::Unwrap<MusicProperties>(value.As<Object>())->_instance;
  }

  void InitMusicProperties(Handle<Object> exports)
  {
    MusicProperties::Init(exports);
  }

  class VideoProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("VideoProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("year"), YearGetter, YearSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("title"), TitleGetter, TitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("subtitle"), SubtitleGetter, SubtitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("rating"), RatingGetter, RatingSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("publisher"), PublisherGetter, PublisherSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bitrate"), BitrateGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("directors"), DirectorsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("duration"), DurationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("height"), HeightGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("keywords"), KeywordsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("latitude"), LatitudeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("longitude"), LongitudeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("orientation"), OrientationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("producers"), ProducersGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("width"), WidthGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("writers"), WritersGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("VideoProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    VideoProperties(::Windows::Storage::FileProperties::VideoProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::VideoProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::VideoProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      VideoProperties *wrapperInstance = new VideoProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> YearGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Year;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void YearSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return;
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Year = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> TitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Title;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void TitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return;
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Title = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> SubtitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Subtitle;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SubtitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return;
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Subtitle = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> RatingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Rating;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void RatingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return;
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Rating = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> PublisherGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Publisher;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void PublisherSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return;
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Publisher = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> BitrateGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Bitrate;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DirectorsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Directors;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DurationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->Duration;
        return scope.Close(Number::New(result.Duration/10000.0));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> HeightGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Height;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> KeywordsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Keywords;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LatitudeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Platform::IBox<double>^ result = wrapper->_instance->Latitude;
        return scope.Close(result ? Number::New(static_cast<double>(result->Value)): static_cast<Handle<Value>>(Undefined()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LongitudeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Platform::IBox<double>^ result = wrapper->_instance->Longitude;
        return scope.Close(result ? Number::New(static_cast<double>(result->Value)): static_cast<Handle<Value>>(Undefined()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OrientationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Windows::Storage::FileProperties::VideoOrientation result = wrapper->_instance->Orientation;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProducersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Producers;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> WidthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Width;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> WritersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::VideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      VideoProperties *wrapper = VideoProperties::Unwrap<VideoProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Writers;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::FileProperties::VideoProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapVideoProperties(::Windows::Storage::FileProperties::VideoProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::VideoProperties^ UnwrapVideoProperties(Handle<Value> value);
    friend bool IsVideoPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> VideoProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapVideoProperties(::Windows::Storage::FileProperties::VideoProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(VideoProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::VideoProperties^ UnwrapVideoProperties(Handle<Value> value)
  {
     return VideoProperties::Unwrap<VideoProperties>(value.As<Object>())->_instance;
  }

  void InitVideoProperties(Handle<Object> exports)
  {
    VideoProperties::Init(exports);
  }

  class ImageProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("ImageProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("title"), TitleGetter, TitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("rating"), RatingGetter, RatingSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("dateTaken"), DateTakenGetter, DateTakenSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("cameraModel"), CameraModelGetter, CameraModelSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("cameraManufacturer"), CameraManufacturerGetter, CameraManufacturerSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("height"), HeightGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("keywords"), KeywordsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("latitude"), LatitudeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("longitude"), LongitudeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("orientation"), OrientationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("peopleNames"), PeopleNamesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("width"), WidthGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("ImageProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    ImageProperties(::Windows::Storage::FileProperties::ImageProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::ImageProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::ImageProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      ImageProperties *wrapperInstance = new ImageProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> TitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Title;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void TitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return;
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Title = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> RatingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Rating;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void RatingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return;
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Rating = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> DateTakenGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        ::Windows::Foundation::DateTime result = wrapper->_instance->DateTaken;
        return scope.Close(NodeRT::Utils::DateTimeToJS(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void DateTakenSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsDate())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return;
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        
        ::Windows::Foundation::DateTime winRtValue = NodeRT::Utils::DateTimeFromJSDate(value);

        wrapper->_instance->DateTaken = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CameraModelGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->CameraModel;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void CameraModelSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return;
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->CameraModel = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CameraManufacturerGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->CameraManufacturer;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void CameraManufacturerSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return;
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->CameraManufacturer = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> HeightGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Height;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> KeywordsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Keywords;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LatitudeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        ::Platform::IBox<double>^ result = wrapper->_instance->Latitude;
        return scope.Close(result ? Number::New(static_cast<double>(result->Value)): static_cast<Handle<Value>>(Undefined()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LongitudeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        ::Platform::IBox<double>^ result = wrapper->_instance->Longitude;
        return scope.Close(result ? Number::New(static_cast<double>(result->Value)): static_cast<Handle<Value>>(Undefined()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OrientationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        ::Windows::Storage::FileProperties::PhotoOrientation result = wrapper->_instance->Orientation;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PeopleNamesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Platform::String^>^ result = wrapper->_instance->PeopleNames;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Platform::String^>::CreateVectorViewWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> WidthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::ImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ImageProperties *wrapper = ImageProperties::Unwrap<ImageProperties>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Width;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::FileProperties::ImageProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapImageProperties(::Windows::Storage::FileProperties::ImageProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::ImageProperties^ UnwrapImageProperties(Handle<Value> value);
    friend bool IsImagePropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> ImageProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapImageProperties(::Windows::Storage::FileProperties::ImageProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(ImageProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::ImageProperties^ UnwrapImageProperties(Handle<Value> value)
  {
     return ImageProperties::Unwrap<ImageProperties>(value.As<Object>())->_instance;
  }

  void InitImageProperties(Handle<Object> exports)
  {
    ImageProperties::Init(exports);
  }

  class DocumentProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("DocumentProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("title"), TitleGetter, TitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("comment"), CommentGetter, CommentSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("author"), AuthorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("keywords"), KeywordsGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("DocumentProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    DocumentProperties(::Windows::Storage::FileProperties::DocumentProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::DocumentProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::DocumentProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      DocumentProperties *wrapperInstance = new DocumentProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> TitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Title;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void TitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(info.This()))
      {
        return;
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Title = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CommentGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Comment;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void CommentSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(info.This()))
      {
        return;
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Comment = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> AuthorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Author;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> KeywordsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::DocumentProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DocumentProperties *wrapper = DocumentProperties::Unwrap<DocumentProperties>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVector<::Platform::String^>^ result = wrapper->_instance->Keywords;
        return scope.Close(NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::FileProperties::DocumentProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapDocumentProperties(::Windows::Storage::FileProperties::DocumentProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::DocumentProperties^ UnwrapDocumentProperties(Handle<Value> value);
    friend bool IsDocumentPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> DocumentProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapDocumentProperties(::Windows::Storage::FileProperties::DocumentProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(DocumentProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::DocumentProperties^ UnwrapDocumentProperties(Handle<Value> value)
  {
     return DocumentProperties::Unwrap<DocumentProperties>(value.As<Object>())->_instance;
  }

  void InitDocumentProperties(Handle<Object> exports)
  {
    DocumentProperties::Init(exports);
  }

  class StorageItemContentProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageItemContentProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(GetMusicPropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getMusicPropertiesAsync"), func);
      func = FunctionTemplate::New(GetVideoPropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getVideoPropertiesAsync"), func);
      func = FunctionTemplate::New(GetImagePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getImagePropertiesAsync"), func);
      func = FunctionTemplate::New(GetDocumentPropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDocumentPropertiesAsync"), func);
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("StorageItemContentProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageItemContentProperties(::Windows::Storage::FileProperties::StorageItemContentProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::StorageItemContentProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::StorageItemContentProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageItemContentProperties *wrapperInstance = new StorageItemContentProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> GetMusicPropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemContentProperties *wrapper = StorageItemContentProperties::Unwrap<StorageItemContentProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::MusicProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetMusicPropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::MusicProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapMusicProperties(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetVideoPropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemContentProperties *wrapper = StorageItemContentProperties::Unwrap<StorageItemContentProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::VideoProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetVideoPropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::VideoProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapVideoProperties(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetImagePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemContentProperties *wrapper = StorageItemContentProperties::Unwrap<StorageItemContentProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::ImageProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetImagePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::ImageProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapImageProperties(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetDocumentPropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemContentProperties *wrapper = StorageItemContentProperties::Unwrap<StorageItemContentProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::DocumentProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetDocumentPropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::DocumentProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapDocumentProperties(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemContentProperties *wrapper = StorageItemContentProperties::Unwrap<StorageItemContentProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::StorageItemContentProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageItemContentProperties *wrapper = StorageItemContentProperties::Unwrap<StorageItemContentProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::FileProperties::StorageItemContentProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageItemContentProperties(::Windows::Storage::FileProperties::StorageItemContentProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::StorageItemContentProperties^ UnwrapStorageItemContentProperties(Handle<Value> value);
    friend bool IsStorageItemContentPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageItemContentProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageItemContentProperties(::Windows::Storage::FileProperties::StorageItemContentProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageItemContentProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::StorageItemContentProperties^ UnwrapStorageItemContentProperties(Handle<Value> value)
  {
     return StorageItemContentProperties::Unwrap<StorageItemContentProperties>(value.As<Object>())->_instance;
  }

  void InitStorageItemContentProperties(Handle<Object> exports)
  {
    StorageItemContentProperties::Init(exports);
  }

  class BasicProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("BasicProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RetrievePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("retrievePropertiesAsync"), func);
      func = FunctionTemplate::New(SavePropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("savePropertiesAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("dateModified"), DateModifiedGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("itemDate"), ItemDateGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("size"), SizeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("BasicProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    BasicProperties(::Windows::Storage::FileProperties::BasicProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileProperties::BasicProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::BasicProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileProperties::BasicProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      BasicProperties *wrapperInstance = new BasicProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RetrievePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::BasicProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      BasicProperties *wrapper = BasicProperties::Unwrap<BasicProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^>^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->RetrievePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IMap<::Platform::String^, ::Platform::Object^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::MapWrapper<::Platform::String^,::Platform::Object^>::CreateMapWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SavePropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::BasicProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      BasicProperties *wrapper = BasicProperties::Unwrap<BasicProperties>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(args[0]) || args[0]->IsObject()))
      {
        try
        {
          ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^
            {
              if (value->IsObject())
              {
                return NodeRT::Collections::JsObjectToWinrtMap<::Platform::Object^>(value.As<Object>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          op = wrapper->_instance->SavePropertiesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SavePropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> DateModifiedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::BasicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      BasicProperties *wrapper = BasicProperties::Unwrap<BasicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::DateTime result = wrapper->_instance->DateModified;
        return scope.Close(NodeRT::Utils::DateTimeToJS(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ItemDateGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::BasicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      BasicProperties *wrapper = BasicProperties::Unwrap<BasicProperties>(info.This());

      try 
      {
        ::Windows::Foundation::DateTime result = wrapper->_instance->ItemDate;
        return scope.Close(NodeRT::Utils::DateTimeToJS(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileProperties::BasicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      BasicProperties *wrapper = BasicProperties::Unwrap<BasicProperties>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Size;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::FileProperties::BasicProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapBasicProperties(::Windows::Storage::FileProperties::BasicProperties^ wintRtInstance);
    friend ::Windows::Storage::FileProperties::BasicProperties^ UnwrapBasicProperties(Handle<Value> value);
    friend bool IsBasicPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> BasicProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapBasicProperties(::Windows::Storage::FileProperties::BasicProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(BasicProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileProperties::BasicProperties^ UnwrapBasicProperties(Handle<Value> value)
  {
     return BasicProperties::Unwrap<BasicProperties>(value.As<Object>())->_instance;
  }

  void InitBasicProperties(Handle<Object> exports)
  {
    BasicProperties::Init(exports);
  }

} } } } 

void init(Handle<Object> exports)
{
  if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
  {
    ThrowException(v8::Exception::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
    return;
  }
  
  NodeRT::Windows::Storage::FileProperties::InitPropertyPrefetchOptionsEnum(exports);
  NodeRT::Windows::Storage::FileProperties::InitThumbnailTypeEnum(exports);
  NodeRT::Windows::Storage::FileProperties::InitThumbnailModeEnum(exports);
  NodeRT::Windows::Storage::FileProperties::InitThumbnailOptionsEnum(exports);
  NodeRT::Windows::Storage::FileProperties::InitPhotoOrientationEnum(exports);
  NodeRT::Windows::Storage::FileProperties::InitVideoOrientationEnum(exports);
  NodeRT::Windows::Storage::FileProperties::InitStorageItemThumbnail(exports);
  NodeRT::Windows::Storage::FileProperties::InitIStorageItemExtraProperties(exports);
  NodeRT::Windows::Storage::FileProperties::InitMusicProperties(exports);
  NodeRT::Windows::Storage::FileProperties::InitVideoProperties(exports);
  NodeRT::Windows::Storage::FileProperties::InitImageProperties(exports);
  NodeRT::Windows::Storage::FileProperties::InitDocumentProperties(exports);
  NodeRT::Windows::Storage::FileProperties::InitStorageItemContentProperties(exports);
  NodeRT::Windows::Storage::FileProperties::InitBasicProperties(exports);

  NodeRT::Utils::RegisterNameSpace("Windows.Storage.FileProperties", exports);
}


NODE_MODULE(binding, init)