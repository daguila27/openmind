// Copyright (c) Microsoft Corporation
// All rights reserved. 
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 
//
// See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.

#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include <string>
#include <node_object_wrap.h>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using namespace v8;
using namespace node;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Devices { namespace Usb { 
  v8::Handle<v8::Value> WrapUsbControlRequestType(::Windows::Devices::Usb::UsbControlRequestType^ wintRtInstance);
  ::Windows::Devices::Usb::UsbControlRequestType^ UnwrapUsbControlRequestType(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbSetupPacket(::Windows::Devices::Usb::UsbSetupPacket^ wintRtInstance);
  ::Windows::Devices::Usb::UsbSetupPacket^ UnwrapUsbSetupPacket(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbDeviceClass(::Windows::Devices::Usb::UsbDeviceClass^ wintRtInstance);
  ::Windows::Devices::Usb::UsbDeviceClass^ UnwrapUsbDeviceClass(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbDeviceClasses(::Windows::Devices::Usb::UsbDeviceClasses^ wintRtInstance);
  ::Windows::Devices::Usb::UsbDeviceClasses^ UnwrapUsbDeviceClasses(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbDevice(::Windows::Devices::Usb::UsbDevice^ wintRtInstance);
  ::Windows::Devices::Usb::UsbDevice^ UnwrapUsbDevice(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterface(::Windows::Devices::Usb::UsbInterface^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterface^ UnwrapUsbInterface(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbDeviceDescriptor(::Windows::Devices::Usb::UsbDeviceDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbDeviceDescriptor^ UnwrapUsbDeviceDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbConfiguration(::Windows::Devices::Usb::UsbConfiguration^ wintRtInstance);
  ::Windows::Devices::Usb::UsbConfiguration^ UnwrapUsbConfiguration(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbDescriptor(::Windows::Devices::Usb::UsbDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbDescriptor^ UnwrapUsbDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbConfigurationDescriptor(::Windows::Devices::Usb::UsbConfigurationDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbConfigurationDescriptor^ UnwrapUsbConfigurationDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterfaceDescriptor(::Windows::Devices::Usb::UsbInterfaceDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterfaceDescriptor^ UnwrapUsbInterfaceDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbBulkInEndpointDescriptor(::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ UnwrapUsbBulkInEndpointDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterruptInEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ UnwrapUsbInterruptInEndpointDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbBulkOutEndpointDescriptor(::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ UnwrapUsbBulkOutEndpointDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterruptOutEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ UnwrapUsbInterruptOutEndpointDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbEndpointDescriptor(::Windows::Devices::Usb::UsbEndpointDescriptor^ wintRtInstance);
  ::Windows::Devices::Usb::UsbEndpointDescriptor^ UnwrapUsbEndpointDescriptor(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterruptInEventArgs(::Windows::Devices::Usb::UsbInterruptInEventArgs^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterruptInEventArgs^ UnwrapUsbInterruptInEventArgs(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterruptInPipe(::Windows::Devices::Usb::UsbInterruptInPipe^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterruptInPipe^ UnwrapUsbInterruptInPipe(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbBulkInPipe(::Windows::Devices::Usb::UsbBulkInPipe^ wintRtInstance);
  ::Windows::Devices::Usb::UsbBulkInPipe^ UnwrapUsbBulkInPipe(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbBulkOutPipe(::Windows::Devices::Usb::UsbBulkOutPipe^ wintRtInstance);
  ::Windows::Devices::Usb::UsbBulkOutPipe^ UnwrapUsbBulkOutPipe(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterruptOutPipe(::Windows::Devices::Usb::UsbInterruptOutPipe^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterruptOutPipe^ UnwrapUsbInterruptOutPipe(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUsbInterfaceSetting(::Windows::Devices::Usb::UsbInterfaceSetting^ wintRtInstance);
  ::Windows::Devices::Usb::UsbInterfaceSetting^ UnwrapUsbInterfaceSetting(Handle<Value> value);
  


  static v8::Handle<v8::Value> InitUsbTransferDirectionEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UsbTransferDirection"), enumObject);

    enumObject->Set(String::NewSymbol("out"), Integer::New(0));
    enumObject->Set(String::NewSymbol("in"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUsbEndpointTypeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UsbEndpointType"), enumObject);

    enumObject->Set(String::NewSymbol("control"), Integer::New(0));
    enumObject->Set(String::NewSymbol("isochronous"), Integer::New(1));
    enumObject->Set(String::NewSymbol("bulk"), Integer::New(2));
    enumObject->Set(String::NewSymbol("interrupt"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUsbControlRecipientEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UsbControlRecipient"), enumObject);

    enumObject->Set(String::NewSymbol("device"), Integer::New(0));
    enumObject->Set(String::NewSymbol("specifiedInterface"), Integer::New(1));
    enumObject->Set(String::NewSymbol("endpoint"), Integer::New(2));
    enumObject->Set(String::NewSymbol("other"), Integer::New(3));
    enumObject->Set(String::NewSymbol("defaultInterface"), Integer::New(4));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUsbControlTransferTypeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UsbControlTransferType"), enumObject);

    enumObject->Set(String::NewSymbol("standard"), Integer::New(0));
    enumObject->Set(String::NewSymbol("class"), Integer::New(1));
    enumObject->Set(String::NewSymbol("vendor"), Integer::New(2));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUsbReadOptionsEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UsbReadOptions"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("autoClearStall"), Integer::New(1));
    enumObject->Set(String::NewSymbol("overrideAutomaticBufferManagement"), Integer::New(2));
    enumObject->Set(String::NewSymbol("ignoreShortPacket"), Integer::New(3));
    enumObject->Set(String::NewSymbol("allowPartialReads"), Integer::New(4));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUsbWriteOptionsEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UsbWriteOptions"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("autoClearStall"), Integer::New(1));
    enumObject->Set(String::NewSymbol("shortPacketTerminate"), Integer::New(2));

    return scope.Close(Undefined());
  }



  
  class UsbControlRequestType : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbControlRequestType"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("recipient"), RecipientGetter, RecipientSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("direction"), DirectionGetter, DirectionSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("controlTransferType"), ControlTransferTypeGetter, ControlTransferTypeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("asByte"), AsByteGetter, AsByteSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbControlRequestType"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbControlRequestType(::Windows::Devices::Usb::UsbControlRequestType^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbControlRequestType^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbControlRequestType^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 0)
      {
        try
        {
          winRtInstance = ref new ::Windows::Devices::Usb::UsbControlRequestType();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbControlRequestType *wrapperInstance = new UsbControlRequestType(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> RecipientGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbControlRecipient result = wrapper->_instance->Recipient;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void RecipientSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return;
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbControlRecipient winRtValue = static_cast<::Windows::Devices::Usb::UsbControlRecipient>(value->Int32Value());

        wrapper->_instance->Recipient = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> DirectionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbTransferDirection result = wrapper->_instance->Direction;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void DirectionSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return;
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbTransferDirection winRtValue = static_cast<::Windows::Devices::Usb::UsbTransferDirection>(value->Int32Value());

        wrapper->_instance->Direction = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ControlTransferTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbControlTransferType result = wrapper->_instance->ControlTransferType;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ControlTransferTypeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return;
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbControlTransferType winRtValue = static_cast<::Windows::Devices::Usb::UsbControlTransferType>(value->Int32Value());

        wrapper->_instance->ControlTransferType = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> AsByteGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->AsByte;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void AsByteSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(info.This()))
      {
        return;
      }

      UsbControlRequestType *wrapper = UsbControlRequestType::Unwrap<UsbControlRequestType>(info.This());

      try 
      {
        
        unsigned char winRtValue = static_cast<unsigned char>(value->Int32Value());

        wrapper->_instance->AsByte = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbControlRequestType^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbControlRequestType(::Windows::Devices::Usb::UsbControlRequestType^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbControlRequestType^ UnwrapUsbControlRequestType(Handle<Value> value);
    friend bool IsUsbControlRequestTypeWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbControlRequestType::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbControlRequestType(::Windows::Devices::Usb::UsbControlRequestType^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbControlRequestType::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbControlRequestType^ UnwrapUsbControlRequestType(Handle<Value> value)
  {
     return UsbControlRequestType::Unwrap<UsbControlRequestType>(value.As<Object>())->_instance;
  }

  void InitUsbControlRequestType(Handle<Object> exports)
  {
    UsbControlRequestType::Init(exports);
  }

  class UsbSetupPacket : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbSetupPacket"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("value"), ValueGetter, ValueSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("requestType"), RequestTypeGetter, RequestTypeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("request"), RequestGetter, RequestSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("length"), LengthGetter, LengthSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("index"), IndexGetter, IndexSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbSetupPacket"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbSetupPacket(::Windows::Devices::Usb::UsbSetupPacket^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbSetupPacket^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbSetupPacket^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          winRtInstance = ref new ::Windows::Devices::Usb::UsbSetupPacket(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 0)
      {
        try
        {
          winRtInstance = ref new ::Windows::Devices::Usb::UsbSetupPacket();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbSetupPacket *wrapperInstance = new UsbSetupPacket(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> ValueGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Value;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ValueSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return;
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Value = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> RequestTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbControlRequestType^ result = wrapper->_instance->RequestType;
        return scope.Close(WrapUsbControlRequestType(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void RequestTypeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbControlRequestType^>(value))
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return;
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbControlRequestType^ winRtValue = dynamic_cast<::Windows::Devices::Usb::UsbControlRequestType^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->RequestType = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> RequestGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->Request;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void RequestSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return;
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        
        unsigned char winRtValue = static_cast<unsigned char>(value->Int32Value());

        wrapper->_instance->Request = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> LengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Length;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void LengthSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return;
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Length = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> IndexGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Index;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void IndexSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(info.This()))
      {
        return;
      }

      UsbSetupPacket *wrapper = UsbSetupPacket::Unwrap<UsbSetupPacket>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Index = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbSetupPacket^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbSetupPacket(::Windows::Devices::Usb::UsbSetupPacket^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbSetupPacket^ UnwrapUsbSetupPacket(Handle<Value> value);
    friend bool IsUsbSetupPacketWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbSetupPacket::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbSetupPacket(::Windows::Devices::Usb::UsbSetupPacket^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbSetupPacket::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbSetupPacket^ UnwrapUsbSetupPacket(Handle<Value> value)
  {
     return UsbSetupPacket::Unwrap<UsbSetupPacket>(value.As<Object>())->_instance;
  }

  void InitUsbSetupPacket(Handle<Object> exports)
  {
    UsbSetupPacket::Init(exports);
  }

  class UsbDeviceClass : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbDeviceClass"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("subclassCode"), SubclassCodeGetter, SubclassCodeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("protocolCode"), ProtocolCodeGetter, ProtocolCodeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("classCode"), ClassCodeGetter, ClassCodeSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbDeviceClass"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbDeviceClass(::Windows::Devices::Usb::UsbDeviceClass^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbDeviceClass^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbDeviceClass^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 0)
      {
        try
        {
          winRtInstance = ref new ::Windows::Devices::Usb::UsbDeviceClass();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbDeviceClass *wrapperInstance = new UsbDeviceClass(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> SubclassCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceClass *wrapper = UsbDeviceClass::Unwrap<UsbDeviceClass>(info.This());

      try 
      {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->SubclassCode;
        return scope.Close(result ? Integer::New(result->Value): static_cast<Handle<Value>>(Undefined()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SubclassCodeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(info.This()))
      {
        return;
      }

      UsbDeviceClass *wrapper = UsbDeviceClass::Unwrap<UsbDeviceClass>(info.This());

      try 
      {
        
        ::Platform::IBox<unsigned char>^ winRtValue = ref new ::Platform::Box<unsigned char>(static_cast<unsigned char>(value->Int32Value()));

        wrapper->_instance->SubclassCode = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ProtocolCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceClass *wrapper = UsbDeviceClass::Unwrap<UsbDeviceClass>(info.This());

      try 
      {
        ::Platform::IBox<unsigned char>^ result = wrapper->_instance->ProtocolCode;
        return scope.Close(result ? Integer::New(result->Value): static_cast<Handle<Value>>(Undefined()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ProtocolCodeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(info.This()))
      {
        return;
      }

      UsbDeviceClass *wrapper = UsbDeviceClass::Unwrap<UsbDeviceClass>(info.This());

      try 
      {
        
        ::Platform::IBox<unsigned char>^ winRtValue = ref new ::Platform::Box<unsigned char>(static_cast<unsigned char>(value->Int32Value()));

        wrapper->_instance->ProtocolCode = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ClassCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceClass *wrapper = UsbDeviceClass::Unwrap<UsbDeviceClass>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->ClassCode;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ClassCodeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(info.This()))
      {
        return;
      }

      UsbDeviceClass *wrapper = UsbDeviceClass::Unwrap<UsbDeviceClass>(info.This());

      try 
      {
        
        unsigned char winRtValue = static_cast<unsigned char>(value->Int32Value());

        wrapper->_instance->ClassCode = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbDeviceClass^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbDeviceClass(::Windows::Devices::Usb::UsbDeviceClass^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbDeviceClass^ UnwrapUsbDeviceClass(Handle<Value> value);
    friend bool IsUsbDeviceClassWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbDeviceClass::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbDeviceClass(::Windows::Devices::Usb::UsbDeviceClass^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbDeviceClass::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbDeviceClass^ UnwrapUsbDeviceClass(Handle<Value> value)
  {
     return UsbDeviceClass::Unwrap<UsbDeviceClass>(value.As<Object>())->_instance;
  }

  void InitUsbDeviceClass(Handle<Object> exports)
  {
    UsbDeviceClass::Init(exports);
  }

  class UsbDeviceClasses : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbDeviceClasses"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->SetAccessor(String::NewSymbol("activeSync"), ActiveSyncGetter);
      constructor->SetAccessor(String::NewSymbol("cdcControl"), CdcControlGetter);
      constructor->SetAccessor(String::NewSymbol("deviceFirmwareUpdate"), DeviceFirmwareUpdateGetter);
      constructor->SetAccessor(String::NewSymbol("irda"), IrdaGetter);
      constructor->SetAccessor(String::NewSymbol("measurement"), MeasurementGetter);
      constructor->SetAccessor(String::NewSymbol("palmSync"), PalmSyncGetter);
      constructor->SetAccessor(String::NewSymbol("personalHealthcare"), PersonalHealthcareGetter);
      constructor->SetAccessor(String::NewSymbol("physical"), PhysicalGetter);
      constructor->SetAccessor(String::NewSymbol("vendorSpecific"), VendorSpecificGetter);

      exports->Set(String::NewSymbol("UsbDeviceClasses"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbDeviceClasses(::Windows::Devices::Usb::UsbDeviceClasses^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbDeviceClasses^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClasses^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbDeviceClasses^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbDeviceClasses *wrapperInstance = new UsbDeviceClasses(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  




    static Handle<Value> ActiveSyncGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::ActiveSync;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CdcControlGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::CdcControl;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DeviceFirmwareUpdateGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::DeviceFirmwareUpdate;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IrdaGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::Irda;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MeasurementGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::Measurement;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PalmSyncGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::PalmSync;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PersonalHealthcareGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::PersonalHealthcare;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PhysicalGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::Physical;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> VendorSpecificGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceClass^ result = ::Windows::Devices::Usb::UsbDeviceClasses::VendorSpecific;
        return scope.Close(WrapUsbDeviceClass(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    

  private:
    ::Windows::Devices::Usb::UsbDeviceClasses^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbDeviceClasses(::Windows::Devices::Usb::UsbDeviceClasses^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbDeviceClasses^ UnwrapUsbDeviceClasses(Handle<Value> value);
    friend bool IsUsbDeviceClassesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbDeviceClasses::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbDeviceClasses(::Windows::Devices::Usb::UsbDeviceClasses^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbDeviceClasses::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbDeviceClasses^ UnwrapUsbDeviceClasses(Handle<Value> value)
  {
     return UsbDeviceClasses::Unwrap<UsbDeviceClasses>(value.As<Object>())->_instance;
  }

  void InitUsbDeviceClasses(Handle<Object> exports)
  {
    UsbDeviceClasses::Init(exports);
  }

  class UsbDevice : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbDevice"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(SendControlOutTransferAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("sendControlOutTransferAsync"), func);
      func = FunctionTemplate::New(SendControlInTransferAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("sendControlInTransferAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("configuration"), ConfigurationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("defaultInterface"), DefaultInterfaceGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("deviceDescriptor"), DeviceDescriptorGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("getDeviceSelector"), FunctionTemplate::New(GetDeviceSelector)->GetFunction());
      constructor->Set(String::NewSymbol("getDeviceClassSelector"), FunctionTemplate::New(GetDeviceClassSelector)->GetFunction());
      func = FunctionTemplate::New(FromIdAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("fromIdAsync"), func);

      exports->Set(String::NewSymbol("UsbDevice"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbDevice(::Windows::Devices::Usb::UsbDevice^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbDevice^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbDevice^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbDevice *wrapperInstance = new UsbDevice(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> SendControlOutTransferAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbDevice *wrapper = UsbDevice::Unwrap<UsbDevice>(args.This());

      ::Windows::Foundation::IAsyncOperation<unsigned int>^ op;
    

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[1]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbSetupPacket^ arg0 = UnwrapUsbSetupPacket(args[0]);
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          op = wrapper->_instance->SendControlOutTransferAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbSetupPacket^ arg0 = UnwrapUsbSetupPacket(args[0]);
          
          op = wrapper->_instance->SendControlOutTransferAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> SendControlInTransferAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbDevice *wrapper = UsbDevice::Unwrap<UsbDevice>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IBuffer^>^ op;
    

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[1]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbSetupPacket^ arg0 = UnwrapUsbSetupPacket(args[0]);
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          op = wrapper->_instance->SendControlInTransferAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbSetupPacket^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbSetupPacket^ arg0 = UnwrapUsbSetupPacket(args[0]);
          
          op = wrapper->_instance->SendControlInTransferAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDevice *wrapper = UsbDevice::Unwrap<UsbDevice>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }


    static Handle<Value> FromIdAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Devices::Usb::UsbDevice^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Devices::Usb::UsbDevice::FromIdAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Devices::Usb::UsbDevice^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapUsbDevice(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }

    static Handle<Value> GetDeviceSelector(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 3
        && args[0]->IsUint32()
        && args[1]->IsUint32()
        && NodeRT::Utils::IsGuid(args[2]))
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Platform::Guid arg2 = NodeRT::Utils::GuidFromJs(args[2]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(arg0, arg1, arg2);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && NodeRT::Utils::IsGuid(args[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(args[0]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsUint32()
        && args[1]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          Platform::String^ result;
          result = ::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(arg0, arg1);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetDeviceClassSelector(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceClass^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDeviceClass^ arg0 = UnwrapUsbDeviceClass(args[0]);
          
          Platform::String^ result;
          result = ::Windows::Devices::Usb::UsbDevice::GetDeviceClassSelector(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> ConfigurationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDevice *wrapper = UsbDevice::Unwrap<UsbDevice>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbConfiguration^ result = wrapper->_instance->Configuration;
        return scope.Close(WrapUsbConfiguration(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DefaultInterfaceGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDevice *wrapper = UsbDevice::Unwrap<UsbDevice>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterface^ result = wrapper->_instance->DefaultInterface;
        return scope.Close(WrapUsbInterface(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DeviceDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDevice^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDevice *wrapper = UsbDevice::Unwrap<UsbDevice>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbDeviceDescriptor^ result = wrapper->_instance->DeviceDescriptor;
        return scope.Close(WrapUsbDeviceDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbDevice^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbDevice(::Windows::Devices::Usb::UsbDevice^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbDevice^ UnwrapUsbDevice(Handle<Value> value);
    friend bool IsUsbDeviceWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbDevice::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbDevice(::Windows::Devices::Usb::UsbDevice^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbDevice::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbDevice^ UnwrapUsbDevice(Handle<Value> value)
  {
     return UsbDevice::Unwrap<UsbDevice>(value.As<Object>())->_instance;
  }

  void InitUsbDevice(Handle<Object> exports)
  {
    UsbDevice::Init(exports);
  }

  class UsbInterface : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterface"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bulkInPipes"), BulkInPipesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bulkOutPipes"), BulkOutPipesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("descriptors"), DescriptorsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interfaceNumber"), InterfaceNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interfaceSettings"), InterfaceSettingsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interruptInPipes"), InterruptInPipesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interruptOutPipes"), InterruptOutPipesGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterface"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterface(::Windows::Devices::Usb::UsbInterface^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterface^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterface^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterface *wrapperInstance = new UsbInterface(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> BulkInPipesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbBulkInPipe^>^ result = wrapper->_instance->BulkInPipes;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbBulkInPipe^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbBulkInPipe^ val) -> Handle<Value> {
              return WrapUsbBulkInPipe(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbBulkInPipe^ {
              return UnwrapUsbBulkInPipe(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> BulkOutPipesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbBulkOutPipe^>^ result = wrapper->_instance->BulkOutPipes;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbBulkOutPipe^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbBulkOutPipe^ val) -> Handle<Value> {
              return WrapUsbBulkOutPipe(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbBulkOutPipe^ {
              return UnwrapUsbBulkOutPipe(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DescriptorsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbDescriptor^>^ result = wrapper->_instance->Descriptors;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbDescriptor^ val) -> Handle<Value> {
              return WrapUsbDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbDescriptor^ {
              return UnwrapUsbDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterfaceNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->InterfaceNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterfaceSettingsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbInterfaceSetting^>^ result = wrapper->_instance->InterfaceSettings;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbInterfaceSetting^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbInterfaceSetting^ val) -> Handle<Value> {
              return WrapUsbInterfaceSetting(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbInterfaceSetting^ {
              return UnwrapUsbInterfaceSetting(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterruptInPipesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbInterruptInPipe^>^ result = wrapper->_instance->InterruptInPipes;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbInterruptInPipe^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbInterruptInPipe^ val) -> Handle<Value> {
              return WrapUsbInterruptInPipe(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInPipe^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbInterruptInPipe^ {
              return UnwrapUsbInterruptInPipe(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterruptOutPipesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterface *wrapper = UsbInterface::Unwrap<UsbInterface>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbInterruptOutPipe^>^ result = wrapper->_instance->InterruptOutPipes;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbInterruptOutPipe^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbInterruptOutPipe^ val) -> Handle<Value> {
              return WrapUsbInterruptOutPipe(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbInterruptOutPipe^ {
              return UnwrapUsbInterruptOutPipe(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterface^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterface(::Windows::Devices::Usb::UsbInterface^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterface^ UnwrapUsbInterface(Handle<Value> value);
    friend bool IsUsbInterfaceWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterface::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterface(::Windows::Devices::Usb::UsbInterface^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterface::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterface^ UnwrapUsbInterface(Handle<Value> value)
  {
     return UsbInterface::Unwrap<UsbInterface>(value.As<Object>())->_instance;
  }

  void InitUsbInterface(Handle<Object> exports)
  {
    UsbInterface::Init(exports);
  }

  class UsbDeviceDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbDeviceDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bcdDeviceRevision"), BcdDeviceRevisionGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bcdUsb"), BcdUsbGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxPacketSize0"), MaxPacketSize0Getter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("numberOfConfigurations"), NumberOfConfigurationsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("productId"), ProductIdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("vendorId"), VendorIdGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbDeviceDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbDeviceDescriptor(::Windows::Devices::Usb::UsbDeviceDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbDeviceDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbDeviceDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbDeviceDescriptor *wrapperInstance = new UsbDeviceDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> BcdDeviceRevisionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceDescriptor *wrapper = UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->BcdDeviceRevision;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> BcdUsbGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceDescriptor *wrapper = UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->BcdUsb;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxPacketSize0Getter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceDescriptor *wrapper = UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->MaxPacketSize0;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> NumberOfConfigurationsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceDescriptor *wrapper = UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->NumberOfConfigurations;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProductIdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceDescriptor *wrapper = UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->ProductId;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> VendorIdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDeviceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDeviceDescriptor *wrapper = UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->VendorId;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbDeviceDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbDeviceDescriptor(::Windows::Devices::Usb::UsbDeviceDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbDeviceDescriptor^ UnwrapUsbDeviceDescriptor(Handle<Value> value);
    friend bool IsUsbDeviceDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbDeviceDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbDeviceDescriptor(::Windows::Devices::Usb::UsbDeviceDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbDeviceDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbDeviceDescriptor^ UnwrapUsbDeviceDescriptor(Handle<Value> value)
  {
     return UsbDeviceDescriptor::Unwrap<UsbDeviceDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbDeviceDescriptor(Handle<Object> exports)
  {
    UsbDeviceDescriptor::Init(exports);
  }

  class UsbConfiguration : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbConfiguration"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("configurationDescriptor"), ConfigurationDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("descriptors"), DescriptorsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("usbInterfaces"), UsbInterfacesGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbConfiguration"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbConfiguration(::Windows::Devices::Usb::UsbConfiguration^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbConfiguration^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfiguration^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbConfiguration^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbConfiguration *wrapperInstance = new UsbConfiguration(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> ConfigurationDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfiguration^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfiguration *wrapper = UsbConfiguration::Unwrap<UsbConfiguration>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbConfigurationDescriptor^ result = wrapper->_instance->ConfigurationDescriptor;
        return scope.Close(WrapUsbConfigurationDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DescriptorsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfiguration^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfiguration *wrapper = UsbConfiguration::Unwrap<UsbConfiguration>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbDescriptor^>^ result = wrapper->_instance->Descriptors;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbDescriptor^ val) -> Handle<Value> {
              return WrapUsbDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbDescriptor^ {
              return UnwrapUsbDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> UsbInterfacesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfiguration^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfiguration *wrapper = UsbConfiguration::Unwrap<UsbConfiguration>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbInterface^>^ result = wrapper->_instance->UsbInterfaces;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbInterface^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbInterface^ val) -> Handle<Value> {
              return WrapUsbInterface(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterface^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbInterface^ {
              return UnwrapUsbInterface(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbConfiguration^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbConfiguration(::Windows::Devices::Usb::UsbConfiguration^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbConfiguration^ UnwrapUsbConfiguration(Handle<Value> value);
    friend bool IsUsbConfigurationWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbConfiguration::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbConfiguration(::Windows::Devices::Usb::UsbConfiguration^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbConfiguration::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbConfiguration^ UnwrapUsbConfiguration(Handle<Value> value)
  {
     return UsbConfiguration::Unwrap<UsbConfiguration>(value.As<Object>())->_instance;
  }

  void InitUsbConfiguration(Handle<Object> exports)
  {
    UsbConfiguration::Init(exports);
  }

  class UsbDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readDescriptorBuffer"), FunctionTemplate::New(ReadDescriptorBuffer)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("descriptorType"), DescriptorTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("length"), LengthGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbDescriptor(::Windows::Devices::Usb::UsbDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbDescriptor *wrapperInstance = new UsbDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> ReadDescriptorBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDescriptor *wrapper = UsbDescriptor::Unwrap<UsbDescriptor>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          wrapper->_instance->ReadDescriptorBuffer(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> DescriptorTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDescriptor *wrapper = UsbDescriptor::Unwrap<UsbDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->DescriptorType;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbDescriptor *wrapper = UsbDescriptor::Unwrap<UsbDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->Length;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbDescriptor(::Windows::Devices::Usb::UsbDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbDescriptor^ UnwrapUsbDescriptor(Handle<Value> value);
    friend bool IsUsbDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbDescriptor(::Windows::Devices::Usb::UsbDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbDescriptor^ UnwrapUsbDescriptor(Handle<Value> value)
  {
     return UsbDescriptor::Unwrap<UsbDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbDescriptor(Handle<Object> exports)
  {
    UsbDescriptor::Init(exports);
  }

  class UsbConfigurationDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbConfigurationDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("configurationValue"), ConfigurationValueGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxPowerMilliamps"), MaxPowerMilliampsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("remoteWakeup"), RemoteWakeupGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("selfPowered"), SelfPoweredGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("tryParse"), FunctionTemplate::New(TryParse)->GetFunction());
      constructor->Set(String::NewSymbol("parse"), FunctionTemplate::New(Parse)->GetFunction());

      exports->Set(String::NewSymbol("UsbConfigurationDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbConfigurationDescriptor(::Windows::Devices::Usb::UsbConfigurationDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbConfigurationDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfigurationDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbConfigurationDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbConfigurationDescriptor *wrapperInstance = new UsbConfigurationDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  


    static Handle<Value> TryParse(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDescriptor^ arg0 = UnwrapUsbDescriptor(args[0]);
          ::Windows::Devices::Usb::UsbConfigurationDescriptor^ arg1;  
          
          bool result;
          result = ::Windows::Devices::Usb::UsbConfigurationDescriptor::TryParse(arg0, &arg1);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("boolean"), Boolean::New(result));
          resObj->Set(String::NewSymbol("parsed"), NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Usb", "UsbConfigurationDescriptor", arg1));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Parse(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDescriptor^ arg0 = UnwrapUsbDescriptor(args[0]);
          
          ::Windows::Devices::Usb::UsbConfigurationDescriptor^ result;
          result = ::Windows::Devices::Usb::UsbConfigurationDescriptor::Parse(arg0);
          return scope.Close(WrapUsbConfigurationDescriptor(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> ConfigurationValueGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfigurationDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfigurationDescriptor *wrapper = UsbConfigurationDescriptor::Unwrap<UsbConfigurationDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->ConfigurationValue;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxPowerMilliampsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfigurationDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfigurationDescriptor *wrapper = UsbConfigurationDescriptor::Unwrap<UsbConfigurationDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->MaxPowerMilliamps;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RemoteWakeupGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfigurationDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfigurationDescriptor *wrapper = UsbConfigurationDescriptor::Unwrap<UsbConfigurationDescriptor>(info.This());

      try 
      {
        bool result = wrapper->_instance->RemoteWakeup;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SelfPoweredGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbConfigurationDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbConfigurationDescriptor *wrapper = UsbConfigurationDescriptor::Unwrap<UsbConfigurationDescriptor>(info.This());

      try 
      {
        bool result = wrapper->_instance->SelfPowered;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbConfigurationDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbConfigurationDescriptor(::Windows::Devices::Usb::UsbConfigurationDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbConfigurationDescriptor^ UnwrapUsbConfigurationDescriptor(Handle<Value> value);
    friend bool IsUsbConfigurationDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbConfigurationDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbConfigurationDescriptor(::Windows::Devices::Usb::UsbConfigurationDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbConfigurationDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbConfigurationDescriptor^ UnwrapUsbConfigurationDescriptor(Handle<Value> value)
  {
     return UsbConfigurationDescriptor::Unwrap<UsbConfigurationDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbConfigurationDescriptor(Handle<Object> exports)
  {
    UsbConfigurationDescriptor::Init(exports);
  }

  class UsbInterfaceDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterfaceDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("alternateSettingNumber"), AlternateSettingNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("classCode"), ClassCodeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interfaceNumber"), InterfaceNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("protocolCode"), ProtocolCodeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("subclassCode"), SubclassCodeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("tryParse"), FunctionTemplate::New(TryParse)->GetFunction());
      constructor->Set(String::NewSymbol("parse"), FunctionTemplate::New(Parse)->GetFunction());

      exports->Set(String::NewSymbol("UsbInterfaceDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterfaceDescriptor(::Windows::Devices::Usb::UsbInterfaceDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterfaceDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterfaceDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterfaceDescriptor *wrapperInstance = new UsbInterfaceDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  


    static Handle<Value> TryParse(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDescriptor^ arg0 = UnwrapUsbDescriptor(args[0]);
          ::Windows::Devices::Usb::UsbInterfaceDescriptor^ arg1;  
          
          bool result;
          result = ::Windows::Devices::Usb::UsbInterfaceDescriptor::TryParse(arg0, &arg1);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("boolean"), Boolean::New(result));
          resObj->Set(String::NewSymbol("parsed"), NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Usb", "UsbInterfaceDescriptor", arg1));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Parse(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDescriptor^ arg0 = UnwrapUsbDescriptor(args[0]);
          
          ::Windows::Devices::Usb::UsbInterfaceDescriptor^ result;
          result = ::Windows::Devices::Usb::UsbInterfaceDescriptor::Parse(arg0);
          return scope.Close(WrapUsbInterfaceDescriptor(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> AlternateSettingNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceDescriptor *wrapper = UsbInterfaceDescriptor::Unwrap<UsbInterfaceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->AlternateSettingNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ClassCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceDescriptor *wrapper = UsbInterfaceDescriptor::Unwrap<UsbInterfaceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->ClassCode;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterfaceNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceDescriptor *wrapper = UsbInterfaceDescriptor::Unwrap<UsbInterfaceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->InterfaceNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProtocolCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceDescriptor *wrapper = UsbInterfaceDescriptor::Unwrap<UsbInterfaceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->ProtocolCode;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SubclassCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceDescriptor *wrapper = UsbInterfaceDescriptor::Unwrap<UsbInterfaceDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->SubclassCode;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterfaceDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterfaceDescriptor(::Windows::Devices::Usb::UsbInterfaceDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterfaceDescriptor^ UnwrapUsbInterfaceDescriptor(Handle<Value> value);
    friend bool IsUsbInterfaceDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterfaceDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterfaceDescriptor(::Windows::Devices::Usb::UsbInterfaceDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterfaceDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterfaceDescriptor^ UnwrapUsbInterfaceDescriptor(Handle<Value> value)
  {
     return UsbInterfaceDescriptor::Unwrap<UsbInterfaceDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbInterfaceDescriptor(Handle<Object> exports)
  {
    UsbInterfaceDescriptor::Init(exports);
  }

  class UsbBulkInEndpointDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbBulkInEndpointDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointNumber"), EndpointNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxPacketSize"), MaxPacketSizeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("pipe"), PipeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbBulkInEndpointDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbBulkInEndpointDescriptor(::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbBulkInEndpointDescriptor *wrapperInstance = new UsbBulkInEndpointDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> EndpointNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInEndpointDescriptor *wrapper = UsbBulkInEndpointDescriptor::Unwrap<UsbBulkInEndpointDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->EndpointNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxPacketSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInEndpointDescriptor *wrapper = UsbBulkInEndpointDescriptor::Unwrap<UsbBulkInEndpointDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->MaxPacketSize;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PipeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInEndpointDescriptor *wrapper = UsbBulkInEndpointDescriptor::Unwrap<UsbBulkInEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbBulkInPipe^ result = wrapper->_instance->Pipe;
        return scope.Close(WrapUsbBulkInPipe(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbBulkInEndpointDescriptor(::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ UnwrapUsbBulkInEndpointDescriptor(Handle<Value> value);
    friend bool IsUsbBulkInEndpointDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbBulkInEndpointDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbBulkInEndpointDescriptor(::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbBulkInEndpointDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ UnwrapUsbBulkInEndpointDescriptor(Handle<Value> value)
  {
     return UsbBulkInEndpointDescriptor::Unwrap<UsbBulkInEndpointDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbBulkInEndpointDescriptor(Handle<Object> exports)
  {
    UsbBulkInEndpointDescriptor::Init(exports);
  }

  class UsbInterruptInEndpointDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterruptInEndpointDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointNumber"), EndpointNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interval"), IntervalGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxPacketSize"), MaxPacketSizeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("pipe"), PipeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterruptInEndpointDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterruptInEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterruptInEndpointDescriptor *wrapperInstance = new UsbInterruptInEndpointDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> EndpointNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptInEndpointDescriptor *wrapper = UsbInterruptInEndpointDescriptor::Unwrap<UsbInterruptInEndpointDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->EndpointNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IntervalGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptInEndpointDescriptor *wrapper = UsbInterruptInEndpointDescriptor::Unwrap<UsbInterruptInEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->Interval;
        return scope.Close(Number::New(result.Duration/10000.0));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxPacketSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptInEndpointDescriptor *wrapper = UsbInterruptInEndpointDescriptor::Unwrap<UsbInterruptInEndpointDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->MaxPacketSize;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PipeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptInEndpointDescriptor *wrapper = UsbInterruptInEndpointDescriptor::Unwrap<UsbInterruptInEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterruptInPipe^ result = wrapper->_instance->Pipe;
        return scope.Close(WrapUsbInterruptInPipe(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterruptInEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ UnwrapUsbInterruptInEndpointDescriptor(Handle<Value> value);
    friend bool IsUsbInterruptInEndpointDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterruptInEndpointDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterruptInEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterruptInEndpointDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ UnwrapUsbInterruptInEndpointDescriptor(Handle<Value> value)
  {
     return UsbInterruptInEndpointDescriptor::Unwrap<UsbInterruptInEndpointDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbInterruptInEndpointDescriptor(Handle<Object> exports)
  {
    UsbInterruptInEndpointDescriptor::Init(exports);
  }

  class UsbBulkOutEndpointDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbBulkOutEndpointDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointNumber"), EndpointNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxPacketSize"), MaxPacketSizeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("pipe"), PipeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbBulkOutEndpointDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbBulkOutEndpointDescriptor(::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbBulkOutEndpointDescriptor *wrapperInstance = new UsbBulkOutEndpointDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> EndpointNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkOutEndpointDescriptor *wrapper = UsbBulkOutEndpointDescriptor::Unwrap<UsbBulkOutEndpointDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->EndpointNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxPacketSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkOutEndpointDescriptor *wrapper = UsbBulkOutEndpointDescriptor::Unwrap<UsbBulkOutEndpointDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->MaxPacketSize;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PipeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkOutEndpointDescriptor *wrapper = UsbBulkOutEndpointDescriptor::Unwrap<UsbBulkOutEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbBulkOutPipe^ result = wrapper->_instance->Pipe;
        return scope.Close(WrapUsbBulkOutPipe(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbBulkOutEndpointDescriptor(::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ UnwrapUsbBulkOutEndpointDescriptor(Handle<Value> value);
    friend bool IsUsbBulkOutEndpointDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbBulkOutEndpointDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbBulkOutEndpointDescriptor(::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbBulkOutEndpointDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ UnwrapUsbBulkOutEndpointDescriptor(Handle<Value> value)
  {
     return UsbBulkOutEndpointDescriptor::Unwrap<UsbBulkOutEndpointDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbBulkOutEndpointDescriptor(Handle<Object> exports)
  {
    UsbBulkOutEndpointDescriptor::Init(exports);
  }

  class UsbInterruptOutEndpointDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterruptOutEndpointDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointNumber"), EndpointNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interval"), IntervalGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxPacketSize"), MaxPacketSizeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("pipe"), PipeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterruptOutEndpointDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterruptOutEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterruptOutEndpointDescriptor *wrapperInstance = new UsbInterruptOutEndpointDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> EndpointNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutEndpointDescriptor *wrapper = UsbInterruptOutEndpointDescriptor::Unwrap<UsbInterruptOutEndpointDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->EndpointNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IntervalGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutEndpointDescriptor *wrapper = UsbInterruptOutEndpointDescriptor::Unwrap<UsbInterruptOutEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Foundation::TimeSpan result = wrapper->_instance->Interval;
        return scope.Close(Number::New(result.Duration/10000.0));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxPacketSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutEndpointDescriptor *wrapper = UsbInterruptOutEndpointDescriptor::Unwrap<UsbInterruptOutEndpointDescriptor>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->MaxPacketSize;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PipeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutEndpointDescriptor *wrapper = UsbInterruptOutEndpointDescriptor::Unwrap<UsbInterruptOutEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterruptOutPipe^ result = wrapper->_instance->Pipe;
        return scope.Close(WrapUsbInterruptOutPipe(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterruptOutEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ UnwrapUsbInterruptOutEndpointDescriptor(Handle<Value> value);
    friend bool IsUsbInterruptOutEndpointDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterruptOutEndpointDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterruptOutEndpointDescriptor(::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterruptOutEndpointDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ UnwrapUsbInterruptOutEndpointDescriptor(Handle<Value> value)
  {
     return UsbInterruptOutEndpointDescriptor::Unwrap<UsbInterruptOutEndpointDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbInterruptOutEndpointDescriptor(Handle<Object> exports)
  {
    UsbInterruptOutEndpointDescriptor::Init(exports);
  }

  class UsbEndpointDescriptor : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbEndpointDescriptor"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("asBulkInEndpointDescriptor"), AsBulkInEndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("asBulkOutEndpointDescriptor"), AsBulkOutEndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("asInterruptInEndpointDescriptor"), AsInterruptInEndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("asInterruptOutEndpointDescriptor"), AsInterruptOutEndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("direction"), DirectionGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointNumber"), EndpointNumberGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointType"), EndpointTypeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("tryParse"), FunctionTemplate::New(TryParse)->GetFunction());
      constructor->Set(String::NewSymbol("parse"), FunctionTemplate::New(Parse)->GetFunction());

      exports->Set(String::NewSymbol("UsbEndpointDescriptor"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbEndpointDescriptor(::Windows::Devices::Usb::UsbEndpointDescriptor^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbEndpointDescriptor^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbEndpointDescriptor^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbEndpointDescriptor *wrapperInstance = new UsbEndpointDescriptor(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  


    static Handle<Value> TryParse(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDescriptor^ arg0 = UnwrapUsbDescriptor(args[0]);
          ::Windows::Devices::Usb::UsbEndpointDescriptor^ arg1;  
          
          bool result;
          result = ::Windows::Devices::Usb::UsbEndpointDescriptor::TryParse(arg0, &arg1);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("boolean"), Boolean::New(result));
          resObj->Set(String::NewSymbol("parsed"), NodeRT::Utils::CreateExternalWinRTObject("Windows.Devices.Usb", "UsbEndpointDescriptor", arg1));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Parse(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(args[0]))
      {
        try
        {
          ::Windows::Devices::Usb::UsbDescriptor^ arg0 = UnwrapUsbDescriptor(args[0]);
          
          ::Windows::Devices::Usb::UsbEndpointDescriptor^ result;
          result = ::Windows::Devices::Usb::UsbEndpointDescriptor::Parse(arg0);
          return scope.Close(WrapUsbEndpointDescriptor(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> AsBulkInEndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ result = wrapper->_instance->AsBulkInEndpointDescriptor;
        return scope.Close(WrapUsbBulkInEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AsBulkOutEndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ result = wrapper->_instance->AsBulkOutEndpointDescriptor;
        return scope.Close(WrapUsbBulkOutEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AsInterruptInEndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ result = wrapper->_instance->AsInterruptInEndpointDescriptor;
        return scope.Close(WrapUsbInterruptInEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AsInterruptOutEndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ result = wrapper->_instance->AsInterruptOutEndpointDescriptor;
        return scope.Close(WrapUsbInterruptOutEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DirectionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbTransferDirection result = wrapper->_instance->Direction;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> EndpointNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        unsigned char result = wrapper->_instance->EndpointNumber;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> EndpointTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbEndpointDescriptor^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbEndpointDescriptor *wrapper = UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbEndpointType result = wrapper->_instance->EndpointType;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbEndpointDescriptor^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbEndpointDescriptor(::Windows::Devices::Usb::UsbEndpointDescriptor^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbEndpointDescriptor^ UnwrapUsbEndpointDescriptor(Handle<Value> value);
    friend bool IsUsbEndpointDescriptorWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbEndpointDescriptor::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbEndpointDescriptor(::Windows::Devices::Usb::UsbEndpointDescriptor^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbEndpointDescriptor::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbEndpointDescriptor^ UnwrapUsbEndpointDescriptor(Handle<Value> value)
  {
     return UsbEndpointDescriptor::Unwrap<UsbEndpointDescriptor>(value.As<Object>())->_instance;
  }

  void InitUsbEndpointDescriptor(Handle<Object> exports)
  {
    UsbEndpointDescriptor::Init(exports);
  }

  class UsbInterruptInEventArgs : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterruptInEventArgs"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interruptData"), InterruptDataGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterruptInEventArgs"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterruptInEventArgs(::Windows::Devices::Usb::UsbInterruptInEventArgs^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterruptInEventArgs^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEventArgs^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterruptInEventArgs^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterruptInEventArgs *wrapperInstance = new UsbInterruptInEventArgs(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> InterruptDataGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEventArgs^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptInEventArgs *wrapper = UsbInterruptInEventArgs::Unwrap<UsbInterruptInEventArgs>(info.This());

      try 
      {
        ::Windows::Storage::Streams::IBuffer^ result = wrapper->_instance->InterruptData;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterruptInEventArgs^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterruptInEventArgs(::Windows::Devices::Usb::UsbInterruptInEventArgs^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterruptInEventArgs^ UnwrapUsbInterruptInEventArgs(Handle<Value> value);
    friend bool IsUsbInterruptInEventArgsWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterruptInEventArgs::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterruptInEventArgs(::Windows::Devices::Usb::UsbInterruptInEventArgs^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterruptInEventArgs::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterruptInEventArgs^ UnwrapUsbInterruptInEventArgs(Handle<Value> value)
  {
     return UsbInterruptInEventArgs::Unwrap<UsbInterruptInEventArgs>(value.As<Object>())->_instance;
  }

  void InitUsbInterruptInEventArgs(Handle<Object> exports)
  {
    UsbInterruptInEventArgs::Init(exports);
  }

  class UsbInterruptInPipe : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterruptInPipe"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(ClearStallAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clearStallAsync"), func);
      
            
      Local<Function> addListenerFunc = FunctionTemplate::New(AddListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("addListener"), addListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("on"), addListenerFunc);
      Local<Function> removeListenerFunc = FunctionTemplate::New(RemoveListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("removeListener"), removeListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("off"), removeListenerFunc);
            
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointDescriptor"), EndpointDescriptorGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterruptInPipe"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterruptInPipe(::Windows::Devices::Usb::UsbInterruptInPipe^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterruptInPipe^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInPipe^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterruptInPipe^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterruptInPipe *wrapperInstance = new UsbInterruptInPipe(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ClearStallAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInPipe^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbInterruptInPipe *wrapper = UsbInterruptInPipe::Unwrap<UsbInterruptInPipe>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ClearStallAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> EndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptInPipe *wrapper = UsbInterruptInPipe::Unwrap<UsbInterruptInPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ result = wrapper->_instance->EndpointDescriptor;
        return scope.Close(WrapUsbInterruptInEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


    static v8::Handle<v8::Value> AddListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;
      
      Local<Function> callback = args[1].As<Function>();
      
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"dataReceived", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInPipe^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        UsbInterruptInPipe *wrapper = UsbInterruptInPipe::Unwrap<UsbInterruptInPipe>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->DataReceived::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Devices::Usb::UsbInterruptInPipe^, ::Windows::Devices::Usb::UsbInterruptInEventArgs^>(
            [callbackObjPtr](::Windows::Devices::Usb::UsbInterruptInPipe^ arg0, ::Windows::Devices::Usb::UsbInterruptInEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = WrapUsbInterruptInPipe(arg0);
                Handle<Value> wrappedArg1 = WrapUsbInterruptInEventArgs(arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else 
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
          tokenMap = Object::New();
          callback->SetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME), tokenMap);
      }

      tokenMap.As<Object>()->Set(args[1], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
                
      return scope.Close(Undefined());
    }

    static v8::Handle<v8::Value> RemoveListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;

      if ((NodeRT::Utils::CaseInsenstiveEquals(L"dataReceived", str)))
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Function> callback = args[1].As<Function>();
      Handle<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      Handle<Value> opaqueWrapperObj =  tokenMap.As<Object>()->Get(args[1]);

      if (opaqueWrapperObj.IsEmpty() || opaqueWrapperObj->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());
            
      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;
        
      try 
      {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"dataReceived", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInPipe^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          UsbInterruptInPipe *wrapper = UsbInterruptInPipe::Unwrap<UsbInterruptInPipe>(args.This());
          wrapper->_instance->DataReceived::remove(registrationToken);
        }
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      tokenMap.As<Object>()->Delete(args[0].As<String>());

      return scope.Close(Undefined());
    }
  private:
    ::Windows::Devices::Usb::UsbInterruptInPipe^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterruptInPipe(::Windows::Devices::Usb::UsbInterruptInPipe^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterruptInPipe^ UnwrapUsbInterruptInPipe(Handle<Value> value);
    friend bool IsUsbInterruptInPipeWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterruptInPipe::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterruptInPipe(::Windows::Devices::Usb::UsbInterruptInPipe^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterruptInPipe::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterruptInPipe^ UnwrapUsbInterruptInPipe(Handle<Value> value)
  {
     return UsbInterruptInPipe::Unwrap<UsbInterruptInPipe>(value.As<Object>())->_instance;
  }

  void InitUsbInterruptInPipe(Handle<Object> exports)
  {
    UsbInterruptInPipe::Init(exports);
  }

  class UsbBulkInPipe : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbBulkInPipe"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushBuffer"), FunctionTemplate::New(FlushBuffer)->GetFunction());
      
            
      func = FunctionTemplate::New(ClearStallAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clearStallAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("readOptions"), ReadOptionsGetter, ReadOptionsSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointDescriptor"), EndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("inputStream"), InputStreamGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("maxTransferSizeBytes"), MaxTransferSizeBytesGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbBulkInPipe"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbBulkInPipe(::Windows::Devices::Usb::UsbBulkInPipe^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbBulkInPipe^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbBulkInPipe^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbBulkInPipe *wrapperInstance = new UsbBulkInPipe(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ClearStallAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ClearStallAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> FlushBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->FlushBuffer();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> ReadOptionsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbReadOptions result = wrapper->_instance->ReadOptions;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ReadOptionsSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(info.This()))
      {
        return;
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbReadOptions winRtValue = static_cast<::Windows::Devices::Usb::UsbReadOptions>(value->Int32Value());

        wrapper->_instance->ReadOptions = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> EndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ result = wrapper->_instance->EndpointDescriptor;
        return scope.Close(WrapUsbBulkInEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InputStreamGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(info.This());

      try 
      {
        ::Windows::Storage::Streams::IInputStream^ result = wrapper->_instance->InputStream;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IInputStream", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MaxTransferSizeBytesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkInPipe *wrapper = UsbBulkInPipe::Unwrap<UsbBulkInPipe>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->MaxTransferSizeBytes;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbBulkInPipe^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbBulkInPipe(::Windows::Devices::Usb::UsbBulkInPipe^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbBulkInPipe^ UnwrapUsbBulkInPipe(Handle<Value> value);
    friend bool IsUsbBulkInPipeWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbBulkInPipe::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbBulkInPipe(::Windows::Devices::Usb::UsbBulkInPipe^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbBulkInPipe::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbBulkInPipe^ UnwrapUsbBulkInPipe(Handle<Value> value)
  {
     return UsbBulkInPipe::Unwrap<UsbBulkInPipe>(value.As<Object>())->_instance;
  }

  void InitUsbBulkInPipe(Handle<Object> exports)
  {
    UsbBulkInPipe::Init(exports);
  }

  class UsbBulkOutPipe : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbBulkOutPipe"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(ClearStallAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clearStallAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("writeOptions"), WriteOptionsGetter, WriteOptionsSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointDescriptor"), EndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("outputStream"), OutputStreamGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbBulkOutPipe"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbBulkOutPipe(::Windows::Devices::Usb::UsbBulkOutPipe^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbBulkOutPipe^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbBulkOutPipe^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbBulkOutPipe *wrapperInstance = new UsbBulkOutPipe(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ClearStallAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbBulkOutPipe *wrapper = UsbBulkOutPipe::Unwrap<UsbBulkOutPipe>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ClearStallAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> WriteOptionsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkOutPipe *wrapper = UsbBulkOutPipe::Unwrap<UsbBulkOutPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbWriteOptions result = wrapper->_instance->WriteOptions;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void WriteOptionsSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(info.This()))
      {
        return;
      }

      UsbBulkOutPipe *wrapper = UsbBulkOutPipe::Unwrap<UsbBulkOutPipe>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbWriteOptions winRtValue = static_cast<::Windows::Devices::Usb::UsbWriteOptions>(value->Int32Value());

        wrapper->_instance->WriteOptions = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> EndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkOutPipe *wrapper = UsbBulkOutPipe::Unwrap<UsbBulkOutPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ result = wrapper->_instance->EndpointDescriptor;
        return scope.Close(WrapUsbBulkOutEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OutputStreamGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbBulkOutPipe *wrapper = UsbBulkOutPipe::Unwrap<UsbBulkOutPipe>(info.This());

      try 
      {
        ::Windows::Storage::Streams::IOutputStream^ result = wrapper->_instance->OutputStream;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IOutputStream", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbBulkOutPipe^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbBulkOutPipe(::Windows::Devices::Usb::UsbBulkOutPipe^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbBulkOutPipe^ UnwrapUsbBulkOutPipe(Handle<Value> value);
    friend bool IsUsbBulkOutPipeWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbBulkOutPipe::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbBulkOutPipe(::Windows::Devices::Usb::UsbBulkOutPipe^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbBulkOutPipe::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbBulkOutPipe^ UnwrapUsbBulkOutPipe(Handle<Value> value)
  {
     return UsbBulkOutPipe::Unwrap<UsbBulkOutPipe>(value.As<Object>())->_instance;
  }

  void InitUsbBulkOutPipe(Handle<Object> exports)
  {
    UsbBulkOutPipe::Init(exports);
  }

  class UsbInterruptOutPipe : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterruptOutPipe"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(ClearStallAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clearStallAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("writeOptions"), WriteOptionsGetter, WriteOptionsSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("endpointDescriptor"), EndpointDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("outputStream"), OutputStreamGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterruptOutPipe"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterruptOutPipe(::Windows::Devices::Usb::UsbInterruptOutPipe^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterruptOutPipe^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterruptOutPipe^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterruptOutPipe *wrapperInstance = new UsbInterruptOutPipe(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ClearStallAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbInterruptOutPipe *wrapper = UsbInterruptOutPipe::Unwrap<UsbInterruptOutPipe>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ClearStallAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> WriteOptionsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutPipe *wrapper = UsbInterruptOutPipe::Unwrap<UsbInterruptOutPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbWriteOptions result = wrapper->_instance->WriteOptions;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void WriteOptionsSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(info.This()))
      {
        return;
      }

      UsbInterruptOutPipe *wrapper = UsbInterruptOutPipe::Unwrap<UsbInterruptOutPipe>(info.This());

      try 
      {
        
        ::Windows::Devices::Usb::UsbWriteOptions winRtValue = static_cast<::Windows::Devices::Usb::UsbWriteOptions>(value->Int32Value());

        wrapper->_instance->WriteOptions = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> EndpointDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutPipe *wrapper = UsbInterruptOutPipe::Unwrap<UsbInterruptOutPipe>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ result = wrapper->_instance->EndpointDescriptor;
        return scope.Close(WrapUsbInterruptOutEndpointDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OutputStreamGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutPipe^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterruptOutPipe *wrapper = UsbInterruptOutPipe::Unwrap<UsbInterruptOutPipe>(info.This());

      try 
      {
        ::Windows::Storage::Streams::IOutputStream^ result = wrapper->_instance->OutputStream;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IOutputStream", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterruptOutPipe^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterruptOutPipe(::Windows::Devices::Usb::UsbInterruptOutPipe^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterruptOutPipe^ UnwrapUsbInterruptOutPipe(Handle<Value> value);
    friend bool IsUsbInterruptOutPipeWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterruptOutPipe::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterruptOutPipe(::Windows::Devices::Usb::UsbInterruptOutPipe^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterruptOutPipe::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterruptOutPipe^ UnwrapUsbInterruptOutPipe(Handle<Value> value)
  {
     return UsbInterruptOutPipe::Unwrap<UsbInterruptOutPipe>(value.As<Object>())->_instance;
  }

  void InitUsbInterruptOutPipe(Handle<Object> exports)
  {
    UsbInterruptOutPipe::Init(exports);
  }

  class UsbInterfaceSetting : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("UsbInterfaceSetting"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(SelectSettingAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("selectSettingAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bulkInEndpoints"), BulkInEndpointsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("bulkOutEndpoints"), BulkOutEndpointsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("descriptors"), DescriptorsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interfaceDescriptor"), InterfaceDescriptorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interruptInEndpoints"), InterruptInEndpointsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("interruptOutEndpoints"), InterruptOutEndpointsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("selected"), SelectedGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("UsbInterfaceSetting"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    UsbInterfaceSetting(::Windows::Devices::Usb::UsbInterfaceSetting^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Devices::Usb::UsbInterfaceSetting^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Devices::Usb::UsbInterfaceSetting^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      UsbInterfaceSetting *wrapperInstance = new UsbInterfaceSetting(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> SelectSettingAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->SelectSettingAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> BulkInEndpointsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>^ result = wrapper->_instance->BulkInEndpoints;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ val) -> Handle<Value> {
              return WrapUsbBulkInEndpointDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbBulkInEndpointDescriptor^ {
              return UnwrapUsbBulkInEndpointDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> BulkOutEndpointsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>^ result = wrapper->_instance->BulkOutEndpoints;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ val) -> Handle<Value> {
              return WrapUsbBulkOutEndpointDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor^ {
              return UnwrapUsbBulkOutEndpointDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DescriptorsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbDescriptor^>^ result = wrapper->_instance->Descriptors;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbDescriptor^ val) -> Handle<Value> {
              return WrapUsbDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbDescriptor^ {
              return UnwrapUsbDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterfaceDescriptorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        ::Windows::Devices::Usb::UsbInterfaceDescriptor^ result = wrapper->_instance->InterfaceDescriptor;
        return scope.Close(WrapUsbInterfaceDescriptor(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterruptInEndpointsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>^ result = wrapper->_instance->InterruptInEndpoints;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ val) -> Handle<Value> {
              return WrapUsbInterruptInEndpointDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor^ {
              return UnwrapUsbInterruptInEndpointDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> InterruptOutEndpointsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IVectorView<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>^ result = wrapper->_instance->InterruptOutEndpoints;
        return scope.Close(NodeRT::Collections::VectorViewWrapper<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>::CreateVectorViewWrapper(result, 
            [](::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ val) -> Handle<Value> {
              return WrapUsbInterruptOutEndpointDescriptor(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor^ {
              return UnwrapUsbInterruptOutEndpointDescriptor(value);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SelectedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Devices::Usb::UsbInterfaceSetting^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      UsbInterfaceSetting *wrapper = UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(info.This());

      try 
      {
        bool result = wrapper->_instance->Selected;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Devices::Usb::UsbInterfaceSetting^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUsbInterfaceSetting(::Windows::Devices::Usb::UsbInterfaceSetting^ wintRtInstance);
    friend ::Windows::Devices::Usb::UsbInterfaceSetting^ UnwrapUsbInterfaceSetting(Handle<Value> value);
    friend bool IsUsbInterfaceSettingWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> UsbInterfaceSetting::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUsbInterfaceSetting(::Windows::Devices::Usb::UsbInterfaceSetting^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(UsbInterfaceSetting::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Devices::Usb::UsbInterfaceSetting^ UnwrapUsbInterfaceSetting(Handle<Value> value)
  {
     return UsbInterfaceSetting::Unwrap<UsbInterfaceSetting>(value.As<Object>())->_instance;
  }

  void InitUsbInterfaceSetting(Handle<Object> exports)
  {
    UsbInterfaceSetting::Init(exports);
  }

} } } } 

void init(Handle<Object> exports)
{
  if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
  {
    ThrowException(v8::Exception::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
    return;
  }
  
  NodeRT::Windows::Devices::Usb::InitUsbTransferDirectionEnum(exports);
  NodeRT::Windows::Devices::Usb::InitUsbEndpointTypeEnum(exports);
  NodeRT::Windows::Devices::Usb::InitUsbControlRecipientEnum(exports);
  NodeRT::Windows::Devices::Usb::InitUsbControlTransferTypeEnum(exports);
  NodeRT::Windows::Devices::Usb::InitUsbReadOptionsEnum(exports);
  NodeRT::Windows::Devices::Usb::InitUsbWriteOptionsEnum(exports);
  NodeRT::Windows::Devices::Usb::InitUsbControlRequestType(exports);
  NodeRT::Windows::Devices::Usb::InitUsbSetupPacket(exports);
  NodeRT::Windows::Devices::Usb::InitUsbDeviceClass(exports);
  NodeRT::Windows::Devices::Usb::InitUsbDeviceClasses(exports);
  NodeRT::Windows::Devices::Usb::InitUsbDevice(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterface(exports);
  NodeRT::Windows::Devices::Usb::InitUsbDeviceDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbConfiguration(exports);
  NodeRT::Windows::Devices::Usb::InitUsbDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbConfigurationDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterfaceDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbBulkInEndpointDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterruptInEndpointDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbBulkOutEndpointDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterruptOutEndpointDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbEndpointDescriptor(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterruptInEventArgs(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterruptInPipe(exports);
  NodeRT::Windows::Devices::Usb::InitUsbBulkInPipe(exports);
  NodeRT::Windows::Devices::Usb::InitUsbBulkOutPipe(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterruptOutPipe(exports);
  NodeRT::Windows::Devices::Usb::InitUsbInterfaceSetting(exports);

  NodeRT::Utils::RegisterNameSpace("Windows.Devices.Usb", exports);
}


NODE_MODULE(binding, init)