// Copyright (c) Microsoft Corporation
// All rights reserved. 
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 
//
// See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.

#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include <string>
#include <node_object_wrap.h>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using namespace v8;
using namespace node;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Storage { namespace Streams { 
  v8::Handle<v8::Value> WrapDataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ wintRtInstance);
  ::Windows::Storage::Streams::DataReaderLoadOperation^ UnwrapDataReaderLoadOperation(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIDataReader(::Windows::Storage::Streams::IDataReader^ wintRtInstance);
  ::Windows::Storage::Streams::IDataReader^ UnwrapIDataReader(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapDataReader(::Windows::Storage::Streams::DataReader^ wintRtInstance);
  ::Windows::Storage::Streams::DataReader^ UnwrapDataReader(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapDataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ wintRtInstance);
  ::Windows::Storage::Streams::DataWriterStoreOperation^ UnwrapDataWriterStoreOperation(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIDataWriter(::Windows::Storage::Streams::IDataWriter^ wintRtInstance);
  ::Windows::Storage::Streams::IDataWriter^ UnwrapIDataWriter(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapDataWriter(::Windows::Storage::Streams::DataWriter^ wintRtInstance);
  ::Windows::Storage::Streams::DataWriter^ UnwrapDataWriter(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapRandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::RandomAccessStream^ UnwrapRandomAccessStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapBuffer(::Windows::Storage::Streams::Buffer^ wintRtInstance);
  ::Windows::Storage::Streams::Buffer^ UnwrapBuffer(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIBuffer(::Windows::Storage::Streams::IBuffer^ wintRtInstance);
  ::Windows::Storage::Streams::IBuffer^ UnwrapIBuffer(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ wintRtInstance);
  ::Windows::Storage::Streams::IContentTypeProvider^ UnwrapIContentTypeProvider(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ wintRtInstance);
  ::Windows::Storage::Streams::IRandomAccessStreamReference^ UnwrapIRandomAccessStreamReference(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ wintRtInstance);
  ::Windows::Storage::Streams::IInputStreamReference^ UnwrapIInputStreamReference(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapRandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ wintRtInstance);
  ::Windows::Storage::Streams::RandomAccessStreamReference^ UnwrapRandomAccessStreamReference(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::FileRandomAccessStream^ UnwrapFileRandomAccessStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileInputStream(::Windows::Storage::Streams::FileInputStream^ wintRtInstance);
  ::Windows::Storage::Streams::FileInputStream^ UnwrapFileInputStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileOutputStream(::Windows::Storage::Streams::FileOutputStream^ wintRtInstance);
  ::Windows::Storage::Streams::FileOutputStream^ UnwrapFileOutputStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapRandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ wintRtInstance);
  ::Windows::Storage::Streams::RandomAccessStreamOverStream^ UnwrapRandomAccessStreamOverStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapInputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ wintRtInstance);
  ::Windows::Storage::Streams::InputStreamOverStream^ UnwrapInputStreamOverStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapOutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ wintRtInstance);
  ::Windows::Storage::Streams::OutputStreamOverStream^ UnwrapOutputStreamOverStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapInMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::InMemoryRandomAccessStream^ UnwrapInMemoryRandomAccessStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIInputStream(::Windows::Storage::Streams::IInputStream^ wintRtInstance);
  ::Windows::Storage::Streams::IInputStream^ UnwrapIInputStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIOutputStream(::Windows::Storage::Streams::IOutputStream^ wintRtInstance);
  ::Windows::Storage::Streams::IOutputStream^ UnwrapIOutputStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ wintRtInstance);
  ::Windows::Storage::Streams::IRandomAccessStream^ UnwrapIRandomAccessStream(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ wintRtInstance);
  ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ UnwrapIRandomAccessStreamWithContentType(Handle<Value> value);
  


  static v8::Handle<v8::Value> InitByteOrderEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ByteOrder"), enumObject);

    enumObject->Set(String::NewSymbol("littleEndian"), Integer::New(0));
    enumObject->Set(String::NewSymbol("bigEndian"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUnicodeEncodingEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UnicodeEncoding"), enumObject);

    enumObject->Set(String::NewSymbol("utf8"), Integer::New(0));
    enumObject->Set(String::NewSymbol("utf16LE"), Integer::New(1));
    enumObject->Set(String::NewSymbol("utf16BE"), Integer::New(2));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitInputStreamOptionsEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("InputStreamOptions"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("partial"), Integer::New(1));
    enumObject->Set(String::NewSymbol("readAhead"), Integer::New(2));

    return scope.Close(Undefined());
  }



  
  class DataReaderLoadOperation : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("DataReaderLoadOperation"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getResults"), FunctionTemplate::New(GetResults)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cancel"), FunctionTemplate::New(Cancel)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("errorCode"), ErrorCodeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("id"), IdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("status"), StatusGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("completed"), CompletedGetter, CompletedSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("DataReaderLoadOperation"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    DataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::DataReaderLoadOperation^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::DataReaderLoadOperation^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      DataReaderLoadOperation *wrapperInstance = new DataReaderLoadOperation(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetResults(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->GetResults();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Cancel(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Cancel();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Close();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> ErrorCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try 
      {
        ::Windows::Foundation::HResult result = wrapper->_instance->ErrorCode;
        return scope.Close(Integer::New(result.Value));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Id;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> StatusGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try 
      {
        ::Windows::Foundation::AsyncStatus result = wrapper->_instance->Status;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CompletedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try 
      {
        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ result = wrapper->_instance->Completed;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "AsyncOperationCompletedHandler`1", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void CompletedSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(value))
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReaderLoadOperation^>(info.This()))
      {
        return;
      }

      DataReaderLoadOperation *wrapper = DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(info.This());

      try 
      {
        
        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ winRtValue = dynamic_cast<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Completed = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Storage::Streams::DataReaderLoadOperation^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapDataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ wintRtInstance);
    friend ::Windows::Storage::Streams::DataReaderLoadOperation^ UnwrapDataReaderLoadOperation(Handle<Value> value);
    friend bool IsDataReaderLoadOperationWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> DataReaderLoadOperation::s_constructorTemplate;

  v8::Handle<v8::Value> WrapDataReaderLoadOperation(::Windows::Storage::Streams::DataReaderLoadOperation^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(DataReaderLoadOperation::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::DataReaderLoadOperation^ UnwrapDataReaderLoadOperation(Handle<Value> value)
  {
     return DataReaderLoadOperation::Unwrap<DataReaderLoadOperation>(value.As<Object>())->_instance;
  }

  void InitDataReaderLoadOperation(Handle<Object> exports)
  {
    DataReaderLoadOperation::Init(exports);
  }

  class IDataReader : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IDataReader"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readByte"), FunctionTemplate::New(ReadByte)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readBytes"), FunctionTemplate::New(ReadBytes)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readBuffer"), FunctionTemplate::New(ReadBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readBoolean"), FunctionTemplate::New(ReadBoolean)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readGuid"), FunctionTemplate::New(ReadGuid)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readInt16"), FunctionTemplate::New(ReadInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readInt32"), FunctionTemplate::New(ReadInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readInt64"), FunctionTemplate::New(ReadInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readUInt16"), FunctionTemplate::New(ReadUInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readUInt32"), FunctionTemplate::New(ReadUInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readUInt64"), FunctionTemplate::New(ReadUInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readSingle"), FunctionTemplate::New(ReadSingle)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readDouble"), FunctionTemplate::New(ReadDouble)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readString"), FunctionTemplate::New(ReadString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readDateTime"), FunctionTemplate::New(ReadDateTime)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readTimeSpan"), FunctionTemplate::New(ReadTimeSpan)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachBuffer"), FunctionTemplate::New(DetachBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachStream"), FunctionTemplate::New(DetachStream)->GetFunction());
      
            
      func = FunctionTemplate::New(LoadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("loadAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("byteOrder"), ByteOrderGetter, ByteOrderSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("inputStreamOptions"), InputStreamOptionsGetter, InputStreamOptionsSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unconsumedBufferLength"), UnconsumedBufferLengthGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unicodeEncoding"), UnicodeEncodingGetter, UnicodeEncodingSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IDataReader"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IDataReader(::Windows::Storage::Streams::IDataReader^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IDataReader^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IDataReader^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IDataReader *wrapperInstance = new IDataReader(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> LoadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      ::Windows::Storage::Streams::DataReaderLoadOperation^ op;
    

      if (args.Length() == 2
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          op = wrapper->_instance->LoadAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> ReadByte(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned char result;
          result = wrapper->_instance->ReadByte();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBytes(const v8::Arguments& args)
    {
      HandleScope scope;
      ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Not implemented")));
      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->ReadBuffer(arg0);
          return scope.Close(WrapIBuffer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBoolean(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          bool result;
          result = wrapper->_instance->ReadBoolean();
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadGuid(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = wrapper->_instance->ReadGuid();
          return scope.Close(NodeRT::Utils::GuidToJs(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          short result;
          result = wrapper->_instance->ReadInt16();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          int result;
          result = wrapper->_instance->ReadInt32();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          __int64 result;
          result = wrapper->_instance->ReadInt64();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadUInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned short result;
          result = wrapper->_instance->ReadUInt16();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadUInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->ReadUInt32();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadUInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned __int64 result;
          result = wrapper->_instance->ReadUInt64();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadSingle(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          float result;
          result = wrapper->_instance->ReadSingle();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadDouble(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          double result;
          result = wrapper->_instance->ReadDouble();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          Platform::String^ result;
          result = wrapper->_instance->ReadString(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadDateTime(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::DateTime result;
          result = wrapper->_instance->ReadDateTime();
          return scope.Close(NodeRT::Utils::DateTimeToJS(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadTimeSpan(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::TimeSpan result;
          result = wrapper->_instance->ReadTimeSpan();
          return scope.Close(Number::New(result.Duration/10000.0));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          return scope.Close(WrapIBuffer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->DetachStream();
          return scope.Close(WrapIInputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> ByteOrderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(value->Int32Value());

        wrapper->_instance->ByteOrder = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> InputStreamOptionsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        ::Windows::Storage::Streams::InputStreamOptions result = wrapper->_instance->InputStreamOptions;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void InputStreamOptionsSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::InputStreamOptions winRtValue = static_cast<::Windows::Storage::Streams::InputStreamOptions>(value->Int32Value());

        wrapper->_instance->InputStreamOptions = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> UnconsumedBufferLengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->UnconsumedBufferLength;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> UnicodeEncodingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataReader^>(info.This()))
      {
        return;
      }

      IDataReader *wrapper = IDataReader::Unwrap<IDataReader>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(value->Int32Value());

        wrapper->_instance->UnicodeEncoding = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Storage::Streams::IDataReader^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIDataReader(::Windows::Storage::Streams::IDataReader^ wintRtInstance);
    friend ::Windows::Storage::Streams::IDataReader^ UnwrapIDataReader(Handle<Value> value);
    friend bool IsIDataReaderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IDataReader::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIDataReader(::Windows::Storage::Streams::IDataReader^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IDataReader::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IDataReader^ UnwrapIDataReader(Handle<Value> value)
  {
     return IDataReader::Unwrap<IDataReader>(value.As<Object>())->_instance;
  }

  void InitIDataReader(Handle<Object> exports)
  {
    IDataReader::Init(exports);
  }

  class DataReader : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("DataReader"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readByte"), FunctionTemplate::New(ReadByte)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readBytes"), FunctionTemplate::New(ReadBytes)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readBuffer"), FunctionTemplate::New(ReadBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readBoolean"), FunctionTemplate::New(ReadBoolean)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readGuid"), FunctionTemplate::New(ReadGuid)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readInt16"), FunctionTemplate::New(ReadInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readInt32"), FunctionTemplate::New(ReadInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readInt64"), FunctionTemplate::New(ReadInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readUInt16"), FunctionTemplate::New(ReadUInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readUInt32"), FunctionTemplate::New(ReadUInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readUInt64"), FunctionTemplate::New(ReadUInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readSingle"), FunctionTemplate::New(ReadSingle)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readDouble"), FunctionTemplate::New(ReadDouble)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readString"), FunctionTemplate::New(ReadString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readDateTime"), FunctionTemplate::New(ReadDateTime)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readTimeSpan"), FunctionTemplate::New(ReadTimeSpan)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachBuffer"), FunctionTemplate::New(DetachBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachStream"), FunctionTemplate::New(DetachStream)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(LoadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("loadAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unicodeEncoding"), UnicodeEncodingGetter, UnicodeEncodingSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("inputStreamOptions"), InputStreamOptionsGetter, InputStreamOptionsSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("byteOrder"), ByteOrderGetter, ByteOrderSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unconsumedBufferLength"), UnconsumedBufferLengthGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("fromBuffer"), FunctionTemplate::New(FromBuffer)->GetFunction());

      exports->Set(String::NewSymbol("DataReader"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    DataReader(::Windows::Storage::Streams::DataReader^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::DataReader^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::DataReader^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(args[0]);
          
          winRtInstance = ref new ::Windows::Storage::Streams::DataReader(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      DataReader *wrapperInstance = new DataReader(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> LoadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      ::Windows::Storage::Streams::DataReaderLoadOperation^ op;
    

      if (args.Length() == 2
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          op = wrapper->_instance->LoadAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> ReadByte(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned char result;
          result = wrapper->_instance->ReadByte();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBytes(const v8::Arguments& args)
    {
      HandleScope scope;
      ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Not implemented")));
      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->ReadBuffer(arg0);
          return scope.Close(WrapIBuffer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBoolean(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          bool result;
          result = wrapper->_instance->ReadBoolean();
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadGuid(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = wrapper->_instance->ReadGuid();
          return scope.Close(NodeRT::Utils::GuidToJs(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          short result;
          result = wrapper->_instance->ReadInt16();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          int result;
          result = wrapper->_instance->ReadInt32();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          __int64 result;
          result = wrapper->_instance->ReadInt64();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadUInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned short result;
          result = wrapper->_instance->ReadUInt16();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadUInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->ReadUInt32();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadUInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned __int64 result;
          result = wrapper->_instance->ReadUInt64();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadSingle(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          float result;
          result = wrapper->_instance->ReadSingle();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadDouble(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          double result;
          result = wrapper->_instance->ReadDouble();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          Platform::String^ result;
          result = wrapper->_instance->ReadString(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadDateTime(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::DateTime result;
          result = wrapper->_instance->ReadDateTime();
          return scope.Close(NodeRT::Utils::DateTimeToJS(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadTimeSpan(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::TimeSpan result;
          result = wrapper->_instance->ReadTimeSpan();
          return scope.Close(Number::New(result.Duration/10000.0));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          return scope.Close(WrapIBuffer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->DetachStream();
          return scope.Close(WrapIInputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> FromBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          ::Windows::Storage::Streams::DataReader^ result;
          result = ::Windows::Storage::Streams::DataReader::FromBuffer(arg0);
          return scope.Close(WrapDataReader(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> UnicodeEncodingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(value->Int32Value());

        wrapper->_instance->UnicodeEncoding = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> InputStreamOptionsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        ::Windows::Storage::Streams::InputStreamOptions result = wrapper->_instance->InputStreamOptions;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void InputStreamOptionsSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::InputStreamOptions winRtValue = static_cast<::Windows::Storage::Streams::InputStreamOptions>(value->Int32Value());

        wrapper->_instance->InputStreamOptions = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ByteOrderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return;
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(value->Int32Value());

        wrapper->_instance->ByteOrder = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> UnconsumedBufferLengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataReader^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataReader *wrapper = DataReader::Unwrap<DataReader>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->UnconsumedBufferLength;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::DataReader^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapDataReader(::Windows::Storage::Streams::DataReader^ wintRtInstance);
    friend ::Windows::Storage::Streams::DataReader^ UnwrapDataReader(Handle<Value> value);
    friend bool IsDataReaderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> DataReader::s_constructorTemplate;

  v8::Handle<v8::Value> WrapDataReader(::Windows::Storage::Streams::DataReader^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(DataReader::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::DataReader^ UnwrapDataReader(Handle<Value> value)
  {
     return DataReader::Unwrap<DataReader>(value.As<Object>())->_instance;
  }

  void InitDataReader(Handle<Object> exports)
  {
    DataReader::Init(exports);
  }

  class DataWriterStoreOperation : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("DataWriterStoreOperation"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getResults"), FunctionTemplate::New(GetResults)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cancel"), FunctionTemplate::New(Cancel)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("completed"), CompletedGetter, CompletedSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("errorCode"), ErrorCodeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("id"), IdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("status"), StatusGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("DataWriterStoreOperation"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    DataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::DataWriterStoreOperation^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::DataWriterStoreOperation^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      DataWriterStoreOperation *wrapperInstance = new DataWriterStoreOperation(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetResults(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->GetResults();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Cancel(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Cancel();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Close();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> CompletedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try 
      {
        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ result = wrapper->_instance->Completed;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "AsyncOperationCompletedHandler`1", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void CompletedSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(value))
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This()))
      {
        return;
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try 
      {
        
        ::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^ winRtValue = dynamic_cast<::Windows::Foundation::AsyncOperationCompletedHandler<unsigned int>^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Completed = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ErrorCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try 
      {
        ::Windows::Foundation::HResult result = wrapper->_instance->ErrorCode;
        return scope.Close(Integer::New(result.Value));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Id;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> StatusGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriterStoreOperation^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriterStoreOperation *wrapper = DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(info.This());

      try 
      {
        ::Windows::Foundation::AsyncStatus result = wrapper->_instance->Status;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::DataWriterStoreOperation^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapDataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ wintRtInstance);
    friend ::Windows::Storage::Streams::DataWriterStoreOperation^ UnwrapDataWriterStoreOperation(Handle<Value> value);
    friend bool IsDataWriterStoreOperationWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> DataWriterStoreOperation::s_constructorTemplate;

  v8::Handle<v8::Value> WrapDataWriterStoreOperation(::Windows::Storage::Streams::DataWriterStoreOperation^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(DataWriterStoreOperation::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::DataWriterStoreOperation^ UnwrapDataWriterStoreOperation(Handle<Value> value)
  {
     return DataWriterStoreOperation::Unwrap<DataWriterStoreOperation>(value.As<Object>())->_instance;
  }

  void InitDataWriterStoreOperation(Handle<Object> exports)
  {
    DataWriterStoreOperation::Init(exports);
  }

  class IDataWriter : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IDataWriter"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeByte"), FunctionTemplate::New(WriteByte)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeBytes"), FunctionTemplate::New(WriteBytes)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeBuffer"), FunctionTemplate::New(WriteBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeBoolean"), FunctionTemplate::New(WriteBoolean)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeGuid"), FunctionTemplate::New(WriteGuid)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeInt16"), FunctionTemplate::New(WriteInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeInt32"), FunctionTemplate::New(WriteInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeInt64"), FunctionTemplate::New(WriteInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeUInt16"), FunctionTemplate::New(WriteUInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeUInt32"), FunctionTemplate::New(WriteUInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeUInt64"), FunctionTemplate::New(WriteUInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeSingle"), FunctionTemplate::New(WriteSingle)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeDouble"), FunctionTemplate::New(WriteDouble)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeDateTime"), FunctionTemplate::New(WriteDateTime)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeTimeSpan"), FunctionTemplate::New(WriteTimeSpan)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeString"), FunctionTemplate::New(WriteString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("measureString"), FunctionTemplate::New(MeasureString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachBuffer"), FunctionTemplate::New(DetachBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachStream"), FunctionTemplate::New(DetachStream)->GetFunction());
      
            
      func = FunctionTemplate::New(StoreAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("storeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("byteOrder"), ByteOrderGetter, ByteOrderSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unicodeEncoding"), UnicodeEncodingGetter, UnicodeEncodingSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unstoredBufferLength"), UnstoredBufferLengthGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IDataWriter"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IDataWriter(::Windows::Storage::Streams::IDataWriter^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IDataWriter^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IDataWriter^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IDataWriter *wrapperInstance = new IDataWriter(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> StoreAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      ::Windows::Storage::Streams::DataWriterStoreOperation^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->StoreAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> WriteByte(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(args[0]->Int32Value());
          
          wrapper->_instance->WriteByte(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBytes(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          wrapper->_instance->WriteBytes(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          wrapper->_instance->WriteBuffer(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsUint32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          unsigned int arg2 = static_cast<unsigned int>(args[2]->IntegerValue());
          
          wrapper->_instance->WriteBuffer(arg0, arg1, arg2);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBoolean(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsBoolean())
      {
        try
        {
          bool arg0 = args[0]->BooleanValue();
          
          wrapper->_instance->WriteBoolean(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteGuid(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsGuid(args[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(args[0]);
          
          wrapper->_instance->WriteGuid(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          short arg0 = static_cast<short>(args[0]->Int32Value());
          
          wrapper->_instance->WriteInt16(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          int arg0 = static_cast<int>(args[0]->Int32Value());
          
          wrapper->_instance->WriteInt32(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          __int64 arg0 = args[0]->IntegerValue();
          
          wrapper->_instance->WriteInt64(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteUInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(args[0]->Int32Value());
          
          wrapper->_instance->WriteUInt16(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteUInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          wrapper->_instance->WriteUInt32(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteUInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->WriteUInt64(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteSingle(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          float arg0 = static_cast<float>(args[0]->NumberValue());
          
          wrapper->_instance->WriteSingle(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteDouble(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          double arg0 = args[0]->NumberValue();
          
          wrapper->_instance->WriteDouble(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteDateTime(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsDate())
      {
        try
        {
          ::Windows::Foundation::DateTime arg0 = NodeRT::Utils::DateTimeFromJSDate(args[0]);
          
          wrapper->_instance->WriteDateTime(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteTimeSpan(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          ::Windows::Foundation::TimeSpan arg0 = NodeRT::Utils::TimeSpanFromMilli(args[0]->IntegerValue());
          
          wrapper->_instance->WriteTimeSpan(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          unsigned int result;
          result = wrapper->_instance->WriteString(arg0);
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> MeasureString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          unsigned int result;
          result = wrapper->_instance->MeasureString(arg0);
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          return scope.Close(WrapIBuffer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->DetachStream();
          return scope.Close(WrapIOutputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> ByteOrderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try 
      {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This()))
      {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(value->Int32Value());

        wrapper->_instance->ByteOrder = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> UnicodeEncodingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try 
      {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This()))
      {
        return;
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(value->Int32Value());

        wrapper->_instance->UnicodeEncoding = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> UnstoredBufferLengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IDataWriter^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IDataWriter *wrapper = IDataWriter::Unwrap<IDataWriter>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->UnstoredBufferLength;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::IDataWriter^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIDataWriter(::Windows::Storage::Streams::IDataWriter^ wintRtInstance);
    friend ::Windows::Storage::Streams::IDataWriter^ UnwrapIDataWriter(Handle<Value> value);
    friend bool IsIDataWriterWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IDataWriter::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIDataWriter(::Windows::Storage::Streams::IDataWriter^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IDataWriter::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IDataWriter^ UnwrapIDataWriter(Handle<Value> value)
  {
     return IDataWriter::Unwrap<IDataWriter>(value.As<Object>())->_instance;
  }

  void InitIDataWriter(Handle<Object> exports)
  {
    IDataWriter::Init(exports);
  }

  class DataWriter : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("DataWriter"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeByte"), FunctionTemplate::New(WriteByte)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeBytes"), FunctionTemplate::New(WriteBytes)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeBuffer"), FunctionTemplate::New(WriteBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeBoolean"), FunctionTemplate::New(WriteBoolean)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeGuid"), FunctionTemplate::New(WriteGuid)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeInt16"), FunctionTemplate::New(WriteInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeInt32"), FunctionTemplate::New(WriteInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeInt64"), FunctionTemplate::New(WriteInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeUInt16"), FunctionTemplate::New(WriteUInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeUInt32"), FunctionTemplate::New(WriteUInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeUInt64"), FunctionTemplate::New(WriteUInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeSingle"), FunctionTemplate::New(WriteSingle)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeDouble"), FunctionTemplate::New(WriteDouble)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeDateTime"), FunctionTemplate::New(WriteDateTime)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeTimeSpan"), FunctionTemplate::New(WriteTimeSpan)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeString"), FunctionTemplate::New(WriteString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("measureString"), FunctionTemplate::New(MeasureString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachBuffer"), FunctionTemplate::New(DetachBuffer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("detachStream"), FunctionTemplate::New(DetachStream)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(StoreAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("storeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unicodeEncoding"), UnicodeEncodingGetter, UnicodeEncodingSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("byteOrder"), ByteOrderGetter, ByteOrderSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("unstoredBufferLength"), UnstoredBufferLengthGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("DataWriter"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    DataWriter(::Windows::Storage::Streams::DataWriter^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::DataWriter^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::DataWriter^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IOutputStream^ arg0 = UnwrapIOutputStream(args[0]);
          
          winRtInstance = ref new ::Windows::Storage::Streams::DataWriter(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 0)
      {
        try
        {
          winRtInstance = ref new ::Windows::Storage::Streams::DataWriter();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      DataWriter *wrapperInstance = new DataWriter(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> StoreAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      ::Windows::Storage::Streams::DataWriterStoreOperation^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->StoreAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> WriteByte(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(args[0]->Int32Value());
          
          wrapper->_instance->WriteByte(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBytes(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          wrapper->_instance->WriteBytes(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          wrapper->_instance->WriteBuffer(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsUint32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          unsigned int arg2 = static_cast<unsigned int>(args[2]->IntegerValue());
          
          wrapper->_instance->WriteBuffer(arg0, arg1, arg2);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBoolean(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsBoolean())
      {
        try
        {
          bool arg0 = args[0]->BooleanValue();
          
          wrapper->_instance->WriteBoolean(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteGuid(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsGuid(args[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(args[0]);
          
          wrapper->_instance->WriteGuid(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          short arg0 = static_cast<short>(args[0]->Int32Value());
          
          wrapper->_instance->WriteInt16(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          int arg0 = static_cast<int>(args[0]->Int32Value());
          
          wrapper->_instance->WriteInt32(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          __int64 arg0 = args[0]->IntegerValue();
          
          wrapper->_instance->WriteInt64(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteUInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(args[0]->Int32Value());
          
          wrapper->_instance->WriteUInt16(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteUInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          wrapper->_instance->WriteUInt32(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteUInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->WriteUInt64(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteSingle(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          float arg0 = static_cast<float>(args[0]->NumberValue());
          
          wrapper->_instance->WriteSingle(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteDouble(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          double arg0 = args[0]->NumberValue();
          
          wrapper->_instance->WriteDouble(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteDateTime(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsDate())
      {
        try
        {
          ::Windows::Foundation::DateTime arg0 = NodeRT::Utils::DateTimeFromJSDate(args[0]);
          
          wrapper->_instance->WriteDateTime(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteTimeSpan(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          ::Windows::Foundation::TimeSpan arg0 = NodeRT::Utils::TimeSpanFromMilli(args[0]->IntegerValue());
          
          wrapper->_instance->WriteTimeSpan(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          unsigned int result;
          result = wrapper->_instance->WriteString(arg0);
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> MeasureString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          unsigned int result;
          result = wrapper->_instance->MeasureString(arg0);
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachBuffer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ result;
          result = wrapper->_instance->DetachBuffer();
          return scope.Close(WrapIBuffer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DetachStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->DetachStream();
          return scope.Close(WrapIOutputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }




    static Handle<Value> UnicodeEncodingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try 
      {
        ::Windows::Storage::Streams::UnicodeEncoding result = wrapper->_instance->UnicodeEncoding;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void UnicodeEncodingSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This()))
      {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::UnicodeEncoding winRtValue = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(value->Int32Value());

        wrapper->_instance->UnicodeEncoding = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ByteOrderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try 
      {
        ::Windows::Storage::Streams::ByteOrder result = wrapper->_instance->ByteOrder;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void ByteOrderSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This()))
      {
        return;
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try 
      {
        
        ::Windows::Storage::Streams::ByteOrder winRtValue = static_cast<::Windows::Storage::Streams::ByteOrder>(value->Int32Value());

        wrapper->_instance->ByteOrder = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> UnstoredBufferLengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::DataWriter^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      DataWriter *wrapper = DataWriter::Unwrap<DataWriter>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->UnstoredBufferLength;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::DataWriter^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapDataWriter(::Windows::Storage::Streams::DataWriter^ wintRtInstance);
    friend ::Windows::Storage::Streams::DataWriter^ UnwrapDataWriter(Handle<Value> value);
    friend bool IsDataWriterWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> DataWriter::s_constructorTemplate;

  v8::Handle<v8::Value> WrapDataWriter(::Windows::Storage::Streams::DataWriter^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(DataWriter::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::DataWriter^ UnwrapDataWriter(Handle<Value> value)
  {
     return DataWriter::Unwrap<DataWriter>(value.As<Object>())->_instance;
  }

  void InitDataWriter(Handle<Object> exports)
  {
    DataWriter::Init(exports);
  }

  class RandomAccessStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("RandomAccessStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(CopyAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("copyAsync"), func);
      func = FunctionTemplate::New(CopyAndCloseAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("copyAndCloseAsync"), func);

      exports->Set(String::NewSymbol("RandomAccessStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    RandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::RandomAccessStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::RandomAccessStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      RandomAccessStream *wrapperInstance = new RandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  

    static Handle<Value> CopyAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args[1]))
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(args[0]);
          ::Windows::Storage::Streams::IOutputStream^ arg1 = UnwrapIOutputStream(args[1]);
          
          op = ::Windows::Storage::Streams::RandomAccessStream::CopyAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args[1])
        && args[2]->IsNumber())
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(args[0]);
          ::Windows::Storage::Streams::IOutputStream^ arg1 = UnwrapIOutputStream(args[1]);
          unsigned __int64 arg2 = static_cast<unsigned __int64>(args[2]->IntegerValue());
          
          op = ::Windows::Storage::Streams::RandomAccessStream::CopyAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned __int64> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Number::New(static_cast<double>(result));
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CopyAndCloseAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned __int64, unsigned __int64>^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args[1]))
      {
        try
        {
          ::Windows::Storage::Streams::IInputStream^ arg0 = UnwrapIInputStream(args[0]);
          ::Windows::Storage::Streams::IOutputStream^ arg1 = UnwrapIOutputStream(args[1]);
          
          op = ::Windows::Storage::Streams::RandomAccessStream::CopyAndCloseAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned __int64> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Number::New(static_cast<double>(result));
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }




  private:
    ::Windows::Storage::Streams::RandomAccessStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapRandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::RandomAccessStream^ UnwrapRandomAccessStream(Handle<Value> value);
    friend bool IsRandomAccessStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> RandomAccessStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapRandomAccessStream(::Windows::Storage::Streams::RandomAccessStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(RandomAccessStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::RandomAccessStream^ UnwrapRandomAccessStream(Handle<Value> value)
  {
     return RandomAccessStream::Unwrap<RandomAccessStream>(value.As<Object>())->_instance;
  }

  void InitRandomAccessStream(Handle<Object> exports)
  {
    RandomAccessStream::Init(exports);
  }

  class Buffer : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("Buffer"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("length"), LengthGetter, LengthSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("capacity"), CapacityGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("Buffer"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    Buffer(::Windows::Storage::Streams::Buffer^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::Buffer^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::Buffer^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          winRtInstance = ref new ::Windows::Storage::Streams::Buffer(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      Buffer *wrapperInstance = new Buffer(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> LengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Buffer *wrapper = Buffer::Unwrap<Buffer>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Length;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void LengthSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info.This()))
      {
        return;
      }

      Buffer *wrapper = Buffer::Unwrap<Buffer>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Length = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CapacityGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::Buffer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Buffer *wrapper = Buffer::Unwrap<Buffer>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Capacity;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::Buffer^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapBuffer(::Windows::Storage::Streams::Buffer^ wintRtInstance);
    friend ::Windows::Storage::Streams::Buffer^ UnwrapBuffer(Handle<Value> value);
    friend bool IsBufferWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> Buffer::s_constructorTemplate;

  v8::Handle<v8::Value> WrapBuffer(::Windows::Storage::Streams::Buffer^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(Buffer::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::Buffer^ UnwrapBuffer(Handle<Value> value)
  {
     return Buffer::Unwrap<Buffer>(value.As<Object>())->_instance;
  }

  void InitBuffer(Handle<Object> exports)
  {
    Buffer::Init(exports);
  }

  class IBuffer : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IBuffer"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("capacity"), CapacityGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("length"), LengthGetter, LengthSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IBuffer"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IBuffer(::Windows::Storage::Streams::IBuffer^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IBuffer^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IBuffer^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IBuffer *wrapperInstance = new IBuffer(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> CapacityGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IBuffer *wrapper = IBuffer::Unwrap<IBuffer>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Capacity;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LengthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IBuffer *wrapper = IBuffer::Unwrap<IBuffer>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Length;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void LengthSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsUint32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(info.This()))
      {
        return;
      }

      IBuffer *wrapper = IBuffer::Unwrap<IBuffer>(info.This());

      try 
      {
        
        unsigned int winRtValue = static_cast<unsigned int>(value->IntegerValue());

        wrapper->_instance->Length = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Storage::Streams::IBuffer^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIBuffer(::Windows::Storage::Streams::IBuffer^ wintRtInstance);
    friend ::Windows::Storage::Streams::IBuffer^ UnwrapIBuffer(Handle<Value> value);
    friend bool IsIBufferWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IBuffer::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIBuffer(::Windows::Storage::Streams::IBuffer^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IBuffer::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IBuffer^ UnwrapIBuffer(Handle<Value> value)
  {
     return IBuffer::Unwrap<IBuffer>(value.As<Object>())->_instance;
  }

  void InitIBuffer(Handle<Object> exports)
  {
    IBuffer::Init(exports);
  }

  class IContentTypeProvider : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IContentTypeProvider"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("contentType"), ContentTypeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IContentTypeProvider"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IContentTypeProvider^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IContentTypeProvider^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IContentTypeProvider^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IContentTypeProvider *wrapperInstance = new IContentTypeProvider(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> ContentTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IContentTypeProvider^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IContentTypeProvider *wrapper = IContentTypeProvider::Unwrap<IContentTypeProvider>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->ContentType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::IContentTypeProvider^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ wintRtInstance);
    friend ::Windows::Storage::Streams::IContentTypeProvider^ UnwrapIContentTypeProvider(Handle<Value> value);
    friend bool IsIContentTypeProviderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IContentTypeProvider::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIContentTypeProvider(::Windows::Storage::Streams::IContentTypeProvider^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IContentTypeProvider::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IContentTypeProvider^ UnwrapIContentTypeProvider(Handle<Value> value)
  {
     return IContentTypeProvider::Unwrap<IContentTypeProvider>(value.As<Object>())->_instance;
  }

  void InitIContentTypeProvider(Handle<Object> exports)
  {
    IContentTypeProvider::Init(exports);
  }

  class IRandomAccessStreamReference : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IRandomAccessStreamReference"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(OpenReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openReadAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IRandomAccessStreamReference"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IRandomAccessStreamReference^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IRandomAccessStreamReference^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IRandomAccessStreamReference *wrapperInstance = new IRandomAccessStreamReference(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> OpenReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IRandomAccessStreamReference *wrapper = IRandomAccessStreamReference::Unwrap<IRandomAccessStreamReference>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIRandomAccessStreamWithContentType(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::Streams::IRandomAccessStreamReference^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ wintRtInstance);
    friend ::Windows::Storage::Streams::IRandomAccessStreamReference^ UnwrapIRandomAccessStreamReference(Handle<Value> value);
    friend bool IsIRandomAccessStreamReferenceWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IRandomAccessStreamReference::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIRandomAccessStreamReference(::Windows::Storage::Streams::IRandomAccessStreamReference^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IRandomAccessStreamReference::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IRandomAccessStreamReference^ UnwrapIRandomAccessStreamReference(Handle<Value> value)
  {
     return IRandomAccessStreamReference::Unwrap<IRandomAccessStreamReference>(value.As<Object>())->_instance;
  }

  void InitIRandomAccessStreamReference(Handle<Object> exports)
  {
    IRandomAccessStreamReference::Init(exports);
  }

  class IInputStreamReference : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IInputStreamReference"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(OpenSequentialReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openSequentialReadAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IInputStreamReference"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IInputStreamReference^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStreamReference^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IInputStreamReference^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IInputStreamReference *wrapperInstance = new IInputStreamReference(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> OpenSequentialReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStreamReference^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IInputStreamReference *wrapper = IInputStreamReference::Unwrap<IInputStreamReference>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IInputStream^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenSequentialReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IInputStream^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIInputStream(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::Streams::IInputStreamReference^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ wintRtInstance);
    friend ::Windows::Storage::Streams::IInputStreamReference^ UnwrapIInputStreamReference(Handle<Value> value);
    friend bool IsIInputStreamReferenceWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IInputStreamReference::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIInputStreamReference(::Windows::Storage::Streams::IInputStreamReference^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IInputStreamReference::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IInputStreamReference^ UnwrapIInputStreamReference(Handle<Value> value)
  {
     return IInputStreamReference::Unwrap<IInputStreamReference>(value.As<Object>())->_instance;
  }

  void InitIInputStreamReference(Handle<Object> exports)
  {
    IInputStreamReference::Init(exports);
  }

  class RandomAccessStreamReference : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("RandomAccessStreamReference"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(OpenReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openReadAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("createFromFile"), FunctionTemplate::New(CreateFromFile)->GetFunction());
      constructor->Set(String::NewSymbol("createFromUri"), FunctionTemplate::New(CreateFromUri)->GetFunction());
      constructor->Set(String::NewSymbol("createFromStream"), FunctionTemplate::New(CreateFromStream)->GetFunction());

      exports->Set(String::NewSymbol("RandomAccessStreamReference"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    RandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::RandomAccessStreamReference^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamReference^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::RandomAccessStreamReference^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      RandomAccessStreamReference *wrapperInstance = new RandomAccessStreamReference(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> OpenReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamReference^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      RandomAccessStreamReference *wrapper = RandomAccessStreamReference::Unwrap<RandomAccessStreamReference>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIRandomAccessStreamWithContentType(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  


    static Handle<Value> CreateFromFile(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = dynamic_cast<::Windows::Storage::IStorageFile^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          ::Windows::Storage::Streams::RandomAccessStreamReference^ result;
          result = ::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromFile(arg0);
          return scope.Close(WrapRandomAccessStreamReference(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFromUri(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args[0]))
      {
        try
        {
          ::Windows::Foundation::Uri^ arg0 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          ::Windows::Storage::Streams::RandomAccessStreamReference^ result;
          result = ::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromUri(arg0);
          return scope.Close(WrapRandomAccessStreamReference(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFromStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ arg0 = UnwrapIRandomAccessStream(args[0]);
          
          ::Windows::Storage::Streams::RandomAccessStreamReference^ result;
          result = ::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromStream(arg0);
          return scope.Close(WrapRandomAccessStreamReference(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



  private:
    ::Windows::Storage::Streams::RandomAccessStreamReference^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapRandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ wintRtInstance);
    friend ::Windows::Storage::Streams::RandomAccessStreamReference^ UnwrapRandomAccessStreamReference(Handle<Value> value);
    friend bool IsRandomAccessStreamReferenceWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> RandomAccessStreamReference::s_constructorTemplate;

  v8::Handle<v8::Value> WrapRandomAccessStreamReference(::Windows::Storage::Streams::RandomAccessStreamReference^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(RandomAccessStreamReference::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::RandomAccessStreamReference^ UnwrapRandomAccessStreamReference(Handle<Value> value)
  {
     return RandomAccessStreamReference::Unwrap<RandomAccessStreamReference>(value.As<Object>())->_instance;
  }

  void InitRandomAccessStreamReference(Handle<Object> exports)
  {
    RandomAccessStreamReference::Init(exports);
  }

  class FileRandomAccessStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileRandomAccessStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInputStreamAt"), FunctionTemplate::New(GetInputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getOutputStreamAt"), FunctionTemplate::New(GetOutputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("seek"), FunctionTemplate::New(Seek)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cloneStream"), FunctionTemplate::New(CloneStream)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("size"), SizeGetter, SizeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canRead"), CanReadGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canWrite"), CanWriteGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("position"), PositionGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("FileRandomAccessStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::FileRandomAccessStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::FileRandomAccessStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileRandomAccessStream *wrapperInstance = new FileRandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIBuffer(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> GetInputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          return scope.Close(WrapIInputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetOutputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          return scope.Close(WrapIOutputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Seek(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->Seek(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CloneStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          return scope.Close(WrapIRandomAccessStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }




    static Handle<Value> SizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Size;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SizeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsNumber())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This()))
      {
        return;
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try 
      {
        
        unsigned __int64 winRtValue = static_cast<unsigned __int64>(value->IntegerValue());

        wrapper->_instance->Size = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CanReadGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanRead;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CanWriteGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanWrite;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PositionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileRandomAccessStream *wrapper = FileRandomAccessStream::Unwrap<FileRandomAccessStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Position;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::FileRandomAccessStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::FileRandomAccessStream^ UnwrapFileRandomAccessStream(Handle<Value> value);
    friend bool IsFileRandomAccessStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileRandomAccessStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileRandomAccessStream(::Windows::Storage::Streams::FileRandomAccessStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileRandomAccessStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::FileRandomAccessStream^ UnwrapFileRandomAccessStream(Handle<Value> value)
  {
     return FileRandomAccessStream::Unwrap<FileRandomAccessStream>(value.As<Object>())->_instance;
  }

  void InitFileRandomAccessStream(Handle<Object> exports)
  {
    FileRandomAccessStream::Init(exports);
  }

  class FileInputStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileInputStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("FileInputStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileInputStream(::Windows::Storage::Streams::FileInputStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::FileInputStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::FileInputStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileInputStream *wrapperInstance = new FileInputStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      FileInputStream *wrapper = FileInputStream::Unwrap<FileInputStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIBuffer(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileInputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileInputStream *wrapper = FileInputStream::Unwrap<FileInputStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }






  private:
    ::Windows::Storage::Streams::FileInputStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileInputStream(::Windows::Storage::Streams::FileInputStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::FileInputStream^ UnwrapFileInputStream(Handle<Value> value);
    friend bool IsFileInputStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileInputStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileInputStream(::Windows::Storage::Streams::FileInputStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileInputStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::FileInputStream^ UnwrapFileInputStream(Handle<Value> value)
  {
     return FileInputStream::Unwrap<FileInputStream>(value.As<Object>())->_instance;
  }

  void InitFileInputStream(Handle<Object> exports)
  {
    FileInputStream::Init(exports);
  }

  class FileOutputStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileOutputStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("FileOutputStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileOutputStream(::Windows::Storage::Streams::FileOutputStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::FileOutputStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::FileOutputStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileOutputStream *wrapperInstance = new FileOutputStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      FileOutputStream *wrapper = FileOutputStream::Unwrap<FileOutputStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      FileOutputStream *wrapper = FileOutputStream::Unwrap<FileOutputStream>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::FileOutputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileOutputStream *wrapper = FileOutputStream::Unwrap<FileOutputStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }






  private:
    ::Windows::Storage::Streams::FileOutputStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileOutputStream(::Windows::Storage::Streams::FileOutputStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::FileOutputStream^ UnwrapFileOutputStream(Handle<Value> value);
    friend bool IsFileOutputStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileOutputStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileOutputStream(::Windows::Storage::Streams::FileOutputStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileOutputStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::FileOutputStream^ UnwrapFileOutputStream(Handle<Value> value)
  {
     return FileOutputStream::Unwrap<FileOutputStream>(value.As<Object>())->_instance;
  }

  void InitFileOutputStream(Handle<Object> exports)
  {
    FileOutputStream::Init(exports);
  }

  class RandomAccessStreamOverStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("RandomAccessStreamOverStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInputStreamAt"), FunctionTemplate::New(GetInputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getOutputStreamAt"), FunctionTemplate::New(GetOutputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("seek"), FunctionTemplate::New(Seek)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cloneStream"), FunctionTemplate::New(CloneStream)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("size"), SizeGetter, SizeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canRead"), CanReadGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canWrite"), CanWriteGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("position"), PositionGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("RandomAccessStreamOverStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    RandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::RandomAccessStreamOverStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::RandomAccessStreamOverStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      RandomAccessStreamOverStream *wrapperInstance = new RandomAccessStreamOverStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIBuffer(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> GetInputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          return scope.Close(WrapIInputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetOutputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          return scope.Close(WrapIOutputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Seek(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->Seek(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CloneStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          return scope.Close(WrapIRandomAccessStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }




    static Handle<Value> SizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Size;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SizeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsNumber())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This()))
      {
        return;
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try 
      {
        
        unsigned __int64 winRtValue = static_cast<unsigned __int64>(value->IntegerValue());

        wrapper->_instance->Size = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CanReadGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanRead;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CanWriteGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanWrite;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PositionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::RandomAccessStreamOverStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      RandomAccessStreamOverStream *wrapper = RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Position;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::RandomAccessStreamOverStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapRandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::RandomAccessStreamOverStream^ UnwrapRandomAccessStreamOverStream(Handle<Value> value);
    friend bool IsRandomAccessStreamOverStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> RandomAccessStreamOverStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapRandomAccessStreamOverStream(::Windows::Storage::Streams::RandomAccessStreamOverStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(RandomAccessStreamOverStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::RandomAccessStreamOverStream^ UnwrapRandomAccessStreamOverStream(Handle<Value> value)
  {
     return RandomAccessStreamOverStream::Unwrap<RandomAccessStreamOverStream>(value.As<Object>())->_instance;
  }

  void InitRandomAccessStreamOverStream(Handle<Object> exports)
  {
    RandomAccessStreamOverStream::Init(exports);
  }

  class InputStreamOverStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("InputStreamOverStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("InputStreamOverStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    InputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::InputStreamOverStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::InputStreamOverStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      InputStreamOverStream *wrapperInstance = new InputStreamOverStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      InputStreamOverStream *wrapper = InputStreamOverStream::Unwrap<InputStreamOverStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIBuffer(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InputStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      InputStreamOverStream *wrapper = InputStreamOverStream::Unwrap<InputStreamOverStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }






  private:
    ::Windows::Storage::Streams::InputStreamOverStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapInputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::InputStreamOverStream^ UnwrapInputStreamOverStream(Handle<Value> value);
    friend bool IsInputStreamOverStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> InputStreamOverStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapInputStreamOverStream(::Windows::Storage::Streams::InputStreamOverStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(InputStreamOverStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::InputStreamOverStream^ UnwrapInputStreamOverStream(Handle<Value> value)
  {
     return InputStreamOverStream::Unwrap<InputStreamOverStream>(value.As<Object>())->_instance;
  }

  void InitInputStreamOverStream(Handle<Object> exports)
  {
    InputStreamOverStream::Init(exports);
  }

  class OutputStreamOverStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("OutputStreamOverStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("OutputStreamOverStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    OutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::OutputStreamOverStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::OutputStreamOverStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      OutputStreamOverStream *wrapperInstance = new OutputStreamOverStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      OutputStreamOverStream *wrapper = OutputStreamOverStream::Unwrap<OutputStreamOverStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      OutputStreamOverStream *wrapper = OutputStreamOverStream::Unwrap<OutputStreamOverStream>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::OutputStreamOverStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      OutputStreamOverStream *wrapper = OutputStreamOverStream::Unwrap<OutputStreamOverStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }






  private:
    ::Windows::Storage::Streams::OutputStreamOverStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapOutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::OutputStreamOverStream^ UnwrapOutputStreamOverStream(Handle<Value> value);
    friend bool IsOutputStreamOverStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> OutputStreamOverStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapOutputStreamOverStream(::Windows::Storage::Streams::OutputStreamOverStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(OutputStreamOverStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::OutputStreamOverStream^ UnwrapOutputStreamOverStream(Handle<Value> value)
  {
     return OutputStreamOverStream::Unwrap<OutputStreamOverStream>(value.As<Object>())->_instance;
  }

  void InitOutputStreamOverStream(Handle<Object> exports)
  {
    OutputStreamOverStream::Init(exports);
  }

  class InMemoryRandomAccessStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("InMemoryRandomAccessStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInputStreamAt"), FunctionTemplate::New(GetInputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getOutputStreamAt"), FunctionTemplate::New(GetOutputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("seek"), FunctionTemplate::New(Seek)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cloneStream"), FunctionTemplate::New(CloneStream)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("size"), SizeGetter, SizeSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canRead"), CanReadGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canWrite"), CanWriteGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("position"), PositionGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("InMemoryRandomAccessStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    InMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::InMemoryRandomAccessStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::InMemoryRandomAccessStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 0)
      {
        try
        {
          winRtInstance = ref new ::Windows::Storage::Streams::InMemoryRandomAccessStream();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      InMemoryRandomAccessStream *wrapperInstance = new InMemoryRandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIBuffer(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> GetInputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          return scope.Close(WrapIInputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetOutputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          return scope.Close(WrapIOutputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Seek(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->Seek(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CloneStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          return scope.Close(WrapIRandomAccessStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }




    static Handle<Value> SizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Size;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SizeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsNumber())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This()))
      {
        return;
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try 
      {
        
        unsigned __int64 winRtValue = static_cast<unsigned __int64>(value->IntegerValue());

        wrapper->_instance->Size = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> CanReadGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanRead;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CanWriteGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanWrite;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PositionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::InMemoryRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      InMemoryRandomAccessStream *wrapper = InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Position;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Streams::InMemoryRandomAccessStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapInMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::InMemoryRandomAccessStream^ UnwrapInMemoryRandomAccessStream(Handle<Value> value);
    friend bool IsInMemoryRandomAccessStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> InMemoryRandomAccessStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapInMemoryRandomAccessStream(::Windows::Storage::Streams::InMemoryRandomAccessStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(InMemoryRandomAccessStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::InMemoryRandomAccessStream^ UnwrapInMemoryRandomAccessStream(Handle<Value> value)
  {
     return InMemoryRandomAccessStream::Unwrap<InMemoryRandomAccessStream>(value.As<Object>())->_instance;
  }

  void InitInMemoryRandomAccessStream(Handle<Object> exports)
  {
    InMemoryRandomAccessStream::Init(exports);
  }

  class IInputStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IInputStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(ReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("readAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IInputStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IInputStream(::Windows::Storage::Streams::IInputStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IInputStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IInputStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IInputStream *wrapperInstance = new IInputStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> ReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IInputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IInputStream *wrapper = IInputStream::Unwrap<IInputStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<::Windows::Storage::Streams::IBuffer^, unsigned int>^ op;
    

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0])
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::Streams::InputStreamOptions arg2 = static_cast<::Windows::Storage::Streams::InputStreamOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->ReadAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIBuffer(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::Streams::IInputStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIInputStream(::Windows::Storage::Streams::IInputStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::IInputStream^ UnwrapIInputStream(Handle<Value> value);
    friend bool IsIInputStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IInputStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIInputStream(::Windows::Storage::Streams::IInputStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IInputStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IInputStream^ UnwrapIInputStream(Handle<Value> value)
  {
     return IInputStream::Unwrap<IInputStream>(value.As<Object>())->_instance;
  }

  void InitIInputStream(Handle<Object> exports)
  {
    IInputStream::Init(exports);
  }

  class IOutputStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IOutputStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IOutputStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IOutputStream(::Windows::Storage::Streams::IOutputStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IOutputStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IOutputStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IOutputStream *wrapperInstance = new IOutputStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IOutputStream *wrapper = IOutputStream::Unwrap<IOutputStream>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = UnwrapIBuffer(args[0]);
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IOutputStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IOutputStream *wrapper = IOutputStream::Unwrap<IOutputStream>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::Streams::IOutputStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIOutputStream(::Windows::Storage::Streams::IOutputStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::IOutputStream^ UnwrapIOutputStream(Handle<Value> value);
    friend bool IsIOutputStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IOutputStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIOutputStream(::Windows::Storage::Streams::IOutputStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IOutputStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IOutputStream^ UnwrapIOutputStream(Handle<Value> value)
  {
     return IOutputStream::Unwrap<IOutputStream>(value.As<Object>())->_instance;
  }

  void InitIOutputStream(Handle<Object> exports)
  {
    IOutputStream::Init(exports);
  }

  class IRandomAccessStream : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IRandomAccessStream"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInputStreamAt"), FunctionTemplate::New(GetInputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getOutputStreamAt"), FunctionTemplate::New(GetOutputStreamAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("seek"), FunctionTemplate::New(Seek)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cloneStream"), FunctionTemplate::New(CloneStream)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canRead"), CanReadGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("canWrite"), CanWriteGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("position"), PositionGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("size"), SizeGetter, SizeSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IRandomAccessStream"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IRandomAccessStream^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IRandomAccessStream^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IRandomAccessStream *wrapperInstance = new IRandomAccessStream(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetInputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IInputStream^ result;
          result = wrapper->_instance->GetInputStreamAt(arg0);
          return scope.Close(WrapIInputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetOutputStreamAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Windows::Storage::Streams::IOutputStream^ result;
          result = wrapper->_instance->GetOutputStreamAt(arg0);
          return scope.Close(WrapIOutputStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Seek(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(args.This());

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          wrapper->_instance->Seek(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CloneStream(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Streams::IRandomAccessStream^ result;
          result = wrapper->_instance->CloneStream();
          return scope.Close(WrapIRandomAccessStream(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> CanReadGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanRead;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CanWriteGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try 
      {
        bool result = wrapper->_instance->CanWrite;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PositionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Position;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->Size;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void SizeSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsNumber())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStream^>(info.This()))
      {
        return;
      }

      IRandomAccessStream *wrapper = IRandomAccessStream::Unwrap<IRandomAccessStream>(info.This());

      try 
      {
        
        unsigned __int64 winRtValue = static_cast<unsigned __int64>(value->IntegerValue());

        wrapper->_instance->Size = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Storage::Streams::IRandomAccessStream^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ wintRtInstance);
    friend ::Windows::Storage::Streams::IRandomAccessStream^ UnwrapIRandomAccessStream(Handle<Value> value);
    friend bool IsIRandomAccessStreamWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IRandomAccessStream::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIRandomAccessStream(::Windows::Storage::Streams::IRandomAccessStream^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IRandomAccessStream::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IRandomAccessStream^ UnwrapIRandomAccessStream(Handle<Value> value)
  {
     return IRandomAccessStream::Unwrap<IRandomAccessStream>(value.As<Object>())->_instance;
  }

  void InitIRandomAccessStream(Handle<Object> exports)
  {
    IRandomAccessStream::Init(exports);
  }

  class IRandomAccessStreamWithContentType : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IRandomAccessStreamWithContentType"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IRandomAccessStreamWithContentType"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Streams::IRandomAccessStreamWithContentType^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IRandomAccessStreamWithContentType *wrapperInstance = new IRandomAccessStreamWithContentType(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  





  private:
    ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ wintRtInstance);
    friend ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ UnwrapIRandomAccessStreamWithContentType(Handle<Value> value);
    friend bool IsIRandomAccessStreamWithContentTypeWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IRandomAccessStreamWithContentType::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIRandomAccessStreamWithContentType(::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IRandomAccessStreamWithContentType::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Streams::IRandomAccessStreamWithContentType^ UnwrapIRandomAccessStreamWithContentType(Handle<Value> value)
  {
     return IRandomAccessStreamWithContentType::Unwrap<IRandomAccessStreamWithContentType>(value.As<Object>())->_instance;
  }

  void InitIRandomAccessStreamWithContentType(Handle<Object> exports)
  {
    IRandomAccessStreamWithContentType::Init(exports);
  }

} } } } 

void init(Handle<Object> exports)
{
  if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
  {
    ThrowException(v8::Exception::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
    return;
  }
  
  NodeRT::Windows::Storage::Streams::InitByteOrderEnum(exports);
  NodeRT::Windows::Storage::Streams::InitUnicodeEncodingEnum(exports);
  NodeRT::Windows::Storage::Streams::InitInputStreamOptionsEnum(exports);
  NodeRT::Windows::Storage::Streams::InitDataReaderLoadOperation(exports);
  NodeRT::Windows::Storage::Streams::InitIDataReader(exports);
  NodeRT::Windows::Storage::Streams::InitDataReader(exports);
  NodeRT::Windows::Storage::Streams::InitDataWriterStoreOperation(exports);
  NodeRT::Windows::Storage::Streams::InitIDataWriter(exports);
  NodeRT::Windows::Storage::Streams::InitDataWriter(exports);
  NodeRT::Windows::Storage::Streams::InitRandomAccessStream(exports);
  NodeRT::Windows::Storage::Streams::InitBuffer(exports);
  NodeRT::Windows::Storage::Streams::InitIBuffer(exports);
  NodeRT::Windows::Storage::Streams::InitIContentTypeProvider(exports);
  NodeRT::Windows::Storage::Streams::InitIRandomAccessStreamReference(exports);
  NodeRT::Windows::Storage::Streams::InitIInputStreamReference(exports);
  NodeRT::Windows::Storage::Streams::InitRandomAccessStreamReference(exports);
  NodeRT::Windows::Storage::Streams::InitFileRandomAccessStream(exports);
  NodeRT::Windows::Storage::Streams::InitFileInputStream(exports);
  NodeRT::Windows::Storage::Streams::InitFileOutputStream(exports);
  NodeRT::Windows::Storage::Streams::InitRandomAccessStreamOverStream(exports);
  NodeRT::Windows::Storage::Streams::InitInputStreamOverStream(exports);
  NodeRT::Windows::Storage::Streams::InitOutputStreamOverStream(exports);
  NodeRT::Windows::Storage::Streams::InitInMemoryRandomAccessStream(exports);
  NodeRT::Windows::Storage::Streams::InitIInputStream(exports);
  NodeRT::Windows::Storage::Streams::InitIOutputStream(exports);
  NodeRT::Windows::Storage::Streams::InitIRandomAccessStream(exports);
  NodeRT::Windows::Storage::Streams::InitIRandomAccessStreamWithContentType(exports);

  NodeRT::Utils::RegisterNameSpace("Windows.Storage.Streams", exports);
}


NODE_MODULE(binding, init)