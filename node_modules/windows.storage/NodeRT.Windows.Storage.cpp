// Copyright (c) Microsoft Corporation
// All rights reserved. 
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 
//
// See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.

#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include <string>
#include <node_object_wrap.h>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using namespace v8;
using namespace node;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Storage { 
  v8::Handle<v8::Value> WrapStorageLibrary(::Windows::Storage::StorageLibrary^ wintRtInstance);
  ::Windows::Storage::StorageLibrary^ UnwrapStorageLibrary(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapStorageFolder(::Windows::Storage::StorageFolder^ wintRtInstance);
  ::Windows::Storage::StorageFolder^ UnwrapStorageFolder(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapKnownFolders(::Windows::Storage::KnownFolders^ wintRtInstance);
  ::Windows::Storage::KnownFolders^ UnwrapKnownFolders(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapStorageFile(::Windows::Storage::StorageFile^ wintRtInstance);
  ::Windows::Storage::StorageFile^ UnwrapStorageFile(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapDownloadsFolder(::Windows::Storage::DownloadsFolder^ wintRtInstance);
  ::Windows::Storage::DownloadsFolder^ UnwrapDownloadsFolder(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStreamedFileDataRequest(::Windows::Storage::IStreamedFileDataRequest^ wintRtInstance);
  ::Windows::Storage::IStreamedFileDataRequest^ UnwrapIStreamedFileDataRequest(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapStreamedFileDataRequest(::Windows::Storage::StreamedFileDataRequest^ wintRtInstance);
  ::Windows::Storage::StreamedFileDataRequest^ UnwrapStreamedFileDataRequest(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapStorageStreamTransaction(::Windows::Storage::StorageStreamTransaction^ wintRtInstance);
  ::Windows::Storage::StorageStreamTransaction^ UnwrapStorageStreamTransaction(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageItem(::Windows::Storage::IStorageItem^ wintRtInstance);
  ::Windows::Storage::IStorageItem^ UnwrapIStorageItem(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageFolder(::Windows::Storage::IStorageFolder^ wintRtInstance);
  ::Windows::Storage::IStorageFolder^ UnwrapIStorageFolder(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageFile(::Windows::Storage::IStorageFile^ wintRtInstance);
  ::Windows::Storage::IStorageFile^ UnwrapIStorageFile(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageItem2(::Windows::Storage::IStorageItem2^ wintRtInstance);
  ::Windows::Storage::IStorageItem2^ UnwrapIStorageItem2(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageItemProperties(::Windows::Storage::IStorageItemProperties^ wintRtInstance);
  ::Windows::Storage::IStorageItemProperties^ UnwrapIStorageItemProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageItemProperties2(::Windows::Storage::IStorageItemProperties2^ wintRtInstance);
  ::Windows::Storage::IStorageItemProperties2^ UnwrapIStorageItemProperties2(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageItemPropertiesWithProvider(::Windows::Storage::IStorageItemPropertiesWithProvider^ wintRtInstance);
  ::Windows::Storage::IStorageItemPropertiesWithProvider^ UnwrapIStorageItemPropertiesWithProvider(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapStorageProvider(::Windows::Storage::StorageProvider^ wintRtInstance);
  ::Windows::Storage::StorageProvider^ UnwrapStorageProvider(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageFilePropertiesWithAvailability(::Windows::Storage::IStorageFilePropertiesWithAvailability^ wintRtInstance);
  ::Windows::Storage::IStorageFilePropertiesWithAvailability^ UnwrapIStorageFilePropertiesWithAvailability(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStorageFolder2(::Windows::Storage::IStorageFolder2^ wintRtInstance);
  ::Windows::Storage::IStorageFolder2^ UnwrapIStorageFolder2(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileIO(::Windows::Storage::FileIO^ wintRtInstance);
  ::Windows::Storage::FileIO^ UnwrapFileIO(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapPathIO(::Windows::Storage::PathIO^ wintRtInstance);
  ::Windows::Storage::PathIO^ UnwrapPathIO(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapCachedFileManager(::Windows::Storage::CachedFileManager^ wintRtInstance);
  ::Windows::Storage::CachedFileManager^ UnwrapCachedFileManager(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemAudioProperties(::Windows::Storage::SystemAudioProperties^ wintRtInstance);
  ::Windows::Storage::SystemAudioProperties^ UnwrapSystemAudioProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemGPSProperties(::Windows::Storage::SystemGPSProperties^ wintRtInstance);
  ::Windows::Storage::SystemGPSProperties^ UnwrapSystemGPSProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemImageProperties(::Windows::Storage::SystemImageProperties^ wintRtInstance);
  ::Windows::Storage::SystemImageProperties^ UnwrapSystemImageProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemMediaProperties(::Windows::Storage::SystemMediaProperties^ wintRtInstance);
  ::Windows::Storage::SystemMediaProperties^ UnwrapSystemMediaProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemMusicProperties(::Windows::Storage::SystemMusicProperties^ wintRtInstance);
  ::Windows::Storage::SystemMusicProperties^ UnwrapSystemMusicProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemPhotoProperties(::Windows::Storage::SystemPhotoProperties^ wintRtInstance);
  ::Windows::Storage::SystemPhotoProperties^ UnwrapSystemPhotoProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemVideoProperties(::Windows::Storage::SystemVideoProperties^ wintRtInstance);
  ::Windows::Storage::SystemVideoProperties^ UnwrapSystemVideoProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSystemProperties(::Windows::Storage::SystemProperties^ wintRtInstance);
  ::Windows::Storage::SystemProperties^ UnwrapSystemProperties(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapApplicationData(::Windows::Storage::ApplicationData^ wintRtInstance);
  ::Windows::Storage::ApplicationData^ UnwrapApplicationData(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSetVersionRequest(::Windows::Storage::SetVersionRequest^ wintRtInstance);
  ::Windows::Storage::SetVersionRequest^ UnwrapSetVersionRequest(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapApplicationDataContainer(::Windows::Storage::ApplicationDataContainer^ wintRtInstance);
  ::Windows::Storage::ApplicationDataContainer^ UnwrapApplicationDataContainer(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapSetVersionDeferral(::Windows::Storage::SetVersionDeferral^ wintRtInstance);
  ::Windows::Storage::SetVersionDeferral^ UnwrapSetVersionDeferral(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapApplicationDataContainerSettings(::Windows::Storage::ApplicationDataContainerSettings^ wintRtInstance);
  ::Windows::Storage::ApplicationDataContainerSettings^ UnwrapApplicationDataContainerSettings(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapApplicationDataCompositeValue(::Windows::Storage::ApplicationDataCompositeValue^ wintRtInstance);
  ::Windows::Storage::ApplicationDataCompositeValue^ UnwrapApplicationDataCompositeValue(Handle<Value> value);
  


  static v8::Handle<v8::Value> InitKnownLibraryIdEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("KnownLibraryId"), enumObject);

    enumObject->Set(String::NewSymbol("music"), Integer::New(0));
    enumObject->Set(String::NewSymbol("pictures"), Integer::New(1));
    enumObject->Set(String::NewSymbol("videos"), Integer::New(2));
    enumObject->Set(String::NewSymbol("documents"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitCreationCollisionOptionEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("CreationCollisionOption"), enumObject);

    enumObject->Set(String::NewSymbol("generateUniqueName"), Integer::New(0));
    enumObject->Set(String::NewSymbol("replaceExisting"), Integer::New(1));
    enumObject->Set(String::NewSymbol("failIfExists"), Integer::New(2));
    enumObject->Set(String::NewSymbol("openIfExists"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitNameCollisionOptionEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("NameCollisionOption"), enumObject);

    enumObject->Set(String::NewSymbol("generateUniqueName"), Integer::New(0));
    enumObject->Set(String::NewSymbol("replaceExisting"), Integer::New(1));
    enumObject->Set(String::NewSymbol("failIfExists"), Integer::New(2));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitStorageDeleteOptionEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("StorageDeleteOption"), enumObject);

    enumObject->Set(String::NewSymbol("default"), Integer::New(0));
    enumObject->Set(String::NewSymbol("permanentDelete"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitStorageItemTypesEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("StorageItemTypes"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("file"), Integer::New(1));
    enumObject->Set(String::NewSymbol("folder"), Integer::New(2));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitFileAttributesEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("FileAttributes"), enumObject);

    enumObject->Set(String::NewSymbol("normal"), Integer::New(0));
    enumObject->Set(String::NewSymbol("readOnly"), Integer::New(1));
    enumObject->Set(String::NewSymbol("directory"), Integer::New(2));
    enumObject->Set(String::NewSymbol("archive"), Integer::New(3));
    enumObject->Set(String::NewSymbol("temporary"), Integer::New(4));
    enumObject->Set(String::NewSymbol("locallyIncomplete"), Integer::New(5));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitFileAccessModeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("FileAccessMode"), enumObject);

    enumObject->Set(String::NewSymbol("read"), Integer::New(0));
    enumObject->Set(String::NewSymbol("readWrite"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitStreamedFileFailureModeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("StreamedFileFailureMode"), enumObject);

    enumObject->Set(String::NewSymbol("failed"), Integer::New(0));
    enumObject->Set(String::NewSymbol("currentlyUnavailable"), Integer::New(1));
    enumObject->Set(String::NewSymbol("incomplete"), Integer::New(2));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitApplicationDataLocalityEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ApplicationDataLocality"), enumObject);

    enumObject->Set(String::NewSymbol("local"), Integer::New(0));
    enumObject->Set(String::NewSymbol("roaming"), Integer::New(1));
    enumObject->Set(String::NewSymbol("temporary"), Integer::New(2));
    enumObject->Set(String::NewSymbol("localCache"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitApplicationDataCreateDispositionEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ApplicationDataCreateDisposition"), enumObject);

    enumObject->Set(String::NewSymbol("always"), Integer::New(0));
    enumObject->Set(String::NewSymbol("existing"), Integer::New(1));

    return scope.Close(Undefined());
  }



  
  class StorageLibrary : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageLibrary"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(RequestAddFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("requestAddFolderAsync"), func);
      func = FunctionTemplate::New(RequestRemoveFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("requestRemoveFolderAsync"), func);
      
            
      Local<Function> addListenerFunc = FunctionTemplate::New(AddListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("addListener"), addListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("on"), addListenerFunc);
      Local<Function> removeListenerFunc = FunctionTemplate::New(RemoveListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("removeListener"), removeListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("off"), removeListenerFunc);
            
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("folders"), FoldersGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("saveFolder"), SaveFolderGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(GetLibraryAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("getLibraryAsync"), func);

      exports->Set(String::NewSymbol("StorageLibrary"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageLibrary(::Windows::Storage::StorageLibrary^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::StorageLibrary^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::StorageLibrary^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageLibrary *wrapperInstance = new StorageLibrary(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RequestAddFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageLibrary *wrapper = StorageLibrary::Unwrap<StorageLibrary>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->RequestAddFolderAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> RequestRemoveFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageLibrary *wrapper = StorageLibrary::Unwrap<StorageLibrary>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args[0]))
      {
        try
        {
          ::Windows::Storage::StorageFolder^ arg0 = UnwrapStorageFolder(args[0]);
          
          op = wrapper->_instance->RequestRemoveFolderAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  

    static Handle<Value> GetLibraryAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageLibrary^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::KnownLibraryId arg0 = static_cast<::Windows::Storage::KnownLibraryId>(args[0]->Int32Value());
          
          op = ::Windows::Storage::StorageLibrary::GetLibraryAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageLibrary^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageLibrary(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }


    static Handle<Value> FoldersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageLibrary *wrapper = StorageLibrary::Unwrap<StorageLibrary>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IObservableVector<::Windows::Storage::StorageFolder^>^ result = wrapper->_instance->Folders;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation.Collections", "IObservableVector`1", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SaveFolderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageLibrary *wrapper = StorageLibrary::Unwrap<StorageLibrary>(info.This());

      try 
      {
        ::Windows::Storage::StorageFolder^ result = wrapper->_instance->SaveFolder;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


    static v8::Handle<v8::Value> AddListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;
      
      Local<Function> callback = args[1].As<Function>();
      
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"definitionChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        StorageLibrary *wrapper = StorageLibrary::Unwrap<StorageLibrary>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->DefinitionChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Storage::StorageLibrary^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Storage::StorageLibrary^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = WrapStorageLibrary(arg0);
                Handle<Value> wrappedArg1 = CreateOpaqueWrapper(arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else 
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
          tokenMap = Object::New();
          callback->SetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME), tokenMap);
      }

      tokenMap.As<Object>()->Set(args[1], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
                
      return scope.Close(Undefined());
    }

    static v8::Handle<v8::Value> RemoveListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;

      if ((NodeRT::Utils::CaseInsenstiveEquals(L"definitionChanged", str)))
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Function> callback = args[1].As<Function>();
      Handle<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      Handle<Value> opaqueWrapperObj =  tokenMap.As<Object>()->Get(args[1]);

      if (opaqueWrapperObj.IsEmpty() || opaqueWrapperObj->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());
            
      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;
        
      try 
      {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"definitionChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageLibrary^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          StorageLibrary *wrapper = StorageLibrary::Unwrap<StorageLibrary>(args.This());
          wrapper->_instance->DefinitionChanged::remove(registrationToken);
        }
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      tokenMap.As<Object>()->Delete(args[0].As<String>());

      return scope.Close(Undefined());
    }
  private:
    ::Windows::Storage::StorageLibrary^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageLibrary(::Windows::Storage::StorageLibrary^ wintRtInstance);
    friend ::Windows::Storage::StorageLibrary^ UnwrapStorageLibrary(Handle<Value> value);
    friend bool IsStorageLibraryWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageLibrary::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageLibrary(::Windows::Storage::StorageLibrary^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageLibrary::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::StorageLibrary^ UnwrapStorageLibrary(Handle<Value> value)
  {
     return StorageLibrary::Unwrap<StorageLibrary>(value.As<Object>())->_instance;
  }

  void InitStorageLibrary(Handle<Object> exports)
  {
    StorageLibrary::Init(exports);
  }

  class StorageFolder : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageFolder"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isOfType"), FunctionTemplate::New(IsOfType)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFileQuery"), FunctionTemplate::New(CreateFileQuery)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFileQueryWithOptions"), FunctionTemplate::New(CreateFileQueryWithOptions)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFolderQuery"), FunctionTemplate::New(CreateFolderQuery)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFolderQueryWithOptions"), FunctionTemplate::New(CreateFolderQueryWithOptions)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createItemQuery"), FunctionTemplate::New(CreateItemQuery)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createItemQueryWithOptions"), FunctionTemplate::New(CreateItemQueryWithOptions)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("areQueryOptionsSupported"), FunctionTemplate::New(AreQueryOptionsSupported)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isCommonFolderQuerySupported"), FunctionTemplate::New(IsCommonFolderQuerySupported)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isCommonFileQuerySupported"), FunctionTemplate::New(IsCommonFileQuerySupported)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isEqual"), FunctionTemplate::New(IsEqual)->GetFunction());
      
            
      func = FunctionTemplate::New(CreateFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFileAsync"), func);
      func = FunctionTemplate::New(CreateFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFolderAsync"), func);
      func = FunctionTemplate::New(GetFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFileAsync"), func);
      func = FunctionTemplate::New(GetFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFolderAsync"), func);
      func = FunctionTemplate::New(GetItemAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getItemAsync"), func);
      func = FunctionTemplate::New(GetFilesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFilesAsync"), func);
      func = FunctionTemplate::New(GetFoldersAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFoldersAsync"), func);
      func = FunctionTemplate::New(GetItemsAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getItemsAsync"), func);
      func = FunctionTemplate::New(RenameAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("renameAsync"), func);
      func = FunctionTemplate::New(DeleteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("deleteAsync"), func);
      func = FunctionTemplate::New(GetBasicPropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getBasicPropertiesAsync"), func);
      func = FunctionTemplate::New(GetIndexedStateAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getIndexedStateAsync"), func);
      func = FunctionTemplate::New(GetThumbnailAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getThumbnailAsync"), func);
      func = FunctionTemplate::New(GetScaledImageAsThumbnailAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getScaledImageAsThumbnailAsync"), func);
      func = FunctionTemplate::New(GetParentAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getParentAsync"), func);
      func = FunctionTemplate::New(TryGetItemAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("tryGetItemAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("attributes"), AttributesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("dateCreated"), DateCreatedGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("name"), NameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("path"), PathGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayName"), DisplayNameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayType"), DisplayTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("folderRelativeId"), FolderRelativeIdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("properties"), PropertiesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("provider"), ProviderGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(GetFolderFromPathAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("getFolderFromPathAsync"), func);

      exports->Set(String::NewSymbol("StorageFolder"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageFolder(::Windows::Storage::StorageFolder^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::StorageFolder^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::StorageFolder^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageFolder *wrapperInstance = new StorageFolder(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> CreateFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->CreateFileAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::CreationCollisionOption arg1 = static_cast<::Windows::Storage::CreationCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->CreateFileAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->CreateFolderAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::CreationCollisionOption arg1 = static_cast<::Windows::Storage::CreationCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->CreateFolderAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->GetFileAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->GetFolderAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetItemAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::IStorageItem^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->GetItemAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::IStorageItem^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIStorageItem(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFilesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFile^>^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetFilesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsUint32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFileQuery arg0 = static_cast<::Windows::Storage::Search::CommonFileQuery>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          unsigned int arg2 = static_cast<unsigned int>(args[2]->IntegerValue());
          
          op = wrapper->_instance->GetFilesAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFileQuery arg0 = static_cast<::Windows::Storage::Search::CommonFileQuery>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetFilesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFile^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Storage::StorageFile^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::StorageFile^ val) -> Handle<Value> {
              return WrapStorageFile(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Storage::StorageFile^ {
              return UnwrapStorageFile(value);
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFoldersAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFolder^>^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetFoldersAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsUint32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFolderQuery arg0 = static_cast<::Windows::Storage::Search::CommonFolderQuery>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          unsigned int arg2 = static_cast<unsigned int>(args[2]->IntegerValue());
          
          op = wrapper->_instance->GetFoldersAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFolderQuery arg0 = static_cast<::Windows::Storage::Search::CommonFolderQuery>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetFoldersAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFolder^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Storage::StorageFolder^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::StorageFolder^ val) -> Handle<Value> {
              return WrapStorageFolder(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Storage::StorageFolder^ {
              return UnwrapStorageFolder(value);
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetItemsAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::IStorageItem^>^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetItemsAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsUint32()
        && args[1]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetItemsAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::IStorageItem^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Storage::IStorageItem^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::IStorageItem^ val) -> Handle<Value> {
              return WrapIStorageItem(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Storage::IStorageItem^ {
              return UnwrapIStorageItem(value);
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> RenameAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->RenameAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::NameCollisionOption arg1 = static_cast<::Windows::Storage::NameCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->RenameAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> DeleteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->DeleteAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StorageDeleteOption arg0 = static_cast<::Windows::Storage::StorageDeleteOption>(args[0]->Int32Value());
          
          op = wrapper->_instance->DeleteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetBasicPropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::BasicProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetBasicPropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::BasicProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "BasicProperties", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetIndexedStateAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Search::IndexedState>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetIndexedStateAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Search::IndexedState> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(static_cast<int>(result));
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetThumbnailAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::StorageItemThumbnail^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsInt32()
        && args[1]->IsUint32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::FileProperties::ThumbnailOptions arg2 = static_cast<::Windows::Storage::FileProperties::ThumbnailOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::StorageItemThumbnail^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemThumbnail", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetScaledImageAsThumbnailAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::StorageItemThumbnail^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsInt32()
        && args[1]->IsUint32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::FileProperties::ThumbnailOptions arg2 = static_cast<::Windows::Storage::FileProperties::ThumbnailOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::StorageItemThumbnail^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemThumbnail", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetParentAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetParentAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> TryGetItemAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::IStorageItem^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->TryGetItemAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::IStorageItem^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIStorageItem(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> IsOfType(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StorageItemTypes arg0 = static_cast<::Windows::Storage::StorageItemTypes>(args[0]->Int32Value());
          
          bool result;
          result = wrapper->_instance->IsOfType(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFileQuery(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Search::StorageFileQueryResult^ result;
          result = wrapper->_instance->CreateFileQuery();
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageFileQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFileQuery arg0 = static_cast<::Windows::Storage::Search::CommonFileQuery>(args[0]->Int32Value());
          
          ::Windows::Storage::Search::StorageFileQueryResult^ result;
          result = wrapper->_instance->CreateFileQuery(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageFileQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFileQueryWithOptions(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Search::QueryOptions^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Search::QueryOptions^ arg0 = dynamic_cast<::Windows::Storage::Search::QueryOptions^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          ::Windows::Storage::Search::StorageFileQueryResult^ result;
          result = wrapper->_instance->CreateFileQueryWithOptions(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageFileQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFolderQuery(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Search::StorageFolderQueryResult^ result;
          result = wrapper->_instance->CreateFolderQuery();
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageFolderQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFolderQuery arg0 = static_cast<::Windows::Storage::Search::CommonFolderQuery>(args[0]->Int32Value());
          
          ::Windows::Storage::Search::StorageFolderQueryResult^ result;
          result = wrapper->_instance->CreateFolderQuery(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageFolderQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFolderQueryWithOptions(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Search::QueryOptions^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Search::QueryOptions^ arg0 = dynamic_cast<::Windows::Storage::Search::QueryOptions^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          ::Windows::Storage::Search::StorageFolderQueryResult^ result;
          result = wrapper->_instance->CreateFolderQueryWithOptions(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageFolderQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateItemQuery(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Search::StorageItemQueryResult^ result;
          result = wrapper->_instance->CreateItemQuery();
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageItemQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateItemQueryWithOptions(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Search::QueryOptions^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Search::QueryOptions^ arg0 = dynamic_cast<::Windows::Storage::Search::QueryOptions^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          ::Windows::Storage::Search::StorageItemQueryResult^ result;
          result = wrapper->_instance->CreateItemQueryWithOptions(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Search", "StorageItemQueryResult", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> AreQueryOptionsSupported(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Search::QueryOptions^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Search::QueryOptions^ arg0 = dynamic_cast<::Windows::Storage::Search::QueryOptions^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          bool result;
          result = wrapper->_instance->AreQueryOptionsSupported(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> IsCommonFolderQuerySupported(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFolderQuery arg0 = static_cast<::Windows::Storage::Search::CommonFolderQuery>(args[0]->Int32Value());
          
          bool result;
          result = wrapper->_instance->IsCommonFolderQuerySupported(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> IsCommonFileQuerySupported(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::Search::CommonFileQuery arg0 = static_cast<::Windows::Storage::Search::CommonFileQuery>(args[0]->Int32Value());
          
          bool result;
          result = wrapper->_instance->IsCommonFileQuerySupported(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> IsEqual(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageItem^ arg0 = UnwrapIStorageItem(args[0]);
          
          bool result;
          result = wrapper->_instance->IsEqual(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> GetFolderFromPathAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::StorageFolder::GetFolderFromPathAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }


    static Handle<Value> AttributesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        ::Windows::Storage::FileAttributes result = wrapper->_instance->Attributes;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DateCreatedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        ::Windows::Foundation::DateTime result = wrapper->_instance->DateCreated;
        return scope.Close(NodeRT::Utils::DateTimeToJS(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> NameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Name;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PathGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Path;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayNameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayName;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FolderRelativeIdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FolderRelativeId;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PropertiesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        ::Windows::Storage::FileProperties::StorageItemContentProperties^ result = wrapper->_instance->Properties;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemContentProperties", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProviderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFolder *wrapper = StorageFolder::Unwrap<StorageFolder>(info.This());

      try 
      {
        ::Windows::Storage::StorageProvider^ result = wrapper->_instance->Provider;
        return scope.Close(WrapStorageProvider(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::StorageFolder^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageFolder(::Windows::Storage::StorageFolder^ wintRtInstance);
    friend ::Windows::Storage::StorageFolder^ UnwrapStorageFolder(Handle<Value> value);
    friend bool IsStorageFolderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageFolder::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageFolder(::Windows::Storage::StorageFolder^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageFolder::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::StorageFolder^ UnwrapStorageFolder(Handle<Value> value)
  {
     return StorageFolder::Unwrap<StorageFolder>(value.As<Object>())->_instance;
  }

  void InitStorageFolder(Handle<Object> exports)
  {
    StorageFolder::Init(exports);
  }

  class KnownFolders : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("KnownFolders"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->SetAccessor(String::NewSymbol("savedPictures"), SavedPicturesGetter);
      constructor->SetAccessor(String::NewSymbol("cameraRoll"), CameraRollGetter);
      constructor->SetAccessor(String::NewSymbol("playlists"), PlaylistsGetter);
      constructor->SetAccessor(String::NewSymbol("documentsLibrary"), DocumentsLibraryGetter);
      constructor->SetAccessor(String::NewSymbol("homeGroup"), HomeGroupGetter);
      constructor->SetAccessor(String::NewSymbol("mediaServerDevices"), MediaServerDevicesGetter);
      constructor->SetAccessor(String::NewSymbol("musicLibrary"), MusicLibraryGetter);
      constructor->SetAccessor(String::NewSymbol("picturesLibrary"), PicturesLibraryGetter);
      constructor->SetAccessor(String::NewSymbol("removableDevices"), RemovableDevicesGetter);
      constructor->SetAccessor(String::NewSymbol("videosLibrary"), VideosLibraryGetter);

      exports->Set(String::NewSymbol("KnownFolders"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    KnownFolders(::Windows::Storage::KnownFolders^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::KnownFolders^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::KnownFolders^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::KnownFolders^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      KnownFolders *wrapperInstance = new KnownFolders(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  




    static Handle<Value> SavedPicturesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::SavedPictures;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CameraRollGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::CameraRoll;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PlaylistsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::Playlists;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DocumentsLibraryGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::DocumentsLibrary;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> HomeGroupGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::HomeGroup;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MediaServerDevicesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::MediaServerDevices;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MusicLibraryGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::MusicLibrary;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PicturesLibraryGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::PicturesLibrary;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RemovableDevicesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::RemovableDevices;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> VideosLibraryGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::StorageFolder^ result = ::Windows::Storage::KnownFolders::VideosLibrary;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    

  private:
    ::Windows::Storage::KnownFolders^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapKnownFolders(::Windows::Storage::KnownFolders^ wintRtInstance);
    friend ::Windows::Storage::KnownFolders^ UnwrapKnownFolders(Handle<Value> value);
    friend bool IsKnownFoldersWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> KnownFolders::s_constructorTemplate;

  v8::Handle<v8::Value> WrapKnownFolders(::Windows::Storage::KnownFolders^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(KnownFolders::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::KnownFolders^ UnwrapKnownFolders(Handle<Value> value)
  {
     return KnownFolders::Unwrap<KnownFolders>(value.As<Object>())->_instance;
  }

  void InitKnownFolders(Handle<Object> exports)
  {
    KnownFolders::Init(exports);
  }

  class StorageFile : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageFile"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isOfType"), FunctionTemplate::New(IsOfType)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isEqual"), FunctionTemplate::New(IsEqual)->GetFunction());
      
            
      func = FunctionTemplate::New(OpenAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openAsync"), func);
      func = FunctionTemplate::New(OpenTransactedWriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openTransactedWriteAsync"), func);
      func = FunctionTemplate::New(CopyAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("copyAsync"), func);
      func = FunctionTemplate::New(CopyAndReplaceAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("copyAndReplaceAsync"), func);
      func = FunctionTemplate::New(MoveAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("moveAsync"), func);
      func = FunctionTemplate::New(MoveAndReplaceAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("moveAndReplaceAsync"), func);
      func = FunctionTemplate::New(RenameAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("renameAsync"), func);
      func = FunctionTemplate::New(DeleteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("deleteAsync"), func);
      func = FunctionTemplate::New(GetBasicPropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getBasicPropertiesAsync"), func);
      func = FunctionTemplate::New(OpenReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openReadAsync"), func);
      func = FunctionTemplate::New(OpenSequentialReadAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openSequentialReadAsync"), func);
      func = FunctionTemplate::New(GetThumbnailAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getThumbnailAsync"), func);
      func = FunctionTemplate::New(GetScaledImageAsThumbnailAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getScaledImageAsThumbnailAsync"), func);
      func = FunctionTemplate::New(GetParentAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getParentAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("contentType"), ContentTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("fileType"), FileTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("attributes"), AttributesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("dateCreated"), DateCreatedGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("name"), NameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("path"), PathGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayName"), DisplayNameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayType"), DisplayTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("folderRelativeId"), FolderRelativeIdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("properties"), PropertiesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("provider"), ProviderGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("isAvailable"), IsAvailableGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(GetFileFromPathAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("getFileFromPathAsync"), func);
      func = FunctionTemplate::New(GetFileFromApplicationUriAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("getFileFromApplicationUriAsync"), func);
      func = FunctionTemplate::New(CreateStreamedFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("createStreamedFileAsync"), func);
      func = FunctionTemplate::New(ReplaceWithStreamedFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("replaceWithStreamedFileAsync"), func);
      func = FunctionTemplate::New(CreateStreamedFileFromUriAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("createStreamedFileFromUriAsync"), func);
      func = FunctionTemplate::New(ReplaceWithStreamedFileFromUriAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("replaceWithStreamedFileFromUriAsync"), func);

      exports->Set(String::NewSymbol("StorageFile"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageFile(::Windows::Storage::StorageFile^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::StorageFile^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::StorageFile^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageFile *wrapperInstance = new StorageFile(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> OpenAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStream^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileAccessMode arg0 = static_cast<::Windows::Storage::FileAccessMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->OpenAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStream^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IRandomAccessStream", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> OpenTransactedWriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageStreamTransaction^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenTransactedWriteAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageStreamTransaction^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageStreamTransaction(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CopyAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          
          op = wrapper->_instance->CopyAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = wrapper->_instance->CopyAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::NameCollisionOption arg2 = static_cast<::Windows::Storage::NameCollisionOption>(args[2]->Int32Value());
          
          op = wrapper->_instance->CopyAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CopyAndReplaceAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = wrapper->_instance->CopyAndReplaceAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> MoveAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          
          op = wrapper->_instance->MoveAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = wrapper->_instance->MoveAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::NameCollisionOption arg2 = static_cast<::Windows::Storage::NameCollisionOption>(args[2]->Int32Value());
          
          op = wrapper->_instance->MoveAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> MoveAndReplaceAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = wrapper->_instance->MoveAndReplaceAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> RenameAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->RenameAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::NameCollisionOption arg1 = static_cast<::Windows::Storage::NameCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->RenameAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> DeleteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->DeleteAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StorageDeleteOption arg0 = static_cast<::Windows::Storage::StorageDeleteOption>(args[0]->Int32Value());
          
          op = wrapper->_instance->DeleteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetBasicPropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::BasicProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetBasicPropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::BasicProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "BasicProperties", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> OpenReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStreamWithContentType^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IRandomAccessStreamWithContentType", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> OpenSequentialReadAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IInputStream^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenSequentialReadAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IInputStream^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IInputStream", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetThumbnailAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::StorageItemThumbnail^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsInt32()
        && args[1]->IsUint32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::FileProperties::ThumbnailOptions arg2 = static_cast<::Windows::Storage::FileProperties::ThumbnailOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::StorageItemThumbnail^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemThumbnail", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetScaledImageAsThumbnailAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::StorageItemThumbnail^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsInt32()
        && args[1]->IsUint32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::FileProperties::ThumbnailOptions arg2 = static_cast<::Windows::Storage::FileProperties::ThumbnailOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::StorageItemThumbnail^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemThumbnail", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetParentAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetParentAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> IsOfType(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StorageItemTypes arg0 = static_cast<::Windows::Storage::StorageItemTypes>(args[0]->Int32Value());
          
          bool result;
          result = wrapper->_instance->IsOfType(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> IsEqual(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageItem^ arg0 = UnwrapIStorageItem(args[0]);
          
          bool result;
          result = wrapper->_instance->IsEqual(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> GetFileFromPathAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::StorageFile::GetFileFromPathAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFileFromApplicationUriAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args[0]))
      {
        try
        {
          ::Windows::Foundation::Uri^ arg0 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          op = ::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateStreamedFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 4
        && args[0]->IsString()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequestedHandler^>(args[1])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(args[2]))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::StreamedFileDataRequestedHandler^ arg1 = dynamic_cast<::Windows::Storage::StreamedFileDataRequestedHandler^>(NodeRT::Utils::GetObjectInstance(args[1]));
          ::Windows::Storage::Streams::IRandomAccessStreamReference^ arg2 = dynamic_cast<::Windows::Storage::Streams::IRandomAccessStreamReference^>(NodeRT::Utils::GetObjectInstance(args[2]));
          
          op = ::Windows::Storage::StorageFile::CreateStreamedFileAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ReplaceWithStreamedFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequestedHandler^>(args[1])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(args[2]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Storage::StreamedFileDataRequestedHandler^ arg1 = dynamic_cast<::Windows::Storage::StreamedFileDataRequestedHandler^>(NodeRT::Utils::GetObjectInstance(args[1]));
          ::Windows::Storage::Streams::IRandomAccessStreamReference^ arg2 = dynamic_cast<::Windows::Storage::Streams::IRandomAccessStreamReference^>(NodeRT::Utils::GetObjectInstance(args[2]));
          
          op = ::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateStreamedFileFromUriAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 4
        && args[0]->IsString()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args[1])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(args[2]))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Foundation::Uri^ arg1 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(args[1]));
          ::Windows::Storage::Streams::IRandomAccessStreamReference^ arg2 = dynamic_cast<::Windows::Storage::Streams::IRandomAccessStreamReference^>(NodeRT::Utils::GetObjectInstance(args[2]));
          
          op = ::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ReplaceWithStreamedFileFromUriAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args[1])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IRandomAccessStreamReference^>(args[2]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Foundation::Uri^ arg1 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(args[1]));
          ::Windows::Storage::Streams::IRandomAccessStreamReference^ arg2 = dynamic_cast<::Windows::Storage::Streams::IRandomAccessStreamReference^>(NodeRT::Utils::GetObjectInstance(args[2]));
          
          op = ::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }


    static Handle<Value> ContentTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->ContentType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FileTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FileType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AttributesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        ::Windows::Storage::FileAttributes result = wrapper->_instance->Attributes;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DateCreatedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        ::Windows::Foundation::DateTime result = wrapper->_instance->DateCreated;
        return scope.Close(NodeRT::Utils::DateTimeToJS(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> NameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Name;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PathGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Path;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayNameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayName;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FolderRelativeIdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FolderRelativeId;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PropertiesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        ::Windows::Storage::FileProperties::StorageItemContentProperties^ result = wrapper->_instance->Properties;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemContentProperties", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProviderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        ::Windows::Storage::StorageProvider^ result = wrapper->_instance->Provider;
        return scope.Close(WrapStorageProvider(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IsAvailableGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageFile *wrapper = StorageFile::Unwrap<StorageFile>(info.This());

      try 
      {
        bool result = wrapper->_instance->IsAvailable;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::StorageFile^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageFile(::Windows::Storage::StorageFile^ wintRtInstance);
    friend ::Windows::Storage::StorageFile^ UnwrapStorageFile(Handle<Value> value);
    friend bool IsStorageFileWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageFile::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageFile(::Windows::Storage::StorageFile^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageFile::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::StorageFile^ UnwrapStorageFile(Handle<Value> value)
  {
     return StorageFile::Unwrap<StorageFile>(value.As<Object>())->_instance;
  }

  void InitStorageFile(Handle<Object> exports)
  {
    StorageFile::Init(exports);
  }

  class DownloadsFolder : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("DownloadsFolder"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(CreateFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("createFileAsync"), func);
      func = FunctionTemplate::New(CreateFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("createFolderAsync"), func);

      exports->Set(String::NewSymbol("DownloadsFolder"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    DownloadsFolder(::Windows::Storage::DownloadsFolder^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::DownloadsFolder^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::DownloadsFolder^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::DownloadsFolder^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      DownloadsFolder *wrapperInstance = new DownloadsFolder(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  

    static Handle<Value> CreateFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::DownloadsFolder::CreateFileAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::CreationCollisionOption arg1 = static_cast<::Windows::Storage::CreationCollisionOption>(args[1]->Int32Value());
          
          op = ::Windows::Storage::DownloadsFolder::CreateFileAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::DownloadsFolder::CreateFolderAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::CreationCollisionOption arg1 = static_cast<::Windows::Storage::CreationCollisionOption>(args[1]->Int32Value());
          
          op = ::Windows::Storage::DownloadsFolder::CreateFolderAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }




  private:
    ::Windows::Storage::DownloadsFolder^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapDownloadsFolder(::Windows::Storage::DownloadsFolder^ wintRtInstance);
    friend ::Windows::Storage::DownloadsFolder^ UnwrapDownloadsFolder(Handle<Value> value);
    friend bool IsDownloadsFolderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> DownloadsFolder::s_constructorTemplate;

  v8::Handle<v8::Value> WrapDownloadsFolder(::Windows::Storage::DownloadsFolder^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(DownloadsFolder::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::DownloadsFolder^ UnwrapDownloadsFolder(Handle<Value> value)
  {
     return DownloadsFolder::Unwrap<DownloadsFolder>(value.As<Object>())->_instance;
  }

  void InitDownloadsFolder(Handle<Object> exports)
  {
    DownloadsFolder::Init(exports);
  }

  class IStreamedFileDataRequest : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStreamedFileDataRequest"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("failAndClose"), FunctionTemplate::New(FailAndClose)->GetFunction());
      
                        
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStreamedFileDataRequest"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStreamedFileDataRequest(::Windows::Storage::IStreamedFileDataRequest^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStreamedFileDataRequest^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStreamedFileDataRequest^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStreamedFileDataRequest^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStreamedFileDataRequest *wrapperInstance = new IStreamedFileDataRequest(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> FailAndClose(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStreamedFileDataRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IStreamedFileDataRequest *wrapper = IStreamedFileDataRequest::Unwrap<IStreamedFileDataRequest>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StreamedFileFailureMode arg0 = static_cast<::Windows::Storage::StreamedFileFailureMode>(args[0]->Int32Value());
          
          wrapper->_instance->FailAndClose(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Storage::IStreamedFileDataRequest^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStreamedFileDataRequest(::Windows::Storage::IStreamedFileDataRequest^ wintRtInstance);
    friend ::Windows::Storage::IStreamedFileDataRequest^ UnwrapIStreamedFileDataRequest(Handle<Value> value);
    friend bool IsIStreamedFileDataRequestWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStreamedFileDataRequest::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStreamedFileDataRequest(::Windows::Storage::IStreamedFileDataRequest^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStreamedFileDataRequest::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStreamedFileDataRequest^ UnwrapIStreamedFileDataRequest(Handle<Value> value)
  {
     return IStreamedFileDataRequest::Unwrap<IStreamedFileDataRequest>(value.As<Object>())->_instance;
  }

  void InitIStreamedFileDataRequest(Handle<Object> exports)
  {
    IStreamedFileDataRequest::Init(exports);
  }

  class StreamedFileDataRequest : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StreamedFileDataRequest"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("failAndClose"), FunctionTemplate::New(FailAndClose)->GetFunction());
      
            
      func = FunctionTemplate::New(WriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("writeAsync"), func);
      func = FunctionTemplate::New(FlushAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("flushAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("StreamedFileDataRequest"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StreamedFileDataRequest(::Windows::Storage::StreamedFileDataRequest^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::StreamedFileDataRequest^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequest^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::StreamedFileDataRequest^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StreamedFileDataRequest *wrapperInstance = new StreamedFileDataRequest(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> WriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StreamedFileDataRequest *wrapper = StreamedFileDataRequest::Unwrap<StreamedFileDataRequest>(args.This());

      ::Windows::Foundation::IAsyncOperationWithProgress<unsigned int, unsigned int>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[0]))
      {
        try
        {
          ::Windows::Storage::Streams::IBuffer^ arg0 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          op = wrapper->_instance->WriteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<unsigned int> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> FlushAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StreamedFileDataRequest *wrapper = StreamedFileDataRequest::Unwrap<StreamedFileDataRequest>(args.This());

      ::Windows::Foundation::IAsyncOperation<bool>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->FlushAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<bool> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Boolean::New(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StreamedFileDataRequest *wrapper = StreamedFileDataRequest::Unwrap<StreamedFileDataRequest>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> FailAndClose(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StreamedFileDataRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StreamedFileDataRequest *wrapper = StreamedFileDataRequest::Unwrap<StreamedFileDataRequest>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StreamedFileFailureMode arg0 = static_cast<::Windows::Storage::StreamedFileFailureMode>(args[0]->Int32Value());
          
          wrapper->_instance->FailAndClose(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Storage::StreamedFileDataRequest^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStreamedFileDataRequest(::Windows::Storage::StreamedFileDataRequest^ wintRtInstance);
    friend ::Windows::Storage::StreamedFileDataRequest^ UnwrapStreamedFileDataRequest(Handle<Value> value);
    friend bool IsStreamedFileDataRequestWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StreamedFileDataRequest::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStreamedFileDataRequest(::Windows::Storage::StreamedFileDataRequest^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StreamedFileDataRequest::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::StreamedFileDataRequest^ UnwrapStreamedFileDataRequest(Handle<Value> value)
  {
     return StreamedFileDataRequest::Unwrap<StreamedFileDataRequest>(value.As<Object>())->_instance;
  }

  void InitStreamedFileDataRequest(Handle<Object> exports)
  {
    StreamedFileDataRequest::Init(exports);
  }

  class StorageStreamTransaction : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageStreamTransaction"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
            
      func = FunctionTemplate::New(CommitAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("commitAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("stream"), StreamGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("StorageStreamTransaction"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageStreamTransaction(::Windows::Storage::StorageStreamTransaction^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::StorageStreamTransaction^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageStreamTransaction^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::StorageStreamTransaction^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageStreamTransaction *wrapperInstance = new StorageStreamTransaction(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> CommitAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageStreamTransaction^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      StorageStreamTransaction *wrapper = StorageStreamTransaction::Unwrap<StorageStreamTransaction>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->CommitAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageStreamTransaction^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      StorageStreamTransaction *wrapper = StorageStreamTransaction::Unwrap<StorageStreamTransaction>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          delete wrapper->_instance;
          wrapper->_instance = nullptr;
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }




    static Handle<Value> StreamGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageStreamTransaction^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageStreamTransaction *wrapper = StorageStreamTransaction::Unwrap<StorageStreamTransaction>(info.This());

      try 
      {
        ::Windows::Storage::Streams::IRandomAccessStream^ result = wrapper->_instance->Stream;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IRandomAccessStream", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::StorageStreamTransaction^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageStreamTransaction(::Windows::Storage::StorageStreamTransaction^ wintRtInstance);
    friend ::Windows::Storage::StorageStreamTransaction^ UnwrapStorageStreamTransaction(Handle<Value> value);
    friend bool IsStorageStreamTransactionWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageStreamTransaction::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageStreamTransaction(::Windows::Storage::StorageStreamTransaction^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageStreamTransaction::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::StorageStreamTransaction^ UnwrapStorageStreamTransaction(Handle<Value> value)
  {
     return StorageStreamTransaction::Unwrap<StorageStreamTransaction>(value.As<Object>())->_instance;
  }

  void InitStorageStreamTransaction(Handle<Object> exports)
  {
    StorageStreamTransaction::Init(exports);
  }

  class IStorageItem : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageItem"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isOfType"), FunctionTemplate::New(IsOfType)->GetFunction());
      
            
      func = FunctionTemplate::New(RenameAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("renameAsync"), func);
      func = FunctionTemplate::New(DeleteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("deleteAsync"), func);
      func = FunctionTemplate::New(GetBasicPropertiesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getBasicPropertiesAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("attributes"), AttributesGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("dateCreated"), DateCreatedGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("name"), NameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("path"), PathGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageItem"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageItem(::Windows::Storage::IStorageItem^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageItem^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageItem^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageItem *wrapperInstance = new IStorageItem(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> RenameAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->RenameAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::NameCollisionOption arg1 = static_cast<::Windows::Storage::NameCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->RenameAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> DeleteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->DeleteAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StorageDeleteOption arg0 = static_cast<::Windows::Storage::StorageDeleteOption>(args[0]->Int32Value());
          
          op = wrapper->_instance->DeleteAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetBasicPropertiesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::BasicProperties^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetBasicPropertiesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::BasicProperties^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "BasicProperties", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> IsOfType(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(args.This());

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::StorageItemTypes arg0 = static_cast<::Windows::Storage::StorageItemTypes>(args[0]->Int32Value());
          
          bool result;
          result = wrapper->_instance->IsOfType(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> AttributesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(info.This());

      try 
      {
        ::Windows::Storage::FileAttributes result = wrapper->_instance->Attributes;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DateCreatedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(info.This());

      try 
      {
        ::Windows::Foundation::DateTime result = wrapper->_instance->DateCreated;
        return scope.Close(NodeRT::Utils::DateTimeToJS(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> NameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Name;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PathGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItem *wrapper = IStorageItem::Unwrap<IStorageItem>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Path;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::IStorageItem^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageItem(::Windows::Storage::IStorageItem^ wintRtInstance);
    friend ::Windows::Storage::IStorageItem^ UnwrapIStorageItem(Handle<Value> value);
    friend bool IsIStorageItemWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageItem::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageItem(::Windows::Storage::IStorageItem^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageItem::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageItem^ UnwrapIStorageItem(Handle<Value> value)
  {
     return IStorageItem::Unwrap<IStorageItem>(value.As<Object>())->_instance;
  }

  void InitIStorageItem(Handle<Object> exports)
  {
    IStorageItem::Init(exports);
  }

  class IStorageFolder : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageFolder"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(CreateFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFileAsync"), func);
      func = FunctionTemplate::New(CreateFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createFolderAsync"), func);
      func = FunctionTemplate::New(GetFileAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFileAsync"), func);
      func = FunctionTemplate::New(GetFolderAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFolderAsync"), func);
      func = FunctionTemplate::New(GetItemAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getItemAsync"), func);
      func = FunctionTemplate::New(GetFilesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFilesAsync"), func);
      func = FunctionTemplate::New(GetFoldersAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFoldersAsync"), func);
      func = FunctionTemplate::New(GetItemsAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getItemsAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageFolder"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageFolder(::Windows::Storage::IStorageFolder^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageFolder^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageFolder^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageFolder *wrapperInstance = new IStorageFolder(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> CreateFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->CreateFileAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::CreationCollisionOption arg1 = static_cast<::Windows::Storage::CreationCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->CreateFileAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->CreateFolderAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::CreationCollisionOption arg1 = static_cast<::Windows::Storage::CreationCollisionOption>(args[1]->Int32Value());
          
          op = wrapper->_instance->CreateFolderAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFileAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->GetFileAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFolderAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->GetFolderAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetItemAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::IStorageItem^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->GetItemAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::IStorageItem^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIStorageItem(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFilesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFile^>^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetFilesAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFile^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Storage::StorageFile^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::StorageFile^ val) -> Handle<Value> {
              return WrapStorageFile(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFile^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Storage::StorageFile^ {
              return UnwrapStorageFile(value);
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetFoldersAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFolder^>^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetFoldersAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::StorageFolder^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Storage::StorageFolder^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::StorageFolder^ val) -> Handle<Value> {
              return WrapStorageFolder(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageFolder^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Storage::StorageFolder^ {
              return UnwrapStorageFolder(value);
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> GetItemsAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder *wrapper = IStorageFolder::Unwrap<IStorageFolder>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::IStorageItem^>^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetItemsAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVectorView<::Windows::Storage::IStorageItem^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorViewWrapper<::Windows::Storage::IStorageItem^>::CreateVectorViewWrapper(result, 
            [](::Windows::Storage::IStorageItem^ val) -> Handle<Value> {
              return WrapIStorageItem(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(value);
            },
            [](Handle<Value> value) -> ::Windows::Storage::IStorageItem^ {
              return UnwrapIStorageItem(value);
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::IStorageFolder^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageFolder(::Windows::Storage::IStorageFolder^ wintRtInstance);
    friend ::Windows::Storage::IStorageFolder^ UnwrapIStorageFolder(Handle<Value> value);
    friend bool IsIStorageFolderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageFolder::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageFolder(::Windows::Storage::IStorageFolder^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageFolder::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageFolder^ UnwrapIStorageFolder(Handle<Value> value)
  {
     return IStorageFolder::Unwrap<IStorageFolder>(value.As<Object>())->_instance;
  }

  void InitIStorageFolder(Handle<Object> exports)
  {
    IStorageFolder::Init(exports);
  }

  class IStorageFile : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageFile"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(OpenAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openAsync"), func);
      func = FunctionTemplate::New(OpenTransactedWriteAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("openTransactedWriteAsync"), func);
      func = FunctionTemplate::New(CopyAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("copyAsync"), func);
      func = FunctionTemplate::New(CopyAndReplaceAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("copyAndReplaceAsync"), func);
      func = FunctionTemplate::New(MoveAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("moveAsync"), func);
      func = FunctionTemplate::New(MoveAndReplaceAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("moveAndReplaceAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("contentType"), ContentTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("fileType"), FileTypeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageFile"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageFile(::Windows::Storage::IStorageFile^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageFile^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageFile^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageFile *wrapperInstance = new IStorageFile(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> OpenAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IRandomAccessStream^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileAccessMode arg0 = static_cast<::Windows::Storage::FileAccessMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->OpenAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IRandomAccessStream^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IRandomAccessStream", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> OpenTransactedWriteAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageStreamTransaction^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->OpenTransactedWriteAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageStreamTransaction^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageStreamTransaction(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CopyAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFile^>^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          
          op = wrapper->_instance->CopyAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = wrapper->_instance->CopyAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::NameCollisionOption arg2 = static_cast<::Windows::Storage::NameCollisionOption>(args[2]->Int32Value());
          
          op = wrapper->_instance->CopyAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFile^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFile(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> CopyAndReplaceAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = wrapper->_instance->CopyAndReplaceAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> MoveAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          
          op = wrapper->_instance->MoveAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = wrapper->_instance->MoveAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFolder^ arg0 = UnwrapIStorageFolder(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::NameCollisionOption arg2 = static_cast<::Windows::Storage::NameCollisionOption>(args[2]->Int32Value());
          
          op = wrapper->_instance->MoveAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> MoveAndReplaceAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = wrapper->_instance->MoveAndReplaceAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> ContentTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->ContentType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FileTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageFile *wrapper = IStorageFile::Unwrap<IStorageFile>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FileType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::IStorageFile^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageFile(::Windows::Storage::IStorageFile^ wintRtInstance);
    friend ::Windows::Storage::IStorageFile^ UnwrapIStorageFile(Handle<Value> value);
    friend bool IsIStorageFileWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageFile::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageFile(::Windows::Storage::IStorageFile^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageFile::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageFile^ UnwrapIStorageFile(Handle<Value> value)
  {
     return IStorageFile::Unwrap<IStorageFile>(value.As<Object>())->_instance;
  }

  void InitIStorageFile(Handle<Object> exports)
  {
    IStorageFile::Init(exports);
  }

  class IStorageItem2 : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageItem2"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("isEqual"), FunctionTemplate::New(IsEqual)->GetFunction());
      
            
      func = FunctionTemplate::New(GetParentAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getParentAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageItem2"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageItem2(::Windows::Storage::IStorageItem2^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageItem2^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem2^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageItem2^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageItem2 *wrapperInstance = new IStorageItem2(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> GetParentAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem2^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItem2 *wrapper = IStorageItem2::Unwrap<IStorageItem2>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::StorageFolder^>^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->GetParentAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::StorageFolder^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapStorageFolder(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> IsEqual(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem2^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItem2 *wrapper = IStorageItem2::Unwrap<IStorageItem2>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItem^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageItem^ arg0 = UnwrapIStorageItem(args[0]);
          
          bool result;
          result = wrapper->_instance->IsEqual(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Storage::IStorageItem2^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageItem2(::Windows::Storage::IStorageItem2^ wintRtInstance);
    friend ::Windows::Storage::IStorageItem2^ UnwrapIStorageItem2(Handle<Value> value);
    friend bool IsIStorageItem2Wrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageItem2::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageItem2(::Windows::Storage::IStorageItem2^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageItem2::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageItem2^ UnwrapIStorageItem2(Handle<Value> value)
  {
     return IStorageItem2::Unwrap<IStorageItem2>(value.As<Object>())->_instance;
  }

  void InitIStorageItem2(Handle<Object> exports)
  {
    IStorageItem2::Init(exports);
  }

  class IStorageItemProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageItemProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(GetThumbnailAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getThumbnailAsync"), func);
      
                  
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayName"), DisplayNameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayType"), DisplayTypeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("folderRelativeId"), FolderRelativeIdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("properties"), PropertiesGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageItemProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageItemProperties(::Windows::Storage::IStorageItemProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageItemProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageItemProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageItemProperties *wrapperInstance = new IStorageItemProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> GetThumbnailAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItemProperties *wrapper = IStorageItemProperties::Unwrap<IStorageItemProperties>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::StorageItemThumbnail^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsInt32()
        && args[1]->IsUint32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::FileProperties::ThumbnailOptions arg2 = static_cast<::Windows::Storage::FileProperties::ThumbnailOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->GetThumbnailAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::StorageItemThumbnail^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemThumbnail", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  



    static Handle<Value> DisplayNameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItemProperties *wrapper = IStorageItemProperties::Unwrap<IStorageItemProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayName;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayTypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItemProperties *wrapper = IStorageItemProperties::Unwrap<IStorageItemProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayType;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FolderRelativeIdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItemProperties *wrapper = IStorageItemProperties::Unwrap<IStorageItemProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FolderRelativeId;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PropertiesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItemProperties *wrapper = IStorageItemProperties::Unwrap<IStorageItemProperties>(info.This());

      try 
      {
        ::Windows::Storage::FileProperties::StorageItemContentProperties^ result = wrapper->_instance->Properties;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemContentProperties", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::IStorageItemProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageItemProperties(::Windows::Storage::IStorageItemProperties^ wintRtInstance);
    friend ::Windows::Storage::IStorageItemProperties^ UnwrapIStorageItemProperties(Handle<Value> value);
    friend bool IsIStorageItemPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageItemProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageItemProperties(::Windows::Storage::IStorageItemProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageItemProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageItemProperties^ UnwrapIStorageItemProperties(Handle<Value> value)
  {
     return IStorageItemProperties::Unwrap<IStorageItemProperties>(value.As<Object>())->_instance;
  }

  void InitIStorageItemProperties(Handle<Object> exports)
  {
    IStorageItemProperties::Init(exports);
  }

  class IStorageItemProperties2 : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageItemProperties2"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(GetScaledImageAsThumbnailAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getScaledImageAsThumbnailAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageItemProperties2"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageItemProperties2(::Windows::Storage::IStorageItemProperties2^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageItemProperties2^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties2^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageItemProperties2^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageItemProperties2 *wrapperInstance = new IStorageItemProperties2(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> GetScaledImageAsThumbnailAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemProperties2^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageItemProperties2 *wrapper = IStorageItemProperties2::Unwrap<IStorageItemProperties2>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::FileProperties::StorageItemThumbnail^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsInt32()
        && args[1]->IsUint32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsInt32()
        && args[1]->IsUint32()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::FileProperties::ThumbnailMode arg0 = static_cast<::Windows::Storage::FileProperties::ThumbnailMode>(args[0]->Int32Value());
          unsigned int arg1 = static_cast<unsigned int>(args[1]->IntegerValue());
          ::Windows::Storage::FileProperties::ThumbnailOptions arg2 = static_cast<::Windows::Storage::FileProperties::ThumbnailOptions>(args[2]->Int32Value());
          
          op = wrapper->_instance->GetScaledImageAsThumbnailAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::FileProperties::StorageItemThumbnail^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.FileProperties", "StorageItemThumbnail", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::IStorageItemProperties2^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageItemProperties2(::Windows::Storage::IStorageItemProperties2^ wintRtInstance);
    friend ::Windows::Storage::IStorageItemProperties2^ UnwrapIStorageItemProperties2(Handle<Value> value);
    friend bool IsIStorageItemProperties2Wrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageItemProperties2::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageItemProperties2(::Windows::Storage::IStorageItemProperties2^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageItemProperties2::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageItemProperties2^ UnwrapIStorageItemProperties2(Handle<Value> value)
  {
     return IStorageItemProperties2::Unwrap<IStorageItemProperties2>(value.As<Object>())->_instance;
  }

  void InitIStorageItemProperties2(Handle<Object> exports)
  {
    IStorageItemProperties2::Init(exports);
  }

  class IStorageItemPropertiesWithProvider : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageItemPropertiesWithProvider"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("provider"), ProviderGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageItemPropertiesWithProvider"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageItemPropertiesWithProvider(::Windows::Storage::IStorageItemPropertiesWithProvider^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageItemPropertiesWithProvider^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemPropertiesWithProvider^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageItemPropertiesWithProvider^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageItemPropertiesWithProvider *wrapperInstance = new IStorageItemPropertiesWithProvider(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> ProviderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageItemPropertiesWithProvider^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageItemPropertiesWithProvider *wrapper = IStorageItemPropertiesWithProvider::Unwrap<IStorageItemPropertiesWithProvider>(info.This());

      try 
      {
        ::Windows::Storage::StorageProvider^ result = wrapper->_instance->Provider;
        return scope.Close(WrapStorageProvider(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::IStorageItemPropertiesWithProvider^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageItemPropertiesWithProvider(::Windows::Storage::IStorageItemPropertiesWithProvider^ wintRtInstance);
    friend ::Windows::Storage::IStorageItemPropertiesWithProvider^ UnwrapIStorageItemPropertiesWithProvider(Handle<Value> value);
    friend bool IsIStorageItemPropertiesWithProviderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageItemPropertiesWithProvider::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageItemPropertiesWithProvider(::Windows::Storage::IStorageItemPropertiesWithProvider^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageItemPropertiesWithProvider::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageItemPropertiesWithProvider^ UnwrapIStorageItemPropertiesWithProvider(Handle<Value> value)
  {
     return IStorageItemPropertiesWithProvider::Unwrap<IStorageItemPropertiesWithProvider>(value.As<Object>())->_instance;
  }

  void InitIStorageItemPropertiesWithProvider(Handle<Object> exports)
  {
    IStorageItemPropertiesWithProvider::Init(exports);
  }

  class StorageProvider : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("StorageProvider"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayName"), DisplayNameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("id"), IdGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("StorageProvider"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    StorageProvider(::Windows::Storage::StorageProvider^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::StorageProvider^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageProvider^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::StorageProvider^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      StorageProvider *wrapperInstance = new StorageProvider(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> DisplayNameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageProvider^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageProvider *wrapper = StorageProvider::Unwrap<StorageProvider>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayName;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::StorageProvider^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      StorageProvider *wrapper = StorageProvider::Unwrap<StorageProvider>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Id;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::StorageProvider^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapStorageProvider(::Windows::Storage::StorageProvider^ wintRtInstance);
    friend ::Windows::Storage::StorageProvider^ UnwrapStorageProvider(Handle<Value> value);
    friend bool IsStorageProviderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> StorageProvider::s_constructorTemplate;

  v8::Handle<v8::Value> WrapStorageProvider(::Windows::Storage::StorageProvider^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(StorageProvider::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::StorageProvider^ UnwrapStorageProvider(Handle<Value> value)
  {
     return StorageProvider::Unwrap<StorageProvider>(value.As<Object>())->_instance;
  }

  void InitStorageProvider(Handle<Object> exports)
  {
    StorageProvider::Init(exports);
  }

  class IStorageFilePropertiesWithAvailability : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageFilePropertiesWithAvailability"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("isAvailable"), IsAvailableGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageFilePropertiesWithAvailability"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageFilePropertiesWithAvailability(::Windows::Storage::IStorageFilePropertiesWithAvailability^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageFilePropertiesWithAvailability^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFilePropertiesWithAvailability^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageFilePropertiesWithAvailability^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageFilePropertiesWithAvailability *wrapperInstance = new IStorageFilePropertiesWithAvailability(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> IsAvailableGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFilePropertiesWithAvailability^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IStorageFilePropertiesWithAvailability *wrapper = IStorageFilePropertiesWithAvailability::Unwrap<IStorageFilePropertiesWithAvailability>(info.This());

      try 
      {
        bool result = wrapper->_instance->IsAvailable;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::IStorageFilePropertiesWithAvailability^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageFilePropertiesWithAvailability(::Windows::Storage::IStorageFilePropertiesWithAvailability^ wintRtInstance);
    friend ::Windows::Storage::IStorageFilePropertiesWithAvailability^ UnwrapIStorageFilePropertiesWithAvailability(Handle<Value> value);
    friend bool IsIStorageFilePropertiesWithAvailabilityWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageFilePropertiesWithAvailability::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageFilePropertiesWithAvailability(::Windows::Storage::IStorageFilePropertiesWithAvailability^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageFilePropertiesWithAvailability::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageFilePropertiesWithAvailability^ UnwrapIStorageFilePropertiesWithAvailability(Handle<Value> value)
  {
     return IStorageFilePropertiesWithAvailability::Unwrap<IStorageFilePropertiesWithAvailability>(value.As<Object>())->_instance;
  }

  void InitIStorageFilePropertiesWithAvailability(Handle<Object> exports)
  {
    IStorageFilePropertiesWithAvailability::Init(exports);
  }

  class IStorageFolder2 : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStorageFolder2"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                  
      func = FunctionTemplate::New(TryGetItemAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("tryGetItemAsync"), func);
      
                  
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStorageFolder2"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStorageFolder2(::Windows::Storage::IStorageFolder2^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::IStorageFolder2^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder2^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::IStorageFolder2^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStorageFolder2 *wrapperInstance = new IStorageFolder2(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> TryGetItemAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFolder2^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      IStorageFolder2 *wrapper = IStorageFolder2::Unwrap<IStorageFolder2>(args.This());

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::IStorageItem^>^ op;
    

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = wrapper->_instance->TryGetItemAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::IStorageItem^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = WrapIStorageItem(result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  





  private:
    ::Windows::Storage::IStorageFolder2^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStorageFolder2(::Windows::Storage::IStorageFolder2^ wintRtInstance);
    friend ::Windows::Storage::IStorageFolder2^ UnwrapIStorageFolder2(Handle<Value> value);
    friend bool IsIStorageFolder2Wrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStorageFolder2::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStorageFolder2(::Windows::Storage::IStorageFolder2^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStorageFolder2::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::IStorageFolder2^ UnwrapIStorageFolder2(Handle<Value> value)
  {
     return IStorageFolder2::Unwrap<IStorageFolder2>(value.As<Object>())->_instance;
  }

  void InitIStorageFolder2(Handle<Object> exports)
  {
    IStorageFolder2::Init(exports);
  }

  class FileIO : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileIO"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(ReadTextAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("readTextAsync"), func);
      func = FunctionTemplate::New(WriteTextAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeTextAsync"), func);
      func = FunctionTemplate::New(AppendTextAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("appendTextAsync"), func);
      func = FunctionTemplate::New(ReadLinesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("readLinesAsync"), func);
      func = FunctionTemplate::New(WriteLinesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeLinesAsync"), func);
      func = FunctionTemplate::New(AppendLinesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("appendLinesAsync"), func);
      func = FunctionTemplate::New(ReadBufferAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("readBufferAsync"), func);
      func = FunctionTemplate::New(WriteBufferAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeBufferAsync"), func);
      func = FunctionTemplate::New(WriteBytesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeBytesAsync"), func);

      exports->Set(String::NewSymbol("FileIO"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileIO(::Windows::Storage::FileIO^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::FileIO^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::FileIO^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::FileIO^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileIO *wrapperInstance = new FileIO(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  

    static Handle<Value> ReadTextAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Platform::String^>^ op;
      

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = ::Windows::Storage::FileIO::ReadTextAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Storage::Streams::UnicodeEncoding arg1 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[1]->Int32Value());
          
          op = ::Windows::Storage::FileIO::ReadTextAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Platform::String^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::NewString(result->Data());
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteTextAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsString())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = ::Windows::Storage::FileIO::WriteTextAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::FileIO::WriteTextAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> AppendTextAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsString())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = ::Windows::Storage::FileIO::AppendTextAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::FileIO::AppendTextAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadLinesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVector<::Platform::String^>^>^ op;
      

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = ::Windows::Storage::FileIO::ReadLinesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Storage::Streams::UnicodeEncoding arg1 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[1]->Int32Value());
          
          op = ::Windows::Storage::FileIO::ReadLinesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVector<::Platform::String^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteLinesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray()))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          
          op = ::Windows::Storage::FileIO::WriteLinesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray())
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::FileIO::WriteLinesAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> AppendLinesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray()))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          
          op = ::Windows::Storage::FileIO::AppendLinesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray())
        && args[2]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::FileIO::AppendLinesAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBufferAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IBuffer^>^ op;
      

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = ::Windows::Storage::FileIO::ReadBufferAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBufferAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[1]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          op = ::Windows::Storage::FileIO::WriteBufferAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBytesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(args[1]) || args[1]->IsArray()))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          ::Platform::Array<unsigned char>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          
          op = ::Windows::Storage::FileIO::WriteBytesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }




  private:
    ::Windows::Storage::FileIO^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileIO(::Windows::Storage::FileIO^ wintRtInstance);
    friend ::Windows::Storage::FileIO^ UnwrapFileIO(Handle<Value> value);
    friend bool IsFileIOWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileIO::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileIO(::Windows::Storage::FileIO^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileIO::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::FileIO^ UnwrapFileIO(Handle<Value> value)
  {
     return FileIO::Unwrap<FileIO>(value.As<Object>())->_instance;
  }

  void InitFileIO(Handle<Object> exports)
  {
    FileIO::Init(exports);
  }

  class PathIO : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("PathIO"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      func = FunctionTemplate::New(ReadTextAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("readTextAsync"), func);
      func = FunctionTemplate::New(WriteTextAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeTextAsync"), func);
      func = FunctionTemplate::New(AppendTextAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("appendTextAsync"), func);
      func = FunctionTemplate::New(ReadLinesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("readLinesAsync"), func);
      func = FunctionTemplate::New(WriteLinesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeLinesAsync"), func);
      func = FunctionTemplate::New(AppendLinesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("appendLinesAsync"), func);
      func = FunctionTemplate::New(ReadBufferAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("readBufferAsync"), func);
      func = FunctionTemplate::New(WriteBufferAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeBufferAsync"), func);
      func = FunctionTemplate::New(WriteBytesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("writeBytesAsync"), func);

      exports->Set(String::NewSymbol("PathIO"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    PathIO(::Windows::Storage::PathIO^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::PathIO^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::PathIO^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::PathIO^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      PathIO *wrapperInstance = new PathIO(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  

    static Handle<Value> ReadTextAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Platform::String^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::PathIO::ReadTextAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::Streams::UnicodeEncoding arg1 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[1]->Int32Value());
          
          op = ::Windows::Storage::PathIO::ReadTextAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Platform::String^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::NewString(result->Data());
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteTextAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = ::Windows::Storage::PathIO::WriteTextAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsString()
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::PathIO::WriteTextAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> AppendTextAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          op = ::Windows::Storage::PathIO::AppendTextAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsString()
        && args[1]->IsString()
        && args[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::PathIO::AppendTextAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadLinesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Foundation::Collections::IVector<::Platform::String^>^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::PathIO::ReadLinesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 3
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::Streams::UnicodeEncoding arg1 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[1]->Int32Value());
          
          op = ::Windows::Storage::PathIO::ReadLinesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Foundation::Collections::IVector<::Platform::String^>^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Collections::VectorWrapper<::Platform::String^>::CreateVectorWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          );
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteLinesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && args[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray()))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          
          op = ::Windows::Storage::PathIO::WriteLinesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray())
        && args[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::PathIO::WriteLinesAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> AppendLinesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && args[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray()))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          
          op = ::Windows::Storage::PathIO::AppendLinesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 4
        && args[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(args[1]) || args[1]->IsArray())
        && args[2]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Foundation::Collections::IIterable<::Platform::String^>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Windows::Foundation::Collections::IIterable<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtVector<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Windows::Foundation::Collections::IIterable<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          ::Windows::Storage::Streams::UnicodeEncoding arg2 = static_cast<::Windows::Storage::Streams::UnicodeEncoding>(args[2]->Int32Value());
          
          op = ::Windows::Storage::PathIO::AppendLinesAsync(arg0,arg1,arg2);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ReadBufferAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Streams::IBuffer^>^ op;
      

      if (args.Length() == 2
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          op = ::Windows::Storage::PathIO::ReadBufferAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Streams::IBuffer^> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage.Streams", "IBuffer", result);
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBufferAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && args[0]->IsString()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Streams::IBuffer^>(args[1]))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::Streams::IBuffer^ arg1 = dynamic_cast<::Windows::Storage::Streams::IBuffer^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          op = ::Windows::Storage::PathIO::WriteBufferAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> WriteBytesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncAction^ op;
      

      if (args.Length() == 3
        && args[0]->IsString()
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(args[1]) || args[1]->IsArray()))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Platform::Array<unsigned char>^ arg1 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[1]);
          
          op = ::Windows::Storage::PathIO::WriteBytesAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }




  private:
    ::Windows::Storage::PathIO^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapPathIO(::Windows::Storage::PathIO^ wintRtInstance);
    friend ::Windows::Storage::PathIO^ UnwrapPathIO(Handle<Value> value);
    friend bool IsPathIOWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> PathIO::s_constructorTemplate;

  v8::Handle<v8::Value> WrapPathIO(::Windows::Storage::PathIO^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(PathIO::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::PathIO^ UnwrapPathIO(Handle<Value> value)
  {
     return PathIO::Unwrap<PathIO>(value.As<Object>())->_instance;
  }

  void InitPathIO(Handle<Object> exports)
  {
    PathIO::Init(exports);
  }

  class CachedFileManager : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("CachedFileManager"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("deferUpdates"), FunctionTemplate::New(DeferUpdates)->GetFunction());
      func = FunctionTemplate::New(CompleteUpdatesAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      constructor->Set(String::NewSymbol("completeUpdatesAsync"), func);

      exports->Set(String::NewSymbol("CachedFileManager"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    CachedFileManager(::Windows::Storage::CachedFileManager^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::CachedFileManager^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::CachedFileManager^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::CachedFileManager^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      CachedFileManager *wrapperInstance = new CachedFileManager(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  

    static Handle<Value> CompleteUpdatesAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ::Windows::Foundation::IAsyncOperation<::Windows::Storage::Provider::FileUpdateStatus>^ op;
      

      if (args.Length() == 2
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          op = ::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<::Windows::Storage::Provider::FileUpdateStatus> t) 
      {	
        try
        {
          auto result = t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [result](NodeUtils::InvokeCallbackDelegate invokeCallback) {

            
            TryCatch tryCatch;
            Handle<Value> error; 
            Handle<Value> arg1 = Integer::New(static_cast<int>(result));
            if (tryCatch.HasCaught())
            {
              error = tryCatch.Exception()->ToObject();
            }
            else 
            {
              error = Undefined();
            }
            if (arg1.IsEmpty()) arg1 = Undefined();
            Handle<Value> args[] = {error, arg1};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
          
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }

    static Handle<Value> DeferUpdates(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = UnwrapIStorageFile(args[0]);
          
          ::Windows::Storage::CachedFileManager::DeferUpdates(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



  private:
    ::Windows::Storage::CachedFileManager^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapCachedFileManager(::Windows::Storage::CachedFileManager^ wintRtInstance);
    friend ::Windows::Storage::CachedFileManager^ UnwrapCachedFileManager(Handle<Value> value);
    friend bool IsCachedFileManagerWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> CachedFileManager::s_constructorTemplate;

  v8::Handle<v8::Value> WrapCachedFileManager(::Windows::Storage::CachedFileManager^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(CachedFileManager::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::CachedFileManager^ UnwrapCachedFileManager(Handle<Value> value)
  {
     return CachedFileManager::Unwrap<CachedFileManager>(value.As<Object>())->_instance;
  }

  void InitCachedFileManager(Handle<Object> exports)
  {
    CachedFileManager::Init(exports);
  }

  class SystemAudioProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemAudioProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("encodingBitrate"), EncodingBitrateGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemAudioProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemAudioProperties(::Windows::Storage::SystemAudioProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemAudioProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemAudioProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemAudioProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemAudioProperties *wrapperInstance = new SystemAudioProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> EncodingBitrateGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemAudioProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemAudioProperties *wrapper = SystemAudioProperties::Unwrap<SystemAudioProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->EncodingBitrate;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemAudioProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemAudioProperties(::Windows::Storage::SystemAudioProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemAudioProperties^ UnwrapSystemAudioProperties(Handle<Value> value);
    friend bool IsSystemAudioPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemAudioProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemAudioProperties(::Windows::Storage::SystemAudioProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemAudioProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemAudioProperties^ UnwrapSystemAudioProperties(Handle<Value> value)
  {
     return SystemAudioProperties::Unwrap<SystemAudioProperties>(value.As<Object>())->_instance;
  }

  void InitSystemAudioProperties(Handle<Object> exports)
  {
    SystemAudioProperties::Init(exports);
  }

  class SystemGPSProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemGPSProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("latitudeDecimal"), LatitudeDecimalGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("longitudeDecimal"), LongitudeDecimalGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemGPSProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemGPSProperties(::Windows::Storage::SystemGPSProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemGPSProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemGPSProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemGPSProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemGPSProperties *wrapperInstance = new SystemGPSProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> LatitudeDecimalGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemGPSProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemGPSProperties *wrapper = SystemGPSProperties::Unwrap<SystemGPSProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->LatitudeDecimal;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LongitudeDecimalGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemGPSProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemGPSProperties *wrapper = SystemGPSProperties::Unwrap<SystemGPSProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->LongitudeDecimal;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemGPSProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemGPSProperties(::Windows::Storage::SystemGPSProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemGPSProperties^ UnwrapSystemGPSProperties(Handle<Value> value);
    friend bool IsSystemGPSPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemGPSProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemGPSProperties(::Windows::Storage::SystemGPSProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemGPSProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemGPSProperties^ UnwrapSystemGPSProperties(Handle<Value> value)
  {
     return SystemGPSProperties::Unwrap<SystemGPSProperties>(value.As<Object>())->_instance;
  }

  void InitSystemGPSProperties(Handle<Object> exports)
  {
    SystemGPSProperties::Init(exports);
  }

  class SystemImageProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemImageProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("horizontalSize"), HorizontalSizeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("verticalSize"), VerticalSizeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemImageProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemImageProperties(::Windows::Storage::SystemImageProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemImageProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemImageProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemImageProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemImageProperties *wrapperInstance = new SystemImageProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> HorizontalSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemImageProperties *wrapper = SystemImageProperties::Unwrap<SystemImageProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->HorizontalSize;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> VerticalSizeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemImageProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemImageProperties *wrapper = SystemImageProperties::Unwrap<SystemImageProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->VerticalSize;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemImageProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemImageProperties(::Windows::Storage::SystemImageProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemImageProperties^ UnwrapSystemImageProperties(Handle<Value> value);
    friend bool IsSystemImagePropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemImageProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemImageProperties(::Windows::Storage::SystemImageProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemImageProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemImageProperties^ UnwrapSystemImageProperties(Handle<Value> value)
  {
     return SystemImageProperties::Unwrap<SystemImageProperties>(value.As<Object>())->_instance;
  }

  void InitSystemImageProperties(Handle<Object> exports)
  {
    SystemImageProperties::Init(exports);
  }

  class SystemMediaProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemMediaProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("duration"), DurationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("producer"), ProducerGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("publisher"), PublisherGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("subTitle"), SubTitleGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("writer"), WriterGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("year"), YearGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemMediaProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemMediaProperties(::Windows::Storage::SystemMediaProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemMediaProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemMediaProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemMediaProperties *wrapperInstance = new SystemMediaProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> DurationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMediaProperties *wrapper = SystemMediaProperties::Unwrap<SystemMediaProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Duration;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ProducerGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMediaProperties *wrapper = SystemMediaProperties::Unwrap<SystemMediaProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Producer;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PublisherGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMediaProperties *wrapper = SystemMediaProperties::Unwrap<SystemMediaProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Publisher;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SubTitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMediaProperties *wrapper = SystemMediaProperties::Unwrap<SystemMediaProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->SubTitle;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> WriterGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMediaProperties *wrapper = SystemMediaProperties::Unwrap<SystemMediaProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Writer;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> YearGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMediaProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMediaProperties *wrapper = SystemMediaProperties::Unwrap<SystemMediaProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Year;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemMediaProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemMediaProperties(::Windows::Storage::SystemMediaProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemMediaProperties^ UnwrapSystemMediaProperties(Handle<Value> value);
    friend bool IsSystemMediaPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemMediaProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemMediaProperties(::Windows::Storage::SystemMediaProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemMediaProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemMediaProperties^ UnwrapSystemMediaProperties(Handle<Value> value)
  {
     return SystemMediaProperties::Unwrap<SystemMediaProperties>(value.As<Object>())->_instance;
  }

  void InitSystemMediaProperties(Handle<Object> exports)
  {
    SystemMediaProperties::Init(exports);
  }

  class SystemMusicProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemMusicProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("albumArtist"), AlbumArtistGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("albumTitle"), AlbumTitleGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("artist"), ArtistGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("composer"), ComposerGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("conductor"), ConductorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayArtist"), DisplayArtistGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("genre"), GenreGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("trackNumber"), TrackNumberGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemMusicProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemMusicProperties(::Windows::Storage::SystemMusicProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemMusicProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemMusicProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemMusicProperties *wrapperInstance = new SystemMusicProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> AlbumArtistGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->AlbumArtist;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AlbumTitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->AlbumTitle;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ArtistGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Artist;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ComposerGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Composer;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ConductorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Conductor;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayArtistGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayArtist;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> GenreGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Genre;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> TrackNumberGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemMusicProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemMusicProperties *wrapper = SystemMusicProperties::Unwrap<SystemMusicProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->TrackNumber;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemMusicProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemMusicProperties(::Windows::Storage::SystemMusicProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemMusicProperties^ UnwrapSystemMusicProperties(Handle<Value> value);
    friend bool IsSystemMusicPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemMusicProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemMusicProperties(::Windows::Storage::SystemMusicProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemMusicProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemMusicProperties^ UnwrapSystemMusicProperties(Handle<Value> value)
  {
     return SystemMusicProperties::Unwrap<SystemMusicProperties>(value.As<Object>())->_instance;
  }

  void InitSystemMusicProperties(Handle<Object> exports)
  {
    SystemMusicProperties::Init(exports);
  }

  class SystemPhotoProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemPhotoProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("cameraManufacturer"), CameraManufacturerGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("cameraModel"), CameraModelGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("dateTaken"), DateTakenGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("orientation"), OrientationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("peopleNames"), PeopleNamesGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemPhotoProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemPhotoProperties(::Windows::Storage::SystemPhotoProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemPhotoProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemPhotoProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemPhotoProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemPhotoProperties *wrapperInstance = new SystemPhotoProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> CameraManufacturerGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemPhotoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemPhotoProperties *wrapper = SystemPhotoProperties::Unwrap<SystemPhotoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->CameraManufacturer;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CameraModelGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemPhotoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemPhotoProperties *wrapper = SystemPhotoProperties::Unwrap<SystemPhotoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->CameraModel;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DateTakenGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemPhotoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemPhotoProperties *wrapper = SystemPhotoProperties::Unwrap<SystemPhotoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DateTaken;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OrientationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemPhotoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemPhotoProperties *wrapper = SystemPhotoProperties::Unwrap<SystemPhotoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Orientation;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PeopleNamesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemPhotoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemPhotoProperties *wrapper = SystemPhotoProperties::Unwrap<SystemPhotoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->PeopleNames;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemPhotoProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemPhotoProperties(::Windows::Storage::SystemPhotoProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemPhotoProperties^ UnwrapSystemPhotoProperties(Handle<Value> value);
    friend bool IsSystemPhotoPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemPhotoProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemPhotoProperties(::Windows::Storage::SystemPhotoProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemPhotoProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemPhotoProperties^ UnwrapSystemPhotoProperties(Handle<Value> value)
  {
     return SystemPhotoProperties::Unwrap<SystemPhotoProperties>(value.As<Object>())->_instance;
  }

  void InitSystemPhotoProperties(Handle<Object> exports)
  {
    SystemPhotoProperties::Init(exports);
  }

  class SystemVideoProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemVideoProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("director"), DirectorGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("frameHeight"), FrameHeightGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("frameWidth"), FrameWidthGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("orientation"), OrientationGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("totalBitrate"), TotalBitrateGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SystemVideoProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemVideoProperties(::Windows::Storage::SystemVideoProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemVideoProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemVideoProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemVideoProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemVideoProperties *wrapperInstance = new SystemVideoProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> DirectorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemVideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemVideoProperties *wrapper = SystemVideoProperties::Unwrap<SystemVideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Director;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FrameHeightGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemVideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemVideoProperties *wrapper = SystemVideoProperties::Unwrap<SystemVideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FrameHeight;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FrameWidthGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemVideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemVideoProperties *wrapper = SystemVideoProperties::Unwrap<SystemVideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->FrameWidth;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> OrientationGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemVideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemVideoProperties *wrapper = SystemVideoProperties::Unwrap<SystemVideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Orientation;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> TotalBitrateGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemVideoProperties^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SystemVideoProperties *wrapper = SystemVideoProperties::Unwrap<SystemVideoProperties>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->TotalBitrate;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SystemVideoProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemVideoProperties(::Windows::Storage::SystemVideoProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemVideoProperties^ UnwrapSystemVideoProperties(Handle<Value> value);
    friend bool IsSystemVideoPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemVideoProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemVideoProperties(::Windows::Storage::SystemVideoProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemVideoProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemVideoProperties^ UnwrapSystemVideoProperties(Handle<Value> value)
  {
     return SystemVideoProperties::Unwrap<SystemVideoProperties>(value.As<Object>())->_instance;
  }

  void InitSystemVideoProperties(Handle<Object> exports)
  {
    SystemVideoProperties::Init(exports);
  }

  class SystemProperties : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SystemProperties"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->SetAccessor(String::NewSymbol("audio"), AudioGetter);
      constructor->SetAccessor(String::NewSymbol("author"), AuthorGetter);
      constructor->SetAccessor(String::NewSymbol("comment"), CommentGetter);
      constructor->SetAccessor(String::NewSymbol("gPS"), GPSGetter);
      constructor->SetAccessor(String::NewSymbol("image"), ImageGetter);
      constructor->SetAccessor(String::NewSymbol("itemNameDisplay"), ItemNameDisplayGetter);
      constructor->SetAccessor(String::NewSymbol("keywords"), KeywordsGetter);
      constructor->SetAccessor(String::NewSymbol("media"), MediaGetter);
      constructor->SetAccessor(String::NewSymbol("music"), MusicGetter);
      constructor->SetAccessor(String::NewSymbol("photo"), PhotoGetter);
      constructor->SetAccessor(String::NewSymbol("rating"), RatingGetter);
      constructor->SetAccessor(String::NewSymbol("title"), TitleGetter);
      constructor->SetAccessor(String::NewSymbol("video"), VideoGetter);

      exports->Set(String::NewSymbol("SystemProperties"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SystemProperties(::Windows::Storage::SystemProperties^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SystemProperties^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SystemProperties^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SystemProperties^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SystemProperties *wrapperInstance = new SystemProperties(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  




    static Handle<Value> AudioGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemAudioProperties^ result = ::Windows::Storage::SystemProperties::Audio;
        return scope.Close(WrapSystemAudioProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AuthorGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        Platform::String^ result = ::Windows::Storage::SystemProperties::Author;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> CommentGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        Platform::String^ result = ::Windows::Storage::SystemProperties::Comment;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> GPSGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemGPSProperties^ result = ::Windows::Storage::SystemProperties::GPS;
        return scope.Close(WrapSystemGPSProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ImageGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemImageProperties^ result = ::Windows::Storage::SystemProperties::Image;
        return scope.Close(WrapSystemImageProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ItemNameDisplayGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        Platform::String^ result = ::Windows::Storage::SystemProperties::ItemNameDisplay;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> KeywordsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        Platform::String^ result = ::Windows::Storage::SystemProperties::Keywords;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MediaGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemMediaProperties^ result = ::Windows::Storage::SystemProperties::Media;
        return scope.Close(WrapSystemMediaProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> MusicGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemMusicProperties^ result = ::Windows::Storage::SystemProperties::Music;
        return scope.Close(WrapSystemMusicProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PhotoGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemPhotoProperties^ result = ::Windows::Storage::SystemProperties::Photo;
        return scope.Close(WrapSystemPhotoProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RatingGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        Platform::String^ result = ::Windows::Storage::SystemProperties::Rating;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> TitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        Platform::String^ result = ::Windows::Storage::SystemProperties::Title;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> VideoGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::SystemVideoProperties^ result = ::Windows::Storage::SystemProperties::Video;
        return scope.Close(WrapSystemVideoProperties(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    

  private:
    ::Windows::Storage::SystemProperties^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSystemProperties(::Windows::Storage::SystemProperties^ wintRtInstance);
    friend ::Windows::Storage::SystemProperties^ UnwrapSystemProperties(Handle<Value> value);
    friend bool IsSystemPropertiesWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SystemProperties::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSystemProperties(::Windows::Storage::SystemProperties^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SystemProperties::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SystemProperties^ UnwrapSystemProperties(Handle<Value> value)
  {
     return SystemProperties::Unwrap<SystemProperties>(value.As<Object>())->_instance;
  }

  void InitSystemProperties(Handle<Object> exports)
  {
    SystemProperties::Init(exports);
  }

  class ApplicationData : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("ApplicationData"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
      Handle<Value> asyncSymbol = String::NewSymbol("__winRtAsync__");
      Handle<Function> func;
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("signalDataChanged"), FunctionTemplate::New(SignalDataChanged)->GetFunction());
      
            
      func = FunctionTemplate::New(SetVersionAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("setVersionAsync"), func);
      func = FunctionTemplate::New(ClearAsync)->GetFunction();
      func->Set(asyncSymbol, True(), PropertyAttribute::DontEnum);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clearAsync"), func);
      
            
      Local<Function> addListenerFunc = FunctionTemplate::New(AddListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("addListener"), addListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("on"), addListenerFunc);
      Local<Function> removeListenerFunc = FunctionTemplate::New(RemoveListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("removeListener"), removeListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("off"), removeListenerFunc);
            
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("localFolder"), LocalFolderGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("localSettings"), LocalSettingsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("roamingFolder"), RoamingFolderGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("roamingSettings"), RoamingSettingsGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("roamingStorageQuota"), RoamingStorageQuotaGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("temporaryFolder"), TemporaryFolderGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("version"), VersionGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->SetAccessor(String::NewSymbol("current"), CurrentGetter);

      exports->Set(String::NewSymbol("ApplicationData"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    ApplicationData(::Windows::Storage::ApplicationData^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::ApplicationData^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::ApplicationData^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      ApplicationData *wrapperInstance = new ApplicationData(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


    static Handle<Value> SetVersionAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 3
        && args[0]->IsUint32()
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataSetVersionHandler^>(args[1]))
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          ::Windows::Storage::ApplicationDataSetVersionHandler^ arg1 = dynamic_cast<::Windows::Storage::ApplicationDataSetVersionHandler^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          op = wrapper->_instance->SetVersionAsync(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
    static Handle<Value> ClearAsync(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      if (args.Length() == 0 || !args[args.Length() -1]->IsFunction())
      {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: No callback was given")));
          return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(args.This());

      ::Windows::Foundation::IAsyncAction^ op;
    

      if (args.Length() == 1)
      {
        try
        {
          op = wrapper->_instance->ClearAsync();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsInt32())
      {
        try
        {
          ::Windows::Storage::ApplicationDataLocality arg0 = static_cast<::Windows::Storage::ApplicationDataLocality>(args[0]->Int32Value());
          
          op = wrapper->_instance->ClearAsync(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }
    
      auto opTask = create_task(op);
      uv_async_t* asyncToken = NodeUtils::Async::GetAsyncToken(args[args.Length() -1].As<Function>());

      opTask.then( [asyncToken] (task<void> t) 
      {	
        try
        {
          t.get();
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [](NodeUtils::InvokeCallbackDelegate invokeCallback) {


            Handle<Value> args[] = {Undefined()};

            invokeCallback(_countof(args), args);
          });
        }
        catch (Platform::Exception^ exception)
        {
          NodeUtils::Async::RunCallbackOnMain(asyncToken, [exception](NodeUtils::InvokeCallbackDelegate invokeCallback) {
             
            Handle<Value> error = NodeRT::Utils::WinRtExceptionToJsError(exception);
        
            Handle<Value> args[] = {error};
            invokeCallback(_countof(args), args);
          });
        }  		
      });

      return scope.Close(Undefined());
    }
  
    static Handle<Value> SignalDataChanged(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->SignalDataChanged();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> LocalFolderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        ::Windows::Storage::StorageFolder^ result = wrapper->_instance->LocalFolder;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LocalSettingsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        ::Windows::Storage::ApplicationDataContainer^ result = wrapper->_instance->LocalSettings;
        return scope.Close(WrapApplicationDataContainer(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RoamingFolderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        ::Windows::Storage::StorageFolder^ result = wrapper->_instance->RoamingFolder;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RoamingSettingsGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        ::Windows::Storage::ApplicationDataContainer^ result = wrapper->_instance->RoamingSettings;
        return scope.Close(WrapApplicationDataContainer(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RoamingStorageQuotaGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        unsigned __int64 result = wrapper->_instance->RoamingStorageQuota;
        return scope.Close(Number::New(static_cast<double>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> TemporaryFolderGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        ::Windows::Storage::StorageFolder^ result = wrapper->_instance->TemporaryFolder;
        return scope.Close(WrapStorageFolder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> VersionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Version;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    

    static Handle<Value> CurrentGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;

      try 
      {
        ::Windows::Storage::ApplicationData^ result = ::Windows::Storage::ApplicationData::Current;
        return scope.Close(WrapApplicationData(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    

    static v8::Handle<v8::Value> AddListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;
      
      Local<Function> callback = args[1].As<Function>();
      
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"dataChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->DataChanged::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Storage::ApplicationData^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Storage::ApplicationData^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = WrapApplicationData(arg0);
                Handle<Value> wrappedArg1 = CreateOpaqueWrapper(arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else 
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
          tokenMap = Object::New();
          callback->SetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME), tokenMap);
      }

      tokenMap.As<Object>()->Set(args[1], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
                
      return scope.Close(Undefined());
    }

    static v8::Handle<v8::Value> RemoveListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;

      if ((NodeRT::Utils::CaseInsenstiveEquals(L"dataChanged", str)))
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Function> callback = args[1].As<Function>();
      Handle<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      Handle<Value> opaqueWrapperObj =  tokenMap.As<Object>()->Get(args[1]);

      if (opaqueWrapperObj.IsEmpty() || opaqueWrapperObj->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());
            
      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;
        
      try 
      {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"dataChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationData^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          ApplicationData *wrapper = ApplicationData::Unwrap<ApplicationData>(args.This());
          wrapper->_instance->DataChanged::remove(registrationToken);
        }
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      tokenMap.As<Object>()->Delete(args[0].As<String>());

      return scope.Close(Undefined());
    }
  private:
    ::Windows::Storage::ApplicationData^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapApplicationData(::Windows::Storage::ApplicationData^ wintRtInstance);
    friend ::Windows::Storage::ApplicationData^ UnwrapApplicationData(Handle<Value> value);
    friend bool IsApplicationDataWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> ApplicationData::s_constructorTemplate;

  v8::Handle<v8::Value> WrapApplicationData(::Windows::Storage::ApplicationData^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(ApplicationData::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::ApplicationData^ UnwrapApplicationData(Handle<Value> value)
  {
     return ApplicationData::Unwrap<ApplicationData>(value.As<Object>())->_instance;
  }

  void InitApplicationData(Handle<Object> exports)
  {
    ApplicationData::Init(exports);
  }

  class SetVersionRequest : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SetVersionRequest"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDeferral"), FunctionTemplate::New(GetDeferral)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("currentVersion"), CurrentVersionGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("desiredVersion"), DesiredVersionGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SetVersionRequest"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SetVersionRequest(::Windows::Storage::SetVersionRequest^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SetVersionRequest^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SetVersionRequest^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SetVersionRequest^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SetVersionRequest *wrapperInstance = new SetVersionRequest(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetDeferral(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SetVersionRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      SetVersionRequest *wrapper = SetVersionRequest::Unwrap<SetVersionRequest>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::SetVersionDeferral^ result;
          result = wrapper->_instance->GetDeferral();
          return scope.Close(WrapSetVersionDeferral(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> CurrentVersionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SetVersionRequest^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SetVersionRequest *wrapper = SetVersionRequest::Unwrap<SetVersionRequest>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->CurrentVersion;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DesiredVersionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SetVersionRequest^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      SetVersionRequest *wrapper = SetVersionRequest::Unwrap<SetVersionRequest>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->DesiredVersion;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::SetVersionRequest^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSetVersionRequest(::Windows::Storage::SetVersionRequest^ wintRtInstance);
    friend ::Windows::Storage::SetVersionRequest^ UnwrapSetVersionRequest(Handle<Value> value);
    friend bool IsSetVersionRequestWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SetVersionRequest::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSetVersionRequest(::Windows::Storage::SetVersionRequest^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SetVersionRequest::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SetVersionRequest^ UnwrapSetVersionRequest(Handle<Value> value)
  {
     return SetVersionRequest::Unwrap<SetVersionRequest>(value.As<Object>())->_instance;
  }

  void InitSetVersionRequest(Handle<Object> exports)
  {
    SetVersionRequest::Init(exports);
  }

  class ApplicationDataContainer : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("ApplicationDataContainer"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("createContainer"), FunctionTemplate::New(CreateContainer)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("deleteContainer"), FunctionTemplate::New(DeleteContainer)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("containers"), ContainersGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("locality"), LocalityGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("name"), NameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("values"), ValuesGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("ApplicationDataContainer"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    ApplicationDataContainer(::Windows::Storage::ApplicationDataContainer^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::ApplicationDataContainer^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::ApplicationDataContainer^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      ApplicationDataContainer *wrapperInstance = new ApplicationDataContainer(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> CreateContainer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainer *wrapper = ApplicationDataContainer::Unwrap<ApplicationDataContainer>(args.This());

      if (args.Length() == 2
        && args[0]->IsString()
        && args[1]->IsInt32())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Windows::Storage::ApplicationDataCreateDisposition arg1 = static_cast<::Windows::Storage::ApplicationDataCreateDisposition>(args[1]->Int32Value());
          
          ::Windows::Storage::ApplicationDataContainer^ result;
          result = wrapper->_instance->CreateContainer(arg0, arg1);
          return scope.Close(WrapApplicationDataContainer(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> DeleteContainer(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainer *wrapper = ApplicationDataContainer::Unwrap<ApplicationDataContainer>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          wrapper->_instance->DeleteContainer(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> ContainersGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainer *wrapper = ApplicationDataContainer::Unwrap<ApplicationDataContainer>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IMapView<::Platform::String^, ::Windows::Storage::ApplicationDataContainer^>^ result = wrapper->_instance->Containers;
        return scope.Close(NodeRT::Collections::MapViewWrapper<::Platform::String^,::Windows::Storage::ApplicationDataContainer^>::CreateMapViewWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Windows::Storage::ApplicationDataContainer^ val) -> Handle<Value> {
              return WrapApplicationDataContainer(val);
            }
          ));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> LocalityGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainer *wrapper = ApplicationDataContainer::Unwrap<ApplicationDataContainer>(info.This());

      try 
      {
        ::Windows::Storage::ApplicationDataLocality result = wrapper->_instance->Locality;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> NameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainer *wrapper = ApplicationDataContainer::Unwrap<ApplicationDataContainer>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Name;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ValuesGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainer^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainer *wrapper = ApplicationDataContainer::Unwrap<ApplicationDataContainer>(info.This());

      try 
      {
        ::Windows::Foundation::Collections::IPropertySet^ result = wrapper->_instance->Values;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation.Collections", "IPropertySet", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::ApplicationDataContainer^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapApplicationDataContainer(::Windows::Storage::ApplicationDataContainer^ wintRtInstance);
    friend ::Windows::Storage::ApplicationDataContainer^ UnwrapApplicationDataContainer(Handle<Value> value);
    friend bool IsApplicationDataContainerWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> ApplicationDataContainer::s_constructorTemplate;

  v8::Handle<v8::Value> WrapApplicationDataContainer(::Windows::Storage::ApplicationDataContainer^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(ApplicationDataContainer::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::ApplicationDataContainer^ UnwrapApplicationDataContainer(Handle<Value> value)
  {
     return ApplicationDataContainer::Unwrap<ApplicationDataContainer>(value.As<Object>())->_instance;
  }

  void InitApplicationDataContainer(Handle<Object> exports)
  {
    ApplicationDataContainer::Init(exports);
  }

  class SetVersionDeferral : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("SetVersionDeferral"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("complete"), FunctionTemplate::New(Complete)->GetFunction());
      
                        
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("SetVersionDeferral"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    SetVersionDeferral(::Windows::Storage::SetVersionDeferral^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::SetVersionDeferral^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SetVersionDeferral^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::SetVersionDeferral^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      SetVersionDeferral *wrapperInstance = new SetVersionDeferral(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> Complete(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::SetVersionDeferral^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      SetVersionDeferral *wrapper = SetVersionDeferral::Unwrap<SetVersionDeferral>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Complete();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Storage::SetVersionDeferral^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapSetVersionDeferral(::Windows::Storage::SetVersionDeferral^ wintRtInstance);
    friend ::Windows::Storage::SetVersionDeferral^ UnwrapSetVersionDeferral(Handle<Value> value);
    friend bool IsSetVersionDeferralWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> SetVersionDeferral::s_constructorTemplate;

  v8::Handle<v8::Value> WrapSetVersionDeferral(::Windows::Storage::SetVersionDeferral^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(SetVersionDeferral::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::SetVersionDeferral^ UnwrapSetVersionDeferral(Handle<Value> value)
  {
     return SetVersionDeferral::Unwrap<SetVersionDeferral>(value.As<Object>())->_instance;
  }

  void InitSetVersionDeferral(Handle<Object> exports)
  {
    SetVersionDeferral::Init(exports);
  }

  class ApplicationDataContainerSettings : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("ApplicationDataContainerSettings"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("lookup"), FunctionTemplate::New(Lookup)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("hasKey"), FunctionTemplate::New(HasKey)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getView"), FunctionTemplate::New(GetView)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("insert"), FunctionTemplate::New(Insert)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("remove"), FunctionTemplate::New(Remove)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clear"), FunctionTemplate::New(Clear)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("first"), FunctionTemplate::New(First)->GetFunction());
      
                  
      Local<Function> addListenerFunc = FunctionTemplate::New(AddListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("addListener"), addListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("on"), addListenerFunc);
      Local<Function> removeListenerFunc = FunctionTemplate::New(RemoveListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("removeListener"), removeListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("off"), removeListenerFunc);
            
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("ApplicationDataContainerSettings"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    ApplicationDataContainerSettings(::Windows::Storage::ApplicationDataContainerSettings^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::ApplicationDataContainerSettings^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::ApplicationDataContainerSettings^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      ApplicationDataContainerSettings *wrapperInstance = new ApplicationDataContainerSettings(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> Lookup(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          ::Platform::Object^ result;
          result = wrapper->_instance->Lookup(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> HasKey(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          bool result;
          result = wrapper->_instance->HasKey(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetView(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IMapView<::Platform::String^, ::Platform::Object^>^ result;
          result = wrapper->_instance->GetView();
          return scope.Close(NodeRT::Collections::MapViewWrapper<::Platform::String^,::Platform::Object^>::CreateMapViewWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            }
          ));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Insert(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 2
        && args[0]->IsString()
        && NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(args[1]))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Platform::Object^ arg1 = dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          bool result;
          result = wrapper->_instance->Insert(arg0, arg1);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Remove(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          wrapper->_instance->Remove(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Clear(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Clear();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> First(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IIterator<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ result;
          result = wrapper->_instance->First();
          return scope.Close(NodeRT::Collections::IteratorWrapper<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>::CreateIteratorWrapper(result, 
            [](::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^ val) -> Handle<Value> {
              return NodeRT::Collections::KeyValuePairWrapper<::Platform::String^,::Platform::Object^>::CreateKeyValuePairWrapper(val, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            }
          );
            }
          ));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





    static v8::Handle<v8::Value> AddListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;
      
      Local<Function> callback = args[1].As<Function>();
      
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"mapChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->MapChanged::add(
            ref new ::Windows::Foundation::Collections::MapChangedEventHandler<::Platform::String^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Foundation::Collections::IObservableMap<::Platform::String^, ::Platform::Object^>^ arg0, ::Windows::Foundation::Collections::IMapChangedEventArgs<::Platform::String^>^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation.Collections", "IObservableMap`2", arg0);
                Handle<Value> wrappedArg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation.Collections", "IMapChangedEventArgs`1", arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else 
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
          tokenMap = Object::New();
          callback->SetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME), tokenMap);
      }

      tokenMap.As<Object>()->Set(args[1], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
                
      return scope.Close(Undefined());
    }

    static v8::Handle<v8::Value> RemoveListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;

      if ((NodeRT::Utils::CaseInsenstiveEquals(L"mapChanged", str)))
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Function> callback = args[1].As<Function>();
      Handle<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      Handle<Value> opaqueWrapperObj =  tokenMap.As<Object>()->Get(args[1]);

      if (opaqueWrapperObj.IsEmpty() || opaqueWrapperObj->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());
            
      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;
        
      try 
      {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"mapChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataContainerSettings^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          ApplicationDataContainerSettings *wrapper = ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(args.This());
          wrapper->_instance->MapChanged::remove(registrationToken);
        }
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      tokenMap.As<Object>()->Delete(args[0].As<String>());

      return scope.Close(Undefined());
    }
  private:
    ::Windows::Storage::ApplicationDataContainerSettings^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapApplicationDataContainerSettings(::Windows::Storage::ApplicationDataContainerSettings^ wintRtInstance);
    friend ::Windows::Storage::ApplicationDataContainerSettings^ UnwrapApplicationDataContainerSettings(Handle<Value> value);
    friend bool IsApplicationDataContainerSettingsWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> ApplicationDataContainerSettings::s_constructorTemplate;

  v8::Handle<v8::Value> WrapApplicationDataContainerSettings(::Windows::Storage::ApplicationDataContainerSettings^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(ApplicationDataContainerSettings::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::ApplicationDataContainerSettings^ UnwrapApplicationDataContainerSettings(Handle<Value> value)
  {
     return ApplicationDataContainerSettings::Unwrap<ApplicationDataContainerSettings>(value.As<Object>())->_instance;
  }

  void InitApplicationDataContainerSettings(Handle<Object> exports)
  {
    ApplicationDataContainerSettings::Init(exports);
  }

  class ApplicationDataCompositeValue : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("ApplicationDataCompositeValue"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("lookup"), FunctionTemplate::New(Lookup)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("hasKey"), FunctionTemplate::New(HasKey)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getView"), FunctionTemplate::New(GetView)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("insert"), FunctionTemplate::New(Insert)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("remove"), FunctionTemplate::New(Remove)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("clear"), FunctionTemplate::New(Clear)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("first"), FunctionTemplate::New(First)->GetFunction());
      
                  
      Local<Function> addListenerFunc = FunctionTemplate::New(AddListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("addListener"), addListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("on"), addListenerFunc);
      Local<Function> removeListenerFunc = FunctionTemplate::New(RemoveListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("removeListener"), removeListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("off"), removeListenerFunc);
            
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("ApplicationDataCompositeValue"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    ApplicationDataCompositeValue(::Windows::Storage::ApplicationDataCompositeValue^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::ApplicationDataCompositeValue^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::ApplicationDataCompositeValue^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 0)
      {
        try
        {
          winRtInstance = ref new ::Windows::Storage::ApplicationDataCompositeValue();
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      ApplicationDataCompositeValue *wrapperInstance = new ApplicationDataCompositeValue(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> Lookup(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          ::Platform::Object^ result;
          result = wrapper->_instance->Lookup(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> HasKey(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          bool result;
          result = wrapper->_instance->HasKey(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetView(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IMapView<::Platform::String^, ::Platform::Object^>^ result;
          result = wrapper->_instance->GetView();
          return scope.Close(NodeRT::Collections::MapViewWrapper<::Platform::String^,::Platform::Object^>::CreateMapViewWrapper(result, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            }
          ));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Insert(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 2
        && args[0]->IsString()
        && NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(args[1]))
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          ::Platform::Object^ arg1 = dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(args[1]));
          
          bool result;
          result = wrapper->_instance->Insert(arg0, arg1);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Remove(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          wrapper->_instance->Remove(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Clear(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Clear();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> First(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IIterator<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>^ result;
          result = wrapper->_instance->First();
          return scope.Close(NodeRT::Collections::IteratorWrapper<::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^>::CreateIteratorWrapper(result, 
            [](::Windows::Foundation::Collections::IKeyValuePair<::Platform::String^, ::Platform::Object^>^ val) -> Handle<Value> {
              return NodeRT::Collections::KeyValuePairWrapper<::Platform::String^,::Platform::Object^>::CreateKeyValuePairWrapper(val, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            }
          );
            }
          ));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





    static v8::Handle<v8::Value> AddListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;
      
      Local<Function> callback = args[1].As<Function>();
      
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"mapChanged", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->MapChanged::add(
            ref new ::Windows::Foundation::Collections::MapChangedEventHandler<::Platform::String^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Foundation::Collections::IObservableMap<::Platform::String^, ::Platform::Object^>^ arg0, ::Windows::Foundation::Collections::IMapChangedEventArgs<::Platform::String^>^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation.Collections", "IObservableMap`2", arg0);
                Handle<Value> wrappedArg1 = NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation.Collections", "IMapChangedEventArgs`1", arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else 
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
          tokenMap = Object::New();
          callback->SetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME), tokenMap);
      }

      tokenMap.As<Object>()->Set(args[1], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
                
      return scope.Close(Undefined());
    }

    static v8::Handle<v8::Value> RemoveListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;

      if ((NodeRT::Utils::CaseInsenstiveEquals(L"mapChanged", str)))
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Function> callback = args[1].As<Function>();
      Handle<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      Handle<Value> opaqueWrapperObj =  tokenMap.As<Object>()->Get(args[1]);

      if (opaqueWrapperObj.IsEmpty() || opaqueWrapperObj->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());
            
      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;
        
      try 
      {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"mapChanged", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::ApplicationDataCompositeValue^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          ApplicationDataCompositeValue *wrapper = ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(args.This());
          wrapper->_instance->MapChanged::remove(registrationToken);
        }
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      tokenMap.As<Object>()->Delete(args[0].As<String>());

      return scope.Close(Undefined());
    }
  private:
    ::Windows::Storage::ApplicationDataCompositeValue^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapApplicationDataCompositeValue(::Windows::Storage::ApplicationDataCompositeValue^ wintRtInstance);
    friend ::Windows::Storage::ApplicationDataCompositeValue^ UnwrapApplicationDataCompositeValue(Handle<Value> value);
    friend bool IsApplicationDataCompositeValueWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> ApplicationDataCompositeValue::s_constructorTemplate;

  v8::Handle<v8::Value> WrapApplicationDataCompositeValue(::Windows::Storage::ApplicationDataCompositeValue^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(ApplicationDataCompositeValue::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::ApplicationDataCompositeValue^ UnwrapApplicationDataCompositeValue(Handle<Value> value)
  {
     return ApplicationDataCompositeValue::Unwrap<ApplicationDataCompositeValue>(value.As<Object>())->_instance;
  }

  void InitApplicationDataCompositeValue(Handle<Object> exports)
  {
    ApplicationDataCompositeValue::Init(exports);
  }

} } } 

void init(Handle<Object> exports)
{
  if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
  {
    ThrowException(v8::Exception::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
    return;
  }
  
  NodeRT::Windows::Storage::InitKnownLibraryIdEnum(exports);
  NodeRT::Windows::Storage::InitCreationCollisionOptionEnum(exports);
  NodeRT::Windows::Storage::InitNameCollisionOptionEnum(exports);
  NodeRT::Windows::Storage::InitStorageDeleteOptionEnum(exports);
  NodeRT::Windows::Storage::InitStorageItemTypesEnum(exports);
  NodeRT::Windows::Storage::InitFileAttributesEnum(exports);
  NodeRT::Windows::Storage::InitFileAccessModeEnum(exports);
  NodeRT::Windows::Storage::InitStreamedFileFailureModeEnum(exports);
  NodeRT::Windows::Storage::InitApplicationDataLocalityEnum(exports);
  NodeRT::Windows::Storage::InitApplicationDataCreateDispositionEnum(exports);
  NodeRT::Windows::Storage::InitStorageLibrary(exports);
  NodeRT::Windows::Storage::InitStorageFolder(exports);
  NodeRT::Windows::Storage::InitKnownFolders(exports);
  NodeRT::Windows::Storage::InitStorageFile(exports);
  NodeRT::Windows::Storage::InitDownloadsFolder(exports);
  NodeRT::Windows::Storage::InitIStreamedFileDataRequest(exports);
  NodeRT::Windows::Storage::InitStreamedFileDataRequest(exports);
  NodeRT::Windows::Storage::InitStorageStreamTransaction(exports);
  NodeRT::Windows::Storage::InitIStorageItem(exports);
  NodeRT::Windows::Storage::InitIStorageFolder(exports);
  NodeRT::Windows::Storage::InitIStorageFile(exports);
  NodeRT::Windows::Storage::InitIStorageItem2(exports);
  NodeRT::Windows::Storage::InitIStorageItemProperties(exports);
  NodeRT::Windows::Storage::InitIStorageItemProperties2(exports);
  NodeRT::Windows::Storage::InitIStorageItemPropertiesWithProvider(exports);
  NodeRT::Windows::Storage::InitStorageProvider(exports);
  NodeRT::Windows::Storage::InitIStorageFilePropertiesWithAvailability(exports);
  NodeRT::Windows::Storage::InitIStorageFolder2(exports);
  NodeRT::Windows::Storage::InitFileIO(exports);
  NodeRT::Windows::Storage::InitPathIO(exports);
  NodeRT::Windows::Storage::InitCachedFileManager(exports);
  NodeRT::Windows::Storage::InitSystemAudioProperties(exports);
  NodeRT::Windows::Storage::InitSystemGPSProperties(exports);
  NodeRT::Windows::Storage::InitSystemImageProperties(exports);
  NodeRT::Windows::Storage::InitSystemMediaProperties(exports);
  NodeRT::Windows::Storage::InitSystemMusicProperties(exports);
  NodeRT::Windows::Storage::InitSystemPhotoProperties(exports);
  NodeRT::Windows::Storage::InitSystemVideoProperties(exports);
  NodeRT::Windows::Storage::InitSystemProperties(exports);
  NodeRT::Windows::Storage::InitApplicationData(exports);
  NodeRT::Windows::Storage::InitSetVersionRequest(exports);
  NodeRT::Windows::Storage::InitApplicationDataContainer(exports);
  NodeRT::Windows::Storage::InitSetVersionDeferral(exports);
  NodeRT::Windows::Storage::InitApplicationDataContainerSettings(exports);
  NodeRT::Windows::Storage::InitApplicationDataCompositeValue(exports);

  NodeRT::Utils::RegisterNameSpace("Windows.Storage", exports);
}


NODE_MODULE(binding, init)