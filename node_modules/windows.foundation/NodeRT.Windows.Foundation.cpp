// Copyright (c) Microsoft Corporation
// All rights reserved. 
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 
//
// See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.

#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include <string>
#include <node_object_wrap.h>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using namespace v8;
using namespace node;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Foundation { 
  v8::Handle<v8::Value> WrapWwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ wintRtInstance);
  ::Windows::Foundation::WwwFormUrlDecoder^ UnwrapWwwFormUrlDecoder(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ wintRtInstance);
  ::Windows::Foundation::IWwwFormUrlDecoderEntry^ UnwrapIWwwFormUrlDecoderEntry(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapWwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ wintRtInstance);
  ::Windows::Foundation::WwwFormUrlDecoderEntry^ UnwrapWwwFormUrlDecoderEntry(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ wintRtInstance);
  ::Windows::Foundation::IGetActivationFactory^ UnwrapIGetActivationFactory(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapPropertyValue(::Windows::Foundation::PropertyValue^ wintRtInstance);
  ::Windows::Foundation::PropertyValue^ UnwrapPropertyValue(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIStringable(::Windows::Foundation::IStringable^ wintRtInstance);
  ::Windows::Foundation::IStringable^ UnwrapIStringable(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIAsyncInfo(::Windows::Foundation::IAsyncInfo^ wintRtInstance);
  ::Windows::Foundation::IAsyncInfo^ UnwrapIAsyncInfo(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIAsyncAction(::Windows::Foundation::IAsyncAction^ wintRtInstance);
  ::Windows::Foundation::IAsyncAction^ UnwrapIAsyncAction(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapUri(::Windows::Foundation::Uri^ wintRtInstance);
  ::Windows::Foundation::Uri^ UnwrapUri(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapIPropertyValue(::Windows::Foundation::IPropertyValue^ wintRtInstance);
  ::Windows::Foundation::IPropertyValue^ UnwrapIPropertyValue(Handle<Value> value);
  


  static v8::Handle<v8::Value> InitPropertyTypeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("PropertyType"), enumObject);
    enumObject->Set(String::NewSymbol("empty"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Empty)));
    enumObject->Set(String::NewSymbol("uInt8"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt8)));
    enumObject->Set(String::NewSymbol("int16"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Int16)));
    enumObject->Set(String::NewSymbol("uInt16"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt16)));
    enumObject->Set(String::NewSymbol("int32"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Int32)));
    enumObject->Set(String::NewSymbol("uInt32"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt32)));
    enumObject->Set(String::NewSymbol("int64"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Int64)));
    enumObject->Set(String::NewSymbol("uInt64"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt64)));
    enumObject->Set(String::NewSymbol("single"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Single)));
    enumObject->Set(String::NewSymbol("double"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Double)));
    enumObject->Set(String::NewSymbol("char16"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Char16)));
    enumObject->Set(String::NewSymbol("boolean"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Boolean)));
    enumObject->Set(String::NewSymbol("string"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::String)));
    enumObject->Set(String::NewSymbol("inspectable"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Inspectable)));
    enumObject->Set(String::NewSymbol("dateTime"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::DateTime)));
    enumObject->Set(String::NewSymbol("timeSpan"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::TimeSpan)));
    enumObject->Set(String::NewSymbol("guid"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Guid)));
    enumObject->Set(String::NewSymbol("point"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Point)));
    enumObject->Set(String::NewSymbol("size"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Size)));
    enumObject->Set(String::NewSymbol("rect"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Rect)));
    enumObject->Set(String::NewSymbol("otherType"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::OtherType)));
    enumObject->Set(String::NewSymbol("uInt8Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt8Array)));
    enumObject->Set(String::NewSymbol("int16Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Int16Array)));
    enumObject->Set(String::NewSymbol("uInt16Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt16Array)));
    enumObject->Set(String::NewSymbol("int32Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Int32Array)));
    enumObject->Set(String::NewSymbol("uInt32Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt32Array)));
    enumObject->Set(String::NewSymbol("int64Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Int64Array)));
    enumObject->Set(String::NewSymbol("uInt64Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::UInt64Array)));
    enumObject->Set(String::NewSymbol("singleArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::SingleArray)));
    enumObject->Set(String::NewSymbol("doubleArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::DoubleArray)));
    enumObject->Set(String::NewSymbol("char16Array"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::Char16Array)));
    enumObject->Set(String::NewSymbol("booleanArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::BooleanArray)));
    enumObject->Set(String::NewSymbol("stringArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::StringArray)));
    enumObject->Set(String::NewSymbol("inspectableArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::InspectableArray)));
    enumObject->Set(String::NewSymbol("dateTimeArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::DateTimeArray)));
    enumObject->Set(String::NewSymbol("timeSpanArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::TimeSpanArray)));
    enumObject->Set(String::NewSymbol("guidArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::GuidArray)));
    enumObject->Set(String::NewSymbol("pointArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::PointArray)));
    enumObject->Set(String::NewSymbol("sizeArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::SizeArray)));
    enumObject->Set(String::NewSymbol("rectArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::RectArray)));
    enumObject->Set(String::NewSymbol("otherTypeArray"), Integer::New(static_cast<int>(::Windows::Foundation::PropertyType::OtherTypeArray)));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitAsyncStatusEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("AsyncStatus"), enumObject);
    enumObject->Set(String::NewSymbol("started"), Integer::New(static_cast<int>(::Windows::Foundation::AsyncStatus::Started)));
    enumObject->Set(String::NewSymbol("completed"), Integer::New(static_cast<int>(::Windows::Foundation::AsyncStatus::Completed)));
    enumObject->Set(String::NewSymbol("canceled"), Integer::New(static_cast<int>(::Windows::Foundation::AsyncStatus::Canceled)));
    enumObject->Set(String::NewSymbol("error"), Integer::New(static_cast<int>(::Windows::Foundation::AsyncStatus::Error)));

    return scope.Close(Undefined());
  }



  
  class WwwFormUrlDecoder : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("WwwFormUrlDecoder"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getFirstValueByName"), FunctionTemplate::New(GetFirstValueByName)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("first"), FunctionTemplate::New(First)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getAt"), FunctionTemplate::New(GetAt)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("indexOf"), FunctionTemplate::New(IndexOf)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getMany"), FunctionTemplate::New(GetMany)->GetFunction());
      
                        
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("WwwFormUrlDecoder"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    WwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::WwwFormUrlDecoder^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::WwwFormUrlDecoder^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          winRtInstance = ref new ::Windows::Foundation::WwwFormUrlDecoder(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      WwwFormUrlDecoder *wrapperInstance = new WwwFormUrlDecoder(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetFirstValueByName(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          Platform::String^ result;
          result = wrapper->_instance->GetFirstValueByName(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> First(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Collections::IIterator<::Windows::Foundation::IWwwFormUrlDecoderEntry^>^ result;
          result = wrapper->_instance->First();
          return scope.Close(NodeRT::Collections::IteratorWrapper<::Windows::Foundation::IWwwFormUrlDecoderEntry^>::CreateIteratorWrapper(result, 
            [](::Windows::Foundation::IWwwFormUrlDecoderEntry^ val) -> Handle<Value> {
              return WrapIWwwFormUrlDecoderEntry(val);
            }
          ));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetAt(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(args.This());

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          ::Windows::Foundation::IWwwFormUrlDecoderEntry^ result;
          result = wrapper->_instance->GetAt(arg0);
          return scope.Close(WrapIWwwFormUrlDecoderEntry(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> IndexOf(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoder^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      WwwFormUrlDecoder *wrapper = WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(args[0]))
      {
        try
        {
          ::Windows::Foundation::IWwwFormUrlDecoderEntry^ arg0 = UnwrapIWwwFormUrlDecoderEntry(args[0]);
          unsigned int arg1;
          
          bool result;
          result = wrapper->_instance->IndexOf(arg0, &arg1);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("boolean"), Boolean::New(result));
          resObj->Set(String::NewSymbol("index"), Integer::New(arg1));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetMany(const v8::Arguments& args)
    {
      HandleScope scope;
      ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Not implemented")));
      return scope.Close(Undefined());
    }





  private:
    ::Windows::Foundation::WwwFormUrlDecoder^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapWwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ wintRtInstance);
    friend ::Windows::Foundation::WwwFormUrlDecoder^ UnwrapWwwFormUrlDecoder(Handle<Value> value);
    friend bool IsWwwFormUrlDecoderWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> WwwFormUrlDecoder::s_constructorTemplate;

  v8::Handle<v8::Value> WrapWwwFormUrlDecoder(::Windows::Foundation::WwwFormUrlDecoder^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(WwwFormUrlDecoder::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::WwwFormUrlDecoder^ UnwrapWwwFormUrlDecoder(Handle<Value> value)
  {
     return WwwFormUrlDecoder::Unwrap<WwwFormUrlDecoder>(value.As<Object>())->_instance;
  }

  void InitWwwFormUrlDecoder(Handle<Object> exports)
  {
    WwwFormUrlDecoder::Init(exports);
  }

  class IWwwFormUrlDecoderEntry : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IWwwFormUrlDecoderEntry"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("name"), NameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("value"), ValueGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IWwwFormUrlDecoderEntry"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::IWwwFormUrlDecoderEntry^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::IWwwFormUrlDecoderEntry^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IWwwFormUrlDecoderEntry *wrapperInstance = new IWwwFormUrlDecoderEntry(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> NameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IWwwFormUrlDecoderEntry *wrapper = IWwwFormUrlDecoderEntry::Unwrap<IWwwFormUrlDecoderEntry>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Name;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ValueGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IWwwFormUrlDecoderEntry^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IWwwFormUrlDecoderEntry *wrapper = IWwwFormUrlDecoderEntry::Unwrap<IWwwFormUrlDecoderEntry>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Value;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Foundation::IWwwFormUrlDecoderEntry^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ wintRtInstance);
    friend ::Windows::Foundation::IWwwFormUrlDecoderEntry^ UnwrapIWwwFormUrlDecoderEntry(Handle<Value> value);
    friend bool IsIWwwFormUrlDecoderEntryWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IWwwFormUrlDecoderEntry::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIWwwFormUrlDecoderEntry(::Windows::Foundation::IWwwFormUrlDecoderEntry^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IWwwFormUrlDecoderEntry::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::IWwwFormUrlDecoderEntry^ UnwrapIWwwFormUrlDecoderEntry(Handle<Value> value)
  {
     return IWwwFormUrlDecoderEntry::Unwrap<IWwwFormUrlDecoderEntry>(value.As<Object>())->_instance;
  }

  void InitIWwwFormUrlDecoderEntry(Handle<Object> exports)
  {
    IWwwFormUrlDecoderEntry::Init(exports);
  }

  class WwwFormUrlDecoderEntry : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("WwwFormUrlDecoderEntry"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("name"), NameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("value"), ValueGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("WwwFormUrlDecoderEntry"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    WwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::WwwFormUrlDecoderEntry^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::WwwFormUrlDecoderEntry^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      WwwFormUrlDecoderEntry *wrapperInstance = new WwwFormUrlDecoderEntry(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> NameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      WwwFormUrlDecoderEntry *wrapper = WwwFormUrlDecoderEntry::Unwrap<WwwFormUrlDecoderEntry>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Name;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ValueGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::WwwFormUrlDecoderEntry^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      WwwFormUrlDecoderEntry *wrapper = WwwFormUrlDecoderEntry::Unwrap<WwwFormUrlDecoderEntry>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Value;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Foundation::WwwFormUrlDecoderEntry^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapWwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ wintRtInstance);
    friend ::Windows::Foundation::WwwFormUrlDecoderEntry^ UnwrapWwwFormUrlDecoderEntry(Handle<Value> value);
    friend bool IsWwwFormUrlDecoderEntryWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> WwwFormUrlDecoderEntry::s_constructorTemplate;

  v8::Handle<v8::Value> WrapWwwFormUrlDecoderEntry(::Windows::Foundation::WwwFormUrlDecoderEntry^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(WwwFormUrlDecoderEntry::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::WwwFormUrlDecoderEntry^ UnwrapWwwFormUrlDecoderEntry(Handle<Value> value)
  {
     return WwwFormUrlDecoderEntry::Unwrap<WwwFormUrlDecoderEntry>(value.As<Object>())->_instance;
  }

  void InitWwwFormUrlDecoderEntry(Handle<Object> exports)
  {
    WwwFormUrlDecoderEntry::Init(exports);
  }

  class IGetActivationFactory : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IGetActivationFactory"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getActivationFactory"), FunctionTemplate::New(GetActivationFactory)->GetFunction());
      
                        
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IGetActivationFactory"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::IGetActivationFactory^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IGetActivationFactory^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::IGetActivationFactory^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IGetActivationFactory *wrapperInstance = new IGetActivationFactory(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetActivationFactory(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IGetActivationFactory^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IGetActivationFactory *wrapper = IGetActivationFactory::Unwrap<IGetActivationFactory>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          ::Platform::Object^ result;
          result = wrapper->_instance->GetActivationFactory(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Foundation::IGetActivationFactory^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ wintRtInstance);
    friend ::Windows::Foundation::IGetActivationFactory^ UnwrapIGetActivationFactory(Handle<Value> value);
    friend bool IsIGetActivationFactoryWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IGetActivationFactory::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIGetActivationFactory(::Windows::Foundation::IGetActivationFactory^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IGetActivationFactory::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::IGetActivationFactory^ UnwrapIGetActivationFactory(Handle<Value> value)
  {
     return IGetActivationFactory::Unwrap<IGetActivationFactory>(value.As<Object>())->_instance;
  }

  void InitIGetActivationFactory(Handle<Object> exports)
  {
    IGetActivationFactory::Init(exports);
  }

  class PropertyValue : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("PropertyValue"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("createEmpty"), FunctionTemplate::New(CreateEmpty)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt8"), FunctionTemplate::New(CreateUInt8)->GetFunction());
      constructor->Set(String::NewSymbol("createInt16"), FunctionTemplate::New(CreateInt16)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt16"), FunctionTemplate::New(CreateUInt16)->GetFunction());
      constructor->Set(String::NewSymbol("createInt32"), FunctionTemplate::New(CreateInt32)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt32"), FunctionTemplate::New(CreateUInt32)->GetFunction());
      constructor->Set(String::NewSymbol("createInt64"), FunctionTemplate::New(CreateInt64)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt64"), FunctionTemplate::New(CreateUInt64)->GetFunction());
      constructor->Set(String::NewSymbol("createSingle"), FunctionTemplate::New(CreateSingle)->GetFunction());
      constructor->Set(String::NewSymbol("createDouble"), FunctionTemplate::New(CreateDouble)->GetFunction());
      constructor->Set(String::NewSymbol("createChar16"), FunctionTemplate::New(CreateChar16)->GetFunction());
      constructor->Set(String::NewSymbol("createBoolean"), FunctionTemplate::New(CreateBoolean)->GetFunction());
      constructor->Set(String::NewSymbol("createString"), FunctionTemplate::New(CreateString)->GetFunction());
      constructor->Set(String::NewSymbol("createInspectable"), FunctionTemplate::New(CreateInspectable)->GetFunction());
      constructor->Set(String::NewSymbol("createGuid"), FunctionTemplate::New(CreateGuid)->GetFunction());
      constructor->Set(String::NewSymbol("createDateTime"), FunctionTemplate::New(CreateDateTime)->GetFunction());
      constructor->Set(String::NewSymbol("createTimeSpan"), FunctionTemplate::New(CreateTimeSpan)->GetFunction());
      constructor->Set(String::NewSymbol("createPoint"), FunctionTemplate::New(CreatePoint)->GetFunction());
      constructor->Set(String::NewSymbol("createSize"), FunctionTemplate::New(CreateSize)->GetFunction());
      constructor->Set(String::NewSymbol("createRect"), FunctionTemplate::New(CreateRect)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt8Array"), FunctionTemplate::New(CreateUInt8Array)->GetFunction());
      constructor->Set(String::NewSymbol("createInt16Array"), FunctionTemplate::New(CreateInt16Array)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt16Array"), FunctionTemplate::New(CreateUInt16Array)->GetFunction());
      constructor->Set(String::NewSymbol("createInt32Array"), FunctionTemplate::New(CreateInt32Array)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt32Array"), FunctionTemplate::New(CreateUInt32Array)->GetFunction());
      constructor->Set(String::NewSymbol("createInt64Array"), FunctionTemplate::New(CreateInt64Array)->GetFunction());
      constructor->Set(String::NewSymbol("createUInt64Array"), FunctionTemplate::New(CreateUInt64Array)->GetFunction());
      constructor->Set(String::NewSymbol("createSingleArray"), FunctionTemplate::New(CreateSingleArray)->GetFunction());
      constructor->Set(String::NewSymbol("createDoubleArray"), FunctionTemplate::New(CreateDoubleArray)->GetFunction());
      constructor->Set(String::NewSymbol("createChar16Array"), FunctionTemplate::New(CreateChar16Array)->GetFunction());
      constructor->Set(String::NewSymbol("createBooleanArray"), FunctionTemplate::New(CreateBooleanArray)->GetFunction());
      constructor->Set(String::NewSymbol("createStringArray"), FunctionTemplate::New(CreateStringArray)->GetFunction());
      constructor->Set(String::NewSymbol("createInspectableArray"), FunctionTemplate::New(CreateInspectableArray)->GetFunction());
      constructor->Set(String::NewSymbol("createGuidArray"), FunctionTemplate::New(CreateGuidArray)->GetFunction());
      constructor->Set(String::NewSymbol("createDateTimeArray"), FunctionTemplate::New(CreateDateTimeArray)->GetFunction());
      constructor->Set(String::NewSymbol("createTimeSpanArray"), FunctionTemplate::New(CreateTimeSpanArray)->GetFunction());
      constructor->Set(String::NewSymbol("createPointArray"), FunctionTemplate::New(CreatePointArray)->GetFunction());
      constructor->Set(String::NewSymbol("createSizeArray"), FunctionTemplate::New(CreateSizeArray)->GetFunction());
      constructor->Set(String::NewSymbol("createRectArray"), FunctionTemplate::New(CreateRectArray)->GetFunction());

      exports->Set(String::NewSymbol("PropertyValue"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    PropertyValue(::Windows::Foundation::PropertyValue^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::PropertyValue^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::PropertyValue^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::PropertyValue^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      PropertyValue *wrapperInstance = new PropertyValue(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  


    static Handle<Value> CreateEmpty(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateEmpty();
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt8(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          unsigned char arg0 = static_cast<unsigned char>(args[0]->Int32Value());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt8(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          short arg0 = static_cast<short>(args[0]->Int32Value());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt16(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          unsigned short arg0 = static_cast<unsigned short>(args[0]->Int32Value());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt16(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsInt32())
      {
        try
        {
          int arg0 = static_cast<int>(args[0]->Int32Value());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt32(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsUint32())
      {
        try
        {
          unsigned int arg0 = static_cast<unsigned int>(args[0]->IntegerValue());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt32(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          __int64 arg0 = args[0]->IntegerValue();
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt64(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          unsigned __int64 arg0 = static_cast<unsigned __int64>(args[0]->IntegerValue());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt64(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateSingle(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          float arg0 = static_cast<float>(args[0]->NumberValue());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSingle(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateDouble(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          double arg0 = args[0]->NumberValue();
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDouble(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateChar16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          wchar_t arg0 = NodeRT::Utils::GetFirstChar(args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateChar16(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateBoolean(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsBoolean())
      {
        try
        {
          bool arg0 = args[0]->BooleanValue();
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateBoolean(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateString(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInspectable(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(args[0]))
      {
        try
        {
          ::Platform::Object^ arg0 = dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInspectable(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateGuid(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsGuid(args[0]))
      {
        try
        {
          ::Platform::Guid arg0 = NodeRT::Utils::GuidFromJs(args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateGuid(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateDateTime(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsDate())
      {
        try
        {
          ::Windows::Foundation::DateTime arg0 = NodeRT::Utils::DateTimeFromJSDate(args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDateTime(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateTimeSpan(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsNumber())
      {
        try
        {
          ::Windows::Foundation::TimeSpan arg0 = NodeRT::Utils::TimeSpanFromMilli(args[0]->IntegerValue());
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateTimeSpan(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreatePoint(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsPoint(args[0]))
      {
        try
        {
          ::Windows::Foundation::Point arg0 = NodeRT::Utils::PointFromJs(args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreatePoint(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateSize(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsSize(args[0]))
      {
        try
        {
          ::Windows::Foundation::Size arg0 = NodeRT::Utils::SizeFromJs(args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSize(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateRect(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && NodeRT::Utils::IsRect(args[0]))
      {
        try
        {
          ::Windows::Foundation::Rect arg0 = NodeRT::Utils::RectFromJs(args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateRect(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt8Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned char>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned char>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned char>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> unsigned char {
                   return static_cast<unsigned char>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned char>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt8Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInt16Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<short>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<short>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<short>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<short>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> short {
                   return static_cast<short>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<short>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt16Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt16Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned short>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned short>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned short>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned short>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> unsigned short {
                   return static_cast<unsigned short>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned short>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt16Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInt32Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<int>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<int>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<int>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<int>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsInt32();
                 },
                 [](Handle<Value> value) -> int {
                   return static_cast<int>(value->Int32Value());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<int>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt32Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt32Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned int>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned int>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned int>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned int>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsUint32();
                 },
                 [](Handle<Value> value) -> unsigned int {
                   return static_cast<unsigned int>(value->IntegerValue());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned int>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt32Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInt64Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<__int64>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<__int64>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<__int64>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<__int64>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Handle<Value> value) -> __int64 {
                   return value->IntegerValue();
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<__int64>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInt64Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateUInt64Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<unsigned __int64>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<unsigned __int64>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<unsigned __int64>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<unsigned __int64>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Handle<Value> value) -> unsigned __int64 {
                   return static_cast<unsigned __int64>(value->IntegerValue());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<unsigned __int64>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateUInt64Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateSingleArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<float>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<float>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<float>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<float>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Handle<Value> value) -> float {
                   return static_cast<float>(value->NumberValue());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<float>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSingleArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateDoubleArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<double>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<double>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<double>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<double>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Handle<Value> value) -> double {
                   return value->NumberValue();
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<double>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDoubleArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateChar16Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<wchar_t>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<wchar_t>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<wchar_t>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<wchar_t>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsString();
                 },
                 [](Handle<Value> value) -> wchar_t {
                   return NodeRT::Utils::GetFirstChar(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<wchar_t>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateChar16Array(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateBooleanArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<bool>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<bool>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<bool>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<bool>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsBoolean();
                 },
                 [](Handle<Value> value) -> bool {
                   return value->BooleanValue();
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<bool>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateBooleanArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateStringArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Platform::String^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Platform::String^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Platform::String^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Platform::String^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return (!NodeRT::Utils::IsWinRtWrapper(value));
                 },
                 [](Handle<Value> value) -> ::Platform::String^ {
                   return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Platform::String^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateStringArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateInspectableArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Platform::Object^>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Platform::Object^>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Platform::Object^>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Platform::Object^>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Object^ {
                   return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Platform::Object^>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateInspectableArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateGuidArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Platform::Guid>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Platform::Guid>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Platform::Guid>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Platform::Guid>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsGuid(value);
                 },
                 [](Handle<Value> value) -> ::Platform::Guid {
                   return NodeRT::Utils::GuidFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Platform::Guid>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateGuidArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateDateTimeArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::DateTime>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::DateTime>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::DateTime>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::DateTime>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsDate();
                 },
                 [](Handle<Value> value) -> ::Windows::Foundation::DateTime {
                   return NodeRT::Utils::DateTimeFromJSDate(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::DateTime>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateDateTimeArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateTimeSpanArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::TimeSpan>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::TimeSpan>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::TimeSpan>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::TimeSpan>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return value->IsNumber();
                 },
                 [](Handle<Value> value) -> ::Windows::Foundation::TimeSpan {
                   return NodeRT::Utils::TimeSpanFromMilli(value->IntegerValue());
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::TimeSpan>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateTimeSpanArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreatePointArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::Point>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Point>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::Point>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::Point>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsPoint(value);
                 },
                 [](Handle<Value> value) -> ::Windows::Foundation::Point {
                   return NodeRT::Utils::PointFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::Point>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreatePointArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateSizeArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::Size>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Size>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::Size>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::Size>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsSize(value);
                 },
                 [](Handle<Value> value) -> ::Windows::Foundation::Size {
                   return NodeRT::Utils::SizeFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::Size>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateSizeArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CreateRectArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && (NodeRT::Utils::IsWinRtWrapperOf<::Platform::Array<::Windows::Foundation::Rect>^>(args[0]) || args[0]->IsArray()))
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Rect>^ arg0 = 
            [] (v8::Handle<v8::Value> value) -> ::Platform::Array<::Windows::Foundation::Rect>^
            {
              if (value->IsArray())
              {
                return NodeRT::Collections::JsArrayToWinrtArray<::Windows::Foundation::Rect>(value.As<Array>(), 
                 [](Handle<Value> value) -> bool {
                   return NodeRT::Utils::IsRect(value);
                 },
                 [](Handle<Value> value) -> ::Windows::Foundation::Rect {
                   return NodeRT::Utils::RectFromJs(value);
                 }
                );
              }
              else
              {
                return dynamic_cast<::Platform::Array<::Windows::Foundation::Rect>^>(NodeRT::Utils::GetObjectInstance(value));
              }
            } (args[0]);
          
          ::Platform::Object^ result;
          result = ::Windows::Foundation::PropertyValue::CreateRectArray(arg0);
          return scope.Close(CreateOpaqueWrapper(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



  private:
    ::Windows::Foundation::PropertyValue^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapPropertyValue(::Windows::Foundation::PropertyValue^ wintRtInstance);
    friend ::Windows::Foundation::PropertyValue^ UnwrapPropertyValue(Handle<Value> value);
    friend bool IsPropertyValueWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> PropertyValue::s_constructorTemplate;

  v8::Handle<v8::Value> WrapPropertyValue(::Windows::Foundation::PropertyValue^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(PropertyValue::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::PropertyValue^ UnwrapPropertyValue(Handle<Value> value)
  {
     return PropertyValue::Unwrap<PropertyValue>(value.As<Object>())->_instance;
  }

  void InitPropertyValue(Handle<Object> exports)
  {
    PropertyValue::Init(exports);
  }

  class IStringable : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IStringable"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("toString"), FunctionTemplate::New(ToString)->GetFunction());
      
                        
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IStringable"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IStringable(::Windows::Foundation::IStringable^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::IStringable^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IStringable^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::IStringable^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IStringable *wrapperInstance = new IStringable(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> ToString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IStringable^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IStringable *wrapper = IStringable::Unwrap<IStringable>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = wrapper->_instance->ToString();
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Foundation::IStringable^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIStringable(::Windows::Foundation::IStringable^ wintRtInstance);
    friend ::Windows::Foundation::IStringable^ UnwrapIStringable(Handle<Value> value);
    friend bool IsIStringableWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IStringable::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIStringable(::Windows::Foundation::IStringable^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IStringable::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::IStringable^ UnwrapIStringable(Handle<Value> value)
  {
     return IStringable::Unwrap<IStringable>(value.As<Object>())->_instance;
  }

  void InitIStringable(Handle<Object> exports)
  {
    IStringable::Init(exports);
  }

  class IAsyncInfo : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IAsyncInfo"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("cancel"), FunctionTemplate::New(Cancel)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("close"), FunctionTemplate::New(Close)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("errorCode"), ErrorCodeGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("id"), IdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("status"), StatusGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IAsyncInfo"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IAsyncInfo(::Windows::Foundation::IAsyncInfo^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::IAsyncInfo^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::IAsyncInfo^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IAsyncInfo *wrapperInstance = new IAsyncInfo(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> Cancel(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Cancel();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> Close(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Close();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> ErrorCodeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      try 
      {
        ::Windows::Foundation::HResult result = wrapper->_instance->ErrorCode;
        return scope.Close(Integer::New(result.Value));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> IdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      try 
      {
        unsigned int result = wrapper->_instance->Id;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> StatusGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncInfo^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncInfo *wrapper = IAsyncInfo::Unwrap<IAsyncInfo>(info.This());

      try 
      {
        ::Windows::Foundation::AsyncStatus result = wrapper->_instance->Status;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Foundation::IAsyncInfo^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIAsyncInfo(::Windows::Foundation::IAsyncInfo^ wintRtInstance);
    friend ::Windows::Foundation::IAsyncInfo^ UnwrapIAsyncInfo(Handle<Value> value);
    friend bool IsIAsyncInfoWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IAsyncInfo::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIAsyncInfo(::Windows::Foundation::IAsyncInfo^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IAsyncInfo::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::IAsyncInfo^ UnwrapIAsyncInfo(Handle<Value> value)
  {
     return IAsyncInfo::Unwrap<IAsyncInfo>(value.As<Object>())->_instance;
  }

  void InitIAsyncInfo(Handle<Object> exports)
  {
    IAsyncInfo::Init(exports);
  }

  class IAsyncAction : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IAsyncAction"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getResults"), FunctionTemplate::New(GetResults)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("completed"), CompletedGetter, CompletedSetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IAsyncAction"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IAsyncAction(::Windows::Foundation::IAsyncAction^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::IAsyncAction^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::IAsyncAction^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IAsyncAction *wrapperInstance = new IAsyncAction(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetResults(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncAction *wrapper = IAsyncAction::Unwrap<IAsyncAction>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->GetResults();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> CompletedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IAsyncAction *wrapper = IAsyncAction::Unwrap<IAsyncAction>(info.This());

      try 
      {
        ::Windows::Foundation::AsyncActionCompletedHandler^ result = wrapper->_instance->Completed;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "AsyncActionCompletedHandler", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void CompletedSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::AsyncActionCompletedHandler^>(value))
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IAsyncAction^>(info.This()))
      {
        return;
      }

      IAsyncAction *wrapper = IAsyncAction::Unwrap<IAsyncAction>(info.This());

      try 
      {
        
        ::Windows::Foundation::AsyncActionCompletedHandler^ winRtValue = dynamic_cast<::Windows::Foundation::AsyncActionCompletedHandler^>(NodeRT::Utils::GetObjectInstance(value));

        wrapper->_instance->Completed = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    


  private:
    ::Windows::Foundation::IAsyncAction^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIAsyncAction(::Windows::Foundation::IAsyncAction^ wintRtInstance);
    friend ::Windows::Foundation::IAsyncAction^ UnwrapIAsyncAction(Handle<Value> value);
    friend bool IsIAsyncActionWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IAsyncAction::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIAsyncAction(::Windows::Foundation::IAsyncAction^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IAsyncAction::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::IAsyncAction^ UnwrapIAsyncAction(Handle<Value> value)
  {
     return IAsyncAction::Unwrap<IAsyncAction>(value.As<Object>())->_instance;
  }

  void InitIAsyncAction(Handle<Object> exports)
  {
    IAsyncAction::Init(exports);
  }

  class Uri : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("Uri"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("equals"), FunctionTemplate::New(Equals)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("combineUri"), FunctionTemplate::New(CombineUri)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("toString"), FunctionTemplate::New(ToString)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("absoluteUri"), AbsoluteUriGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayUri"), DisplayUriGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("domain"), DomainGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("extension"), ExtensionGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("fragment"), FragmentGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("host"), HostGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("password"), PasswordGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("path"), PathGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("port"), PortGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("query"), QueryGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("queryParsed"), QueryParsedGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("rawUri"), RawUriGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("schemeName"), SchemeNameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("suspicious"), SuspiciousGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("userName"), UserNameGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("absoluteCanonicalUri"), AbsoluteCanonicalUriGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("displayIri"), DisplayIriGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("unescapeComponent"), FunctionTemplate::New(UnescapeComponent)->GetFunction());
      constructor->Set(String::NewSymbol("escapeComponent"), FunctionTemplate::New(EscapeComponent)->GetFunction());

      exports->Set(String::NewSymbol("Uri"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    Uri(::Windows::Foundation::Uri^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::Uri^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::Uri^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          winRtInstance = ref new ::Windows::Foundation::Uri(arg0);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else if (args.Length() == 2
        && args[0]->IsString()
        && args[1]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          
          winRtInstance = ref new ::Windows::Foundation::Uri(arg0,arg1);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      Uri *wrapperInstance = new Uri(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> Equals(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args[0]))
      {
        try
        {
          ::Windows::Foundation::Uri^ arg0 = dynamic_cast<::Windows::Foundation::Uri^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          bool result;
          result = wrapper->_instance->Equals(arg0);
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> CombineUri(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(args.This());

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          ::Windows::Foundation::Uri^ result;
          result = wrapper->_instance->CombineUri(arg0);
          return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Foundation", "Uri", result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> ToString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = wrapper->_instance->ToString();
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }


    static Handle<Value> UnescapeComponent(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          Platform::String^ result;
          result = ::Windows::Foundation::Uri::UnescapeComponent(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> EscapeComponent(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 1
        && args[0]->IsString())
      {
        try
        {
          Platform::String^ arg0 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[0])));
          
          Platform::String^ result;
          result = ::Windows::Foundation::Uri::EscapeComponent(arg0);
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }

    static Handle<Value> AbsoluteUriGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->AbsoluteUri;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayUriGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayUri;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DomainGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Domain;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> ExtensionGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Extension;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FragmentGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Fragment;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> HostGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Host;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PasswordGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Password;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PathGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Path;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> PortGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        int result = wrapper->_instance->Port;
        return scope.Close(Integer::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> QueryGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Query;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> QueryParsedGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        ::Windows::Foundation::WwwFormUrlDecoder^ result = wrapper->_instance->QueryParsed;
        return scope.Close(WrapWwwFormUrlDecoder(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> RawUriGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->RawUri;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SchemeNameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->SchemeName;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> SuspiciousGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        bool result = wrapper->_instance->Suspicious;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> UserNameGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->UserName;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> AbsoluteCanonicalUriGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->AbsoluteCanonicalUri;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> DisplayIriGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::Uri^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      Uri *wrapper = Uri::Unwrap<Uri>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->DisplayIri;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Foundation::Uri^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapUri(::Windows::Foundation::Uri^ wintRtInstance);
    friend ::Windows::Foundation::Uri^ UnwrapUri(Handle<Value> value);
    friend bool IsUriWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> Uri::s_constructorTemplate;

  v8::Handle<v8::Value> WrapUri(::Windows::Foundation::Uri^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(Uri::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::Uri^ UnwrapUri(Handle<Value> value)
  {
     return Uri::Unwrap<Uri>(value.As<Object>())->_instance;
  }

  void InitUri(Handle<Object> exports)
  {
    Uri::Init(exports);
  }

  class IPropertyValue : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("IPropertyValue"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt8"), FunctionTemplate::New(GetUInt8)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInt16"), FunctionTemplate::New(GetInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt16"), FunctionTemplate::New(GetUInt16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInt32"), FunctionTemplate::New(GetInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt32"), FunctionTemplate::New(GetUInt32)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInt64"), FunctionTemplate::New(GetInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt64"), FunctionTemplate::New(GetUInt64)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getSingle"), FunctionTemplate::New(GetSingle)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDouble"), FunctionTemplate::New(GetDouble)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getChar16"), FunctionTemplate::New(GetChar16)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getBoolean"), FunctionTemplate::New(GetBoolean)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getString"), FunctionTemplate::New(GetString)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getGuid"), FunctionTemplate::New(GetGuid)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDateTime"), FunctionTemplate::New(GetDateTime)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getTimeSpan"), FunctionTemplate::New(GetTimeSpan)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getPoint"), FunctionTemplate::New(GetPoint)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getSize"), FunctionTemplate::New(GetSize)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getRect"), FunctionTemplate::New(GetRect)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt8Array"), FunctionTemplate::New(GetUInt8Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInt16Array"), FunctionTemplate::New(GetInt16Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt16Array"), FunctionTemplate::New(GetUInt16Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInt32Array"), FunctionTemplate::New(GetInt32Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt32Array"), FunctionTemplate::New(GetUInt32Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInt64Array"), FunctionTemplate::New(GetInt64Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getUInt64Array"), FunctionTemplate::New(GetUInt64Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getSingleArray"), FunctionTemplate::New(GetSingleArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDoubleArray"), FunctionTemplate::New(GetDoubleArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getChar16Array"), FunctionTemplate::New(GetChar16Array)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getBooleanArray"), FunctionTemplate::New(GetBooleanArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getStringArray"), FunctionTemplate::New(GetStringArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getInspectableArray"), FunctionTemplate::New(GetInspectableArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getGuidArray"), FunctionTemplate::New(GetGuidArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDateTimeArray"), FunctionTemplate::New(GetDateTimeArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getTimeSpanArray"), FunctionTemplate::New(GetTimeSpanArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getPointArray"), FunctionTemplate::New(GetPointArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getSizeArray"), FunctionTemplate::New(GetSizeArray)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getRectArray"), FunctionTemplate::New(GetRectArray)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("isNumericScalar"), IsNumericScalarGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("type"), TypeGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("IPropertyValue"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    IPropertyValue(::Windows::Foundation::IPropertyValue^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Foundation::IPropertyValue^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Foundation::IPropertyValue^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      IPropertyValue *wrapperInstance = new IPropertyValue(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetUInt8(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned char result;
          result = wrapper->_instance->GetUInt8();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          short result;
          result = wrapper->_instance->GetInt16();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned short result;
          result = wrapper->_instance->GetUInt16();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          int result;
          result = wrapper->_instance->GetInt32();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt32(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned int result;
          result = wrapper->_instance->GetUInt32();
          return scope.Close(Integer::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          __int64 result;
          result = wrapper->_instance->GetInt64();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt64(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          unsigned __int64 result;
          result = wrapper->_instance->GetUInt64();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetSingle(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          float result;
          result = wrapper->_instance->GetSingle();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetDouble(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          double result;
          result = wrapper->_instance->GetDouble();
          return scope.Close(Number::New(static_cast<double>(result)));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetChar16(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wchar_t result;
          result = wrapper->_instance->GetChar16();
          return scope.Close(NodeRT::Utils::JsStringFromChar(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetBoolean(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          bool result;
          result = wrapper->_instance->GetBoolean();
          return scope.Close(Boolean::New(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetString(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          Platform::String^ result;
          result = wrapper->_instance->GetString();
          return scope.Close(NodeRT::Utils::NewString(result->Data()));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetGuid(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Guid result;
          result = wrapper->_instance->GetGuid();
          return scope.Close(NodeRT::Utils::GuidToJs(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetDateTime(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::DateTime result;
          result = wrapper->_instance->GetDateTime();
          return scope.Close(NodeRT::Utils::DateTimeToJS(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetTimeSpan(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::TimeSpan result;
          result = wrapper->_instance->GetTimeSpan();
          return scope.Close(Number::New(result.Duration/10000.0));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetPoint(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Point result;
          result = wrapper->_instance->GetPoint();
          return scope.Close(NodeRT::Utils::PointToJs(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetSize(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Size result;
          result = wrapper->_instance->GetSize();
          return scope.Close(NodeRT::Utils::SizeToJs(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetRect(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Foundation::Rect result;
          result = wrapper->_instance->GetRect();
          return scope.Close(NodeRT::Utils::RectToJs(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt8Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned char>^ arg0;
          
          wrapper->_instance->GetUInt8Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<unsigned char>::CreateArrayWrapper(arg0, 
            [](unsigned char val) -> Handle<Value> {
              return Integer::New(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Handle<Value> value) -> unsigned char {
              return static_cast<unsigned char>(value->Int32Value());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInt16Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<short>^ arg0;
          
          wrapper->_instance->GetInt16Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<short>::CreateArrayWrapper(arg0, 
            [](short val) -> Handle<Value> {
              return Integer::New(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Handle<Value> value) -> short {
              return static_cast<short>(value->Int32Value());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt16Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned short>^ arg0;
          
          wrapper->_instance->GetUInt16Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<unsigned short>::CreateArrayWrapper(arg0, 
            [](unsigned short val) -> Handle<Value> {
              return Integer::New(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Handle<Value> value) -> unsigned short {
              return static_cast<unsigned short>(value->Int32Value());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInt32Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<int>^ arg0;
          
          wrapper->_instance->GetInt32Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<int>::CreateArrayWrapper(arg0, 
            [](int val) -> Handle<Value> {
              return Integer::New(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsInt32();
            },
            [](Handle<Value> value) -> int {
              return static_cast<int>(value->Int32Value());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt32Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned int>^ arg0;
          
          wrapper->_instance->GetUInt32Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<unsigned int>::CreateArrayWrapper(arg0, 
            [](unsigned int val) -> Handle<Value> {
              return Integer::New(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsUint32();
            },
            [](Handle<Value> value) -> unsigned int {
              return static_cast<unsigned int>(value->IntegerValue());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInt64Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<__int64>^ arg0;
          
          wrapper->_instance->GetInt64Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<__int64>::CreateArrayWrapper(arg0, 
            [](__int64 val) -> Handle<Value> {
              return Number::New(static_cast<double>(val));
            },
            [](Handle<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Handle<Value> value) -> __int64 {
              return value->IntegerValue();
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetUInt64Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<unsigned __int64>^ arg0;
          
          wrapper->_instance->GetUInt64Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<unsigned __int64>::CreateArrayWrapper(arg0, 
            [](unsigned __int64 val) -> Handle<Value> {
              return Number::New(static_cast<double>(val));
            },
            [](Handle<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Handle<Value> value) -> unsigned __int64 {
              return static_cast<unsigned __int64>(value->IntegerValue());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetSingleArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<float>^ arg0;
          
          wrapper->_instance->GetSingleArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<float>::CreateArrayWrapper(arg0, 
            [](float val) -> Handle<Value> {
              return Number::New(static_cast<double>(val));
            },
            [](Handle<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Handle<Value> value) -> float {
              return static_cast<float>(value->NumberValue());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetDoubleArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<double>^ arg0;
          
          wrapper->_instance->GetDoubleArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<double>::CreateArrayWrapper(arg0, 
            [](double val) -> Handle<Value> {
              return Number::New(static_cast<double>(val));
            },
            [](Handle<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Handle<Value> value) -> double {
              return value->NumberValue();
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetChar16Array(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<wchar_t>^ arg0;
          
          wrapper->_instance->GetChar16Array(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<wchar_t>::CreateArrayWrapper(arg0, 
            [](wchar_t val) -> Handle<Value> {
              return NodeRT::Utils::JsStringFromChar(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> wchar_t {
              return NodeRT::Utils::GetFirstChar(value);
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetBooleanArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<bool>^ arg0;
          
          wrapper->_instance->GetBooleanArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<bool>::CreateArrayWrapper(arg0, 
            [](bool val) -> Handle<Value> {
              return Boolean::New(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsBoolean();
            },
            [](Handle<Value> value) -> bool {
              return value->BooleanValue();
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetStringArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Platform::String^>^ arg0;
          
          wrapper->_instance->GetStringArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Platform::String^>::CreateArrayWrapper(arg0, 
            [](::Platform::String^ val) -> Handle<Value> {
              return NodeRT::Utils::NewString(val->Data());
            },
            [](Handle<Value> value) -> bool {
              return value->IsString();
            },
            [](Handle<Value> value) -> ::Platform::String^ {
              return ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetInspectableArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Platform::Object^>^ arg0;
          
          wrapper->_instance->GetInspectableArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Platform::Object^>::CreateArrayWrapper(arg0, 
            [](::Platform::Object^ val) -> Handle<Value> {
              return CreateOpaqueWrapper(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsWinRtWrapperOf<::Platform::Object^>(value);
            },
            [](Handle<Value> value) -> ::Platform::Object^ {
              return dynamic_cast<::Platform::Object^>(NodeRT::Utils::GetObjectInstance(value));
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetGuidArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Platform::Guid>^ arg0;
          
          wrapper->_instance->GetGuidArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Platform::Guid>::CreateArrayWrapper(arg0, 
            [](::Platform::Guid val) -> Handle<Value> {
              return NodeRT::Utils::GuidToJs(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsGuid(value);
            },
            [](Handle<Value> value) -> ::Platform::Guid {
              return NodeRT::Utils::GuidFromJs(value);
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetDateTimeArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::DateTime>^ arg0;
          
          wrapper->_instance->GetDateTimeArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::DateTime>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::DateTime val) -> Handle<Value> {
              return NodeRT::Utils::DateTimeToJS(val);
            },
            [](Handle<Value> value) -> bool {
              return value->IsDate();
            },
            [](Handle<Value> value) -> ::Windows::Foundation::DateTime {
              return NodeRT::Utils::DateTimeFromJSDate(value);
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetTimeSpanArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::TimeSpan>^ arg0;
          
          wrapper->_instance->GetTimeSpanArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::TimeSpan>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::TimeSpan val) -> Handle<Value> {
              return Number::New(val.Duration/10000.0);
            },
            [](Handle<Value> value) -> bool {
              return value->IsNumber();
            },
            [](Handle<Value> value) -> ::Windows::Foundation::TimeSpan {
              return NodeRT::Utils::TimeSpanFromMilli(value->IntegerValue());
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetPointArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Point>^ arg0;
          
          wrapper->_instance->GetPointArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::Point>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::Point val) -> Handle<Value> {
              return NodeRT::Utils::PointToJs(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsPoint(value);
            },
            [](Handle<Value> value) -> ::Windows::Foundation::Point {
              return NodeRT::Utils::PointFromJs(value);
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetSizeArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Size>^ arg0;
          
          wrapper->_instance->GetSizeArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::Size>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::Size val) -> Handle<Value> {
              return NodeRT::Utils::SizeToJs(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsSize(value);
            },
            [](Handle<Value> value) -> ::Windows::Foundation::Size {
              return NodeRT::Utils::SizeFromJs(value);
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> GetRectArray(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Platform::Array<::Windows::Foundation::Rect>^ arg0;
          
          wrapper->_instance->GetRectArray(&arg0);
          Handle<Object> resObj = Object::New();
          resObj->Set(String::NewSymbol("value"), NodeRT::Collections::ArrayWrapper<::Windows::Foundation::Rect>::CreateArrayWrapper(arg0, 
            [](::Windows::Foundation::Rect val) -> Handle<Value> {
              return NodeRT::Utils::RectToJs(val);
            },
            [](Handle<Value> value) -> bool {
              return NodeRT::Utils::IsRect(value);
            },
            [](Handle<Value> value) -> ::Windows::Foundation::Rect {
              return NodeRT::Utils::RectFromJs(value);
            }
          ));
          return scope.Close(resObj);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> IsNumericScalarGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      try 
      {
        bool result = wrapper->_instance->IsNumericScalar;
        return scope.Close(Boolean::New(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> TypeGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Foundation::IPropertyValue^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      IPropertyValue *wrapper = IPropertyValue::Unwrap<IPropertyValue>(info.This());

      try 
      {
        ::Windows::Foundation::PropertyType result = wrapper->_instance->Type;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Foundation::IPropertyValue^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapIPropertyValue(::Windows::Foundation::IPropertyValue^ wintRtInstance);
    friend ::Windows::Foundation::IPropertyValue^ UnwrapIPropertyValue(Handle<Value> value);
    friend bool IsIPropertyValueWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> IPropertyValue::s_constructorTemplate;

  v8::Handle<v8::Value> WrapIPropertyValue(::Windows::Foundation::IPropertyValue^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(IPropertyValue::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Foundation::IPropertyValue^ UnwrapIPropertyValue(Handle<Value> value)
  {
     return IPropertyValue::Unwrap<IPropertyValue>(value.As<Object>())->_instance;
  }

  void InitIPropertyValue(Handle<Object> exports)
  {
    IPropertyValue::Init(exports);
  }

} } } 

void init(Handle<Object> exports)
{
  if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
  {
    ThrowException(v8::Exception::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
    return;
  }
  
  NodeRT::Windows::Foundation::InitPropertyTypeEnum(exports);
  NodeRT::Windows::Foundation::InitAsyncStatusEnum(exports);
  NodeRT::Windows::Foundation::InitWwwFormUrlDecoder(exports);
  NodeRT::Windows::Foundation::InitIWwwFormUrlDecoderEntry(exports);
  NodeRT::Windows::Foundation::InitWwwFormUrlDecoderEntry(exports);
  NodeRT::Windows::Foundation::InitIGetActivationFactory(exports);
  NodeRT::Windows::Foundation::InitPropertyValue(exports);
  NodeRT::Windows::Foundation::InitIStringable(exports);
  NodeRT::Windows::Foundation::InitIAsyncInfo(exports);
  NodeRT::Windows::Foundation::InitIAsyncAction(exports);
  NodeRT::Windows::Foundation::InitUri(exports);
  NodeRT::Windows::Foundation::InitIPropertyValue(exports);

  NodeRT::Utils::RegisterNameSpace("Windows.Foundation", exports);
}


NODE_MODULE(binding, init)