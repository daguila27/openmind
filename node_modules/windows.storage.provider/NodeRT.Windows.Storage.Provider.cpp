// Copyright (c) Microsoft Corporation
// All rights reserved. 
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
//
// THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT. 
//
// See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.

#define NTDDI_VERSION 0x06010000

#include <v8.h>
#include <string>
#include <node_object_wrap.h>
#include <ppltasks.h>
#include "CollectionsConverter.h"
#include "CollectionsWrap.h"
#include "node-async.h"
#include "NodeRtUtils.h"
#include "OpaqueWrapper.h"
#include "WrapperBase.h"

#using <Windows.WinMD>

// this undefs fixes the issues of compiling Windows.Data.Json, Windows.Storag.FileProperties, and Windows.Stroage.Search
// Some of the node header files brings windows definitions with the same names as some of the WinRT methods
#undef DocumentProperties
#undef GetObject
#undef CreateEvent
#undef FindText
#undef SendMessage

const char* REGISTRATION_TOKEN_MAP_PROPERTY_NAME = "__registrationTokenMap__";

using namespace v8;
using namespace node;
using namespace concurrency;

namespace NodeRT { namespace Windows { namespace Storage { namespace Provider { 
  v8::Handle<v8::Value> WrapCachedFileUpdaterUI(::Windows::Storage::Provider::CachedFileUpdaterUI^ wintRtInstance);
  ::Windows::Storage::Provider::CachedFileUpdaterUI^ UnwrapCachedFileUpdaterUI(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileUpdateRequestedEventArgs(::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ wintRtInstance);
  ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ UnwrapFileUpdateRequestedEventArgs(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileUpdateRequest(::Windows::Storage::Provider::FileUpdateRequest^ wintRtInstance);
  ::Windows::Storage::Provider::FileUpdateRequest^ UnwrapFileUpdateRequest(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapFileUpdateRequestDeferral(::Windows::Storage::Provider::FileUpdateRequestDeferral^ wintRtInstance);
  ::Windows::Storage::Provider::FileUpdateRequestDeferral^ UnwrapFileUpdateRequestDeferral(Handle<Value> value);
  
  v8::Handle<v8::Value> WrapCachedFileUpdater(::Windows::Storage::Provider::CachedFileUpdater^ wintRtInstance);
  ::Windows::Storage::Provider::CachedFileUpdater^ UnwrapCachedFileUpdater(Handle<Value> value);
  


  static v8::Handle<v8::Value> InitCachedFileTargetEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("CachedFileTarget"), enumObject);

    enumObject->Set(String::NewSymbol("local"), Integer::New(0));
    enumObject->Set(String::NewSymbol("remote"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitUIStatusEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("UIStatus"), enumObject);

    enumObject->Set(String::NewSymbol("unavailable"), Integer::New(0));
    enumObject->Set(String::NewSymbol("hidden"), Integer::New(1));
    enumObject->Set(String::NewSymbol("visible"), Integer::New(2));
    enumObject->Set(String::NewSymbol("complete"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitFileUpdateStatusEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("FileUpdateStatus"), enumObject);

    enumObject->Set(String::NewSymbol("incomplete"), Integer::New(0));
    enumObject->Set(String::NewSymbol("complete"), Integer::New(1));
    enumObject->Set(String::NewSymbol("userInputNeeded"), Integer::New(2));
    enumObject->Set(String::NewSymbol("currentlyUnavailable"), Integer::New(3));
    enumObject->Set(String::NewSymbol("failed"), Integer::New(4));
    enumObject->Set(String::NewSymbol("completeAndRenamed"), Integer::New(5));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitCachedFileOptionsEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("CachedFileOptions"), enumObject);

    enumObject->Set(String::NewSymbol("none"), Integer::New(0));
    enumObject->Set(String::NewSymbol("requireUpdateOnAccess"), Integer::New(1));
    enumObject->Set(String::NewSymbol("useCachedFileWhenOffline"), Integer::New(2));
    enumObject->Set(String::NewSymbol("denyAccessWhenOffline"), Integer::New(3));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitReadActivationModeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("ReadActivationMode"), enumObject);

    enumObject->Set(String::NewSymbol("notNeeded"), Integer::New(0));
    enumObject->Set(String::NewSymbol("beforeAccess"), Integer::New(1));

    return scope.Close(Undefined());
  }


  static v8::Handle<v8::Value> InitWriteActivationModeEnum(const Handle<Object> exports)
  {
    HandleScope scope;
    
    Handle<Object> enumObject = Object::New();
    exports->Set(String::NewSymbol("WriteActivationMode"), enumObject);

    enumObject->Set(String::NewSymbol("readOnly"), Integer::New(0));
    enumObject->Set(String::NewSymbol("notNeeded"), Integer::New(1));
    enumObject->Set(String::NewSymbol("afterWrite"), Integer::New(2));

    return scope.Close(Undefined());
  }



  
  class CachedFileUpdaterUI : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("CachedFileUpdaterUI"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                        
      Local<Function> addListenerFunc = FunctionTemplate::New(AddListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("addListener"), addListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("on"), addListenerFunc);
      Local<Function> removeListenerFunc = FunctionTemplate::New(RemoveListener)->GetFunction();
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("removeListener"), removeListenerFunc);
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("off"), removeListenerFunc);
            
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("title"), TitleGetter, TitleSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("uIStatus"), UIStatusGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("updateTarget"), UpdateTargetGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("CachedFileUpdaterUI"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    CachedFileUpdaterUI(::Windows::Storage::Provider::CachedFileUpdaterUI^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Provider::CachedFileUpdaterUI^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Provider::CachedFileUpdaterUI^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      CachedFileUpdaterUI *wrapperInstance = new CachedFileUpdaterUI(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> TitleGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->Title;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void TitleSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsString())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(info.This()))
      {
        return;
      }

      CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(info.This());

      try 
      {
        
        Platform::String^ winRtValue = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(value)));

        wrapper->_instance->Title = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> UIStatusGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(info.This());

      try 
      {
        ::Windows::Storage::Provider::UIStatus result = wrapper->_instance->UIStatus;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> UpdateTargetGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(info.This());

      try 
      {
        ::Windows::Storage::Provider::CachedFileTarget result = wrapper->_instance->UpdateTarget;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


    static v8::Handle<v8::Value> AddListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected arguments are eventName(string),callback(function)")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;
      
      Local<Function> callback = args[1].As<Function>();
      
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      if (NodeRT::Utils::CaseInsenstiveEquals(L"fileUpdateRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->FileUpdateRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Storage::Provider::CachedFileUpdaterUI^, ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^>(
            [callbackObjPtr](::Windows::Storage::Provider::CachedFileUpdaterUI^ arg0, ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = WrapCachedFileUpdaterUI(arg0);
                Handle<Value> wrappedArg1 = WrapFileUpdateRequestedEventArgs(arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else if (NodeRT::Utils::CaseInsenstiveEquals(L"uIRequested", str))
      {
        if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(args.This()))
        {
          ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
          return scope.Close(Undefined());
        }
        CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(args.This());
      
        try
        {
          std::shared_ptr<Persistent<Object>> callbackObjPtr(new Persistent<Object>(Persistent<Object>::New(NodeRT::Utils::CreateCallbackObjectInDomain(callback))), 
            [] (Persistent<Object> *ptr ) {
              NodeUtils::Async::RunOnMain([ptr]() {
                ptr->Dispose();
                delete ptr;
            });
          });

          registrationToken = wrapper->_instance->UIRequested::add(
            ref new ::Windows::Foundation::TypedEventHandler<::Windows::Storage::Provider::CachedFileUpdaterUI^, ::Platform::Object^>(
            [callbackObjPtr](::Windows::Storage::Provider::CachedFileUpdaterUI^ arg0, ::Platform::Object^ arg1) {
              NodeUtils::Async::RunOnMain([callbackObjPtr , arg0, arg1]() {
                TryCatch tryCatch;
              
                Handle<Value> error;

                Handle<Value> wrappedArg0 = WrapCachedFileUpdaterUI(arg0);
                Handle<Value> wrappedArg1 = CreateOpaqueWrapper(arg1);

                if (tryCatch.HasCaught())
                {
                  error = tryCatch.Exception()->ToObject();
                }
                else 
                {
                  error = Undefined();
                }


                if (wrappedArg0.IsEmpty()) wrappedArg0 = Undefined();
                if (wrappedArg1.IsEmpty()) wrappedArg1 = Undefined();

                Handle<Value> args[] = { wrappedArg0, wrappedArg1 };
                NodeRT::Utils::CallCallbackInDomain(*callbackObjPtr, _countof(args), args);
              });
            })
          );
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }

      }
      else 
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
          tokenMap = Object::New();
          callback->SetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME), tokenMap);
      }

      tokenMap.As<Object>()->Set(args[1], CreateOpaqueWrapper(::Windows::Foundation::PropertyValue::CreateInt64(registrationToken.Value)));
                
      return scope.Close(Undefined());
    }

    static v8::Handle<v8::Value> RemoveListener(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() < 2 || !args[0]->IsString() || !args[1]->IsFunction())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"wrong arguments, expected a string and a callback")));
        return scope.Close(Undefined());
      }

      String::Value eventName(args[0]);
      auto str = *eventName;

      if ((NodeRT::Utils::CaseInsenstiveEquals(L"fileUpdateRequested", str)) &&(NodeRT::Utils::CaseInsenstiveEquals(L"uIRequested", str)))
      {
        ThrowException(Exception::Error(String::Concat(NodeRT::Utils::NewString(L"given event name isn't supported: "), args[0].As<String>())));
        return scope.Close(Undefined());
      }

      Local<Function> callback = args[1].As<Function>();
      Handle<Value> tokenMap = callback->GetHiddenValue(String::NewSymbol(REGISTRATION_TOKEN_MAP_PROPERTY_NAME));
                
      if (tokenMap.IsEmpty() || tokenMap->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      Handle<Value> opaqueWrapperObj =  tokenMap.As<Object>()->Get(args[1]);

      if (opaqueWrapperObj.IsEmpty() || opaqueWrapperObj->Equals(Undefined()))
      {
        return scope.Close(Undefined());
      }

      OpaqueWrapper *opaqueWrapper = OpaqueWrapper::Unwrap<OpaqueWrapper>(opaqueWrapperObj.As<Object>());
            
      long long tokenValue = (long long) opaqueWrapper->GetObjectInstance();
      ::Windows::Foundation::EventRegistrationToken registrationToken;
      registrationToken.Value = tokenValue;
        
      try 
      {
        if (NodeRT::Utils::CaseInsenstiveEquals(L"fileUpdateRequested", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(args.This());
          wrapper->_instance->FileUpdateRequested::remove(registrationToken);
        }
        else if (NodeRT::Utils::CaseInsenstiveEquals(L"uIRequested", str))
        {
          if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdaterUI^>(args.This()))
          {
            ThrowException(Exception::Error(NodeRT::Utils::NewString(L"The caller of this method isn't of the expected type or internal WinRt object was disposed")));
            return scope.Close(Undefined());
          }
          CachedFileUpdaterUI *wrapper = CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(args.This());
          wrapper->_instance->UIRequested::remove(registrationToken);
        }
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }

      tokenMap.As<Object>()->Delete(args[0].As<String>());

      return scope.Close(Undefined());
    }
  private:
    ::Windows::Storage::Provider::CachedFileUpdaterUI^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapCachedFileUpdaterUI(::Windows::Storage::Provider::CachedFileUpdaterUI^ wintRtInstance);
    friend ::Windows::Storage::Provider::CachedFileUpdaterUI^ UnwrapCachedFileUpdaterUI(Handle<Value> value);
    friend bool IsCachedFileUpdaterUIWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> CachedFileUpdaterUI::s_constructorTemplate;

  v8::Handle<v8::Value> WrapCachedFileUpdaterUI(::Windows::Storage::Provider::CachedFileUpdaterUI^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(CachedFileUpdaterUI::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Provider::CachedFileUpdaterUI^ UnwrapCachedFileUpdaterUI(Handle<Value> value)
  {
     return CachedFileUpdaterUI::Unwrap<CachedFileUpdaterUI>(value.As<Object>())->_instance;
  }

  void InitCachedFileUpdaterUI(Handle<Object> exports)
  {
    CachedFileUpdaterUI::Init(exports);
  }

  class FileUpdateRequestedEventArgs : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileUpdateRequestedEventArgs"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("request"), RequestGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("FileUpdateRequestedEventArgs"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileUpdateRequestedEventArgs(::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequestedEventArgs^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Provider::FileUpdateRequestedEventArgs^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileUpdateRequestedEventArgs *wrapperInstance = new FileUpdateRequestedEventArgs(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  



    static Handle<Value> RequestGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequestedEventArgs^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequestedEventArgs *wrapper = FileUpdateRequestedEventArgs::Unwrap<FileUpdateRequestedEventArgs>(info.This());

      try 
      {
        ::Windows::Storage::Provider::FileUpdateRequest^ result = wrapper->_instance->Request;
        return scope.Close(WrapFileUpdateRequest(result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileUpdateRequestedEventArgs(::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ wintRtInstance);
    friend ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ UnwrapFileUpdateRequestedEventArgs(Handle<Value> value);
    friend bool IsFileUpdateRequestedEventArgsWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileUpdateRequestedEventArgs::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileUpdateRequestedEventArgs(::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileUpdateRequestedEventArgs::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Provider::FileUpdateRequestedEventArgs^ UnwrapFileUpdateRequestedEventArgs(Handle<Value> value)
  {
     return FileUpdateRequestedEventArgs::Unwrap<FileUpdateRequestedEventArgs>(value.As<Object>())->_instance;
  }

  void InitFileUpdateRequestedEventArgs(Handle<Object> exports)
  {
    FileUpdateRequestedEventArgs::Init(exports);
  }

  class FileUpdateRequest : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileUpdateRequest"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("getDeferral"), FunctionTemplate::New(GetDeferral)->GetFunction());
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("updateLocalFile"), FunctionTemplate::New(UpdateLocalFile)->GetFunction());
      
                        
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("status"), StatusGetter, StatusSetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("contentId"), ContentIdGetter);
      s_constructorTemplate->PrototypeTemplate()->SetAccessor(String::NewSymbol("file"), FileGetter);
      
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("FileUpdateRequest"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileUpdateRequest(::Windows::Storage::Provider::FileUpdateRequest^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Provider::FileUpdateRequest^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Provider::FileUpdateRequest^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileUpdateRequest *wrapperInstance = new FileUpdateRequest(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> GetDeferral(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequest *wrapper = FileUpdateRequest::Unwrap<FileUpdateRequest>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          ::Windows::Storage::Provider::FileUpdateRequestDeferral^ result;
          result = wrapper->_instance->GetDeferral();
          return scope.Close(WrapFileUpdateRequestDeferral(result));
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }
    static Handle<Value> UpdateLocalFile(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequest *wrapper = FileUpdateRequest::Unwrap<FileUpdateRequest>(args.This());

      if (args.Length() == 1
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0]))
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = dynamic_cast<::Windows::Storage::IStorageFile^>(NodeRT::Utils::GetObjectInstance(args[0]));
          
          wrapper->_instance->UpdateLocalFile(arg0);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



    static Handle<Value> StatusGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequest *wrapper = FileUpdateRequest::Unwrap<FileUpdateRequest>(info.This());

      try 
      {
        ::Windows::Storage::Provider::FileUpdateStatus result = wrapper->_instance->Status;
        return scope.Close(Integer::New(static_cast<int>(result)));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static void StatusSetter(Local<String> property, Local<Value> value, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!value->IsInt32())
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Value to set is of unexpected type")));
        return;
      }

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(info.This()))
      {
        return;
      }

      FileUpdateRequest *wrapper = FileUpdateRequest::Unwrap<FileUpdateRequest>(info.This());

      try 
      {
        
        ::Windows::Storage::Provider::FileUpdateStatus winRtValue = static_cast<::Windows::Storage::Provider::FileUpdateStatus>(value->Int32Value());

        wrapper->_instance->Status = winRtValue;
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
      }
    }
    
    static Handle<Value> ContentIdGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequest *wrapper = FileUpdateRequest::Unwrap<FileUpdateRequest>(info.This());

      try 
      {
        Platform::String^ result = wrapper->_instance->ContentId;
        return scope.Close(NodeRT::Utils::NewString(result->Data()));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    
    static Handle<Value> FileGetter(Local<String> property, const AccessorInfo &info)
    {
      HandleScope scope;
      
      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequest^>(info.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequest *wrapper = FileUpdateRequest::Unwrap<FileUpdateRequest>(info.This());

      try 
      {
        ::Windows::Storage::StorageFile^ result = wrapper->_instance->File;
        return scope.Close(NodeRT::Utils::CreateExternalWinRTObject("Windows.Storage", "StorageFile", result));
      }
      catch (Platform::Exception ^exception)
      {
        NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
        return scope.Close(Undefined());
      }
    }
    


  private:
    ::Windows::Storage::Provider::FileUpdateRequest^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileUpdateRequest(::Windows::Storage::Provider::FileUpdateRequest^ wintRtInstance);
    friend ::Windows::Storage::Provider::FileUpdateRequest^ UnwrapFileUpdateRequest(Handle<Value> value);
    friend bool IsFileUpdateRequestWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileUpdateRequest::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileUpdateRequest(::Windows::Storage::Provider::FileUpdateRequest^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileUpdateRequest::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Provider::FileUpdateRequest^ UnwrapFileUpdateRequest(Handle<Value> value)
  {
     return FileUpdateRequest::Unwrap<FileUpdateRequest>(value.As<Object>())->_instance;
  }

  void InitFileUpdateRequest(Handle<Object> exports)
  {
    FileUpdateRequest::Init(exports);
  }

  class FileUpdateRequestDeferral : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("FileUpdateRequestDeferral"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
            
      s_constructorTemplate->PrototypeTemplate()->Set(String::NewSymbol("complete"), FunctionTemplate::New(Complete)->GetFunction());
      
                        
      Local<Function> constructor = s_constructorTemplate->GetFunction();


      exports->Set(String::NewSymbol("FileUpdateRequestDeferral"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    FileUpdateRequestDeferral(::Windows::Storage::Provider::FileUpdateRequestDeferral^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Provider::FileUpdateRequestDeferral^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequestDeferral^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Provider::FileUpdateRequestDeferral^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      FileUpdateRequestDeferral *wrapperInstance = new FileUpdateRequestDeferral(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  
    static Handle<Value> Complete(const v8::Arguments& args)
    {
      HandleScope scope;

      if (!NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::FileUpdateRequestDeferral^>(args.This()))
      {
        return scope.Close(Undefined());
      }

      FileUpdateRequestDeferral *wrapper = FileUpdateRequestDeferral::Unwrap<FileUpdateRequestDeferral>(args.This());

      if (args.Length() == 0)
      {
        try
        {
          wrapper->_instance->Complete();
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }





  private:
    ::Windows::Storage::Provider::FileUpdateRequestDeferral^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapFileUpdateRequestDeferral(::Windows::Storage::Provider::FileUpdateRequestDeferral^ wintRtInstance);
    friend ::Windows::Storage::Provider::FileUpdateRequestDeferral^ UnwrapFileUpdateRequestDeferral(Handle<Value> value);
    friend bool IsFileUpdateRequestDeferralWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> FileUpdateRequestDeferral::s_constructorTemplate;

  v8::Handle<v8::Value> WrapFileUpdateRequestDeferral(::Windows::Storage::Provider::FileUpdateRequestDeferral^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(FileUpdateRequestDeferral::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Provider::FileUpdateRequestDeferral^ UnwrapFileUpdateRequestDeferral(Handle<Value> value)
  {
     return FileUpdateRequestDeferral::Unwrap<FileUpdateRequestDeferral>(value.As<Object>())->_instance;
  }

  void InitFileUpdateRequestDeferral(Handle<Object> exports)
  {
    FileUpdateRequestDeferral::Init(exports);
  }

  class CachedFileUpdater : public WrapperBase
  {
  public:    
    static v8::Handle<v8::Value> Init(const Handle<Object> exports)
    {
      HandleScope scope;
      
      s_constructorTemplate = Persistent<FunctionTemplate>::New(FunctionTemplate::New(New));
      s_constructorTemplate->SetClassName(String::NewSymbol("CachedFileUpdater"));
      s_constructorTemplate->InstanceTemplate()->SetInternalFieldCount(1);
      
                              
      Local<Function> constructor = s_constructorTemplate->GetFunction();

      constructor->Set(String::NewSymbol("setUpdateInformation"), FunctionTemplate::New(SetUpdateInformation)->GetFunction());

      exports->Set(String::NewSymbol("CachedFileUpdater"), constructor);
      return scope.Close(Undefined());
    }


    virtual ::Platform::Object^ GetObjectInstance() const override
    {
      return _instance;
    }

  private:
    
    CachedFileUpdater(::Windows::Storage::Provider::CachedFileUpdater^ instance)
    {
      _instance = instance;
    }
    
    
    static v8::Handle<v8::Value> New(const v8::Arguments& args)
    {
      HandleScope scope;

      // in case the constructor was called without the new operator
      if (!s_constructorTemplate->HasInstance(args.This()))
      {
        if (args.Length() > 0)
        {
          std::unique_ptr<Handle<Value> []> constructorArgs(new Handle<Value>[args.Length()]);

          Handle<Value> *argsPtr = constructorArgs.get();
          for (int i = 0; i < args.Length(); i++)
          {
            argsPtr[i] = args[i];
          }

          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), constructorArgs.get());
        }
        else
        {
          return s_constructorTemplate->GetFunction()->CallAsConstructor(args.Length(), nullptr);
        }
      }
      
      ::Windows::Storage::Provider::CachedFileUpdater^ winRtInstance;


      if (args.Length() == 1 && OpaqueWrapper::IsOpaqueWrapper(args[0]) &&
        NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::Provider::CachedFileUpdater^>(args[0]))
      {
        try 
        {
          winRtInstance = (::Windows::Storage::Provider::CachedFileUpdater^) NodeRT::Utils::GetObjectInstance(args[0]);
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Invalid arguments, no suitable constructor found")));
        return scope.Close(Undefined());
      }

      args.This()->SetHiddenValue(String::NewSymbol("__winRtInstance__"), True());

      CachedFileUpdater *wrapperInstance = new CachedFileUpdater(winRtInstance);
      wrapperInstance->Wrap(args.This());

      return args.This();
    }


  


    static Handle<Value> SetUpdateInformation(const v8::Arguments& args)
    {
      HandleScope scope;

      if (args.Length() == 5
        && NodeRT::Utils::IsWinRtWrapperOf<::Windows::Storage::IStorageFile^>(args[0])
        && args[1]->IsString()
        && args[2]->IsInt32()
        && args[3]->IsInt32()
        && args[4]->IsInt32())
      {
        try
        {
          ::Windows::Storage::IStorageFile^ arg0 = dynamic_cast<::Windows::Storage::IStorageFile^>(NodeRT::Utils::GetObjectInstance(args[0]));
          Platform::String^ arg1 = ref new Platform::String(NodeRT::Utils::StringToWchar(v8::String::Value(args[1])));
          ::Windows::Storage::Provider::ReadActivationMode arg2 = static_cast<::Windows::Storage::Provider::ReadActivationMode>(args[2]->Int32Value());
          ::Windows::Storage::Provider::WriteActivationMode arg3 = static_cast<::Windows::Storage::Provider::WriteActivationMode>(args[3]->Int32Value());
          ::Windows::Storage::Provider::CachedFileOptions arg4 = static_cast<::Windows::Storage::Provider::CachedFileOptions>(args[4]->Int32Value());
          
          ::Windows::Storage::Provider::CachedFileUpdater::SetUpdateInformation(arg0, arg1, arg2, arg3, arg4);
          return scope.Close(Undefined());   
        }
        catch (Platform::Exception ^exception)
        {
          NodeRT::Utils::ThrowWinRtExceptionInJs(exception);
          return scope.Close(Undefined());
        }
      }
      else 
      {
        ThrowException(Exception::Error(NodeRT::Utils::NewString(L"Bad arguments: no suitable overload found")));
        return scope.Close(Undefined());
      }

      return scope.Close(Undefined());
    }



  private:
    ::Windows::Storage::Provider::CachedFileUpdater^ _instance;
    static Persistent<FunctionTemplate> s_constructorTemplate;

    friend v8::Handle<v8::Value> WrapCachedFileUpdater(::Windows::Storage::Provider::CachedFileUpdater^ wintRtInstance);
    friend ::Windows::Storage::Provider::CachedFileUpdater^ UnwrapCachedFileUpdater(Handle<Value> value);
    friend bool IsCachedFileUpdaterWrapper(Handle<Value> value);
  };
  Persistent<FunctionTemplate> CachedFileUpdater::s_constructorTemplate;

  v8::Handle<v8::Value> WrapCachedFileUpdater(::Windows::Storage::Provider::CachedFileUpdater^ winRtInstance)
  {
    HandleScope scope;

    if (winRtInstance == nullptr)
    {
      return scope.Close(Undefined());
    }

    Handle<Object> opaqueWrapper = CreateOpaqueWrapper(winRtInstance);
    Handle<Value> args[] = {opaqueWrapper};
    return scope.Close(CachedFileUpdater::s_constructorTemplate->GetFunction()->NewInstance(_countof(args), args));
  }

  ::Windows::Storage::Provider::CachedFileUpdater^ UnwrapCachedFileUpdater(Handle<Value> value)
  {
     return CachedFileUpdater::Unwrap<CachedFileUpdater>(value.As<Object>())->_instance;
  }

  void InitCachedFileUpdater(Handle<Object> exports)
  {
    CachedFileUpdater::Init(exports);
  }

} } } } 

void init(Handle<Object> exports)
{
  if (FAILED(CoInitializeEx(nullptr, COINIT_MULTITHREADED)))
  {
    ThrowException(v8::Exception::Error(NodeRT::Utils::NewString(L"error in CoInitializeEx()")));
    return;
  }
  
  NodeRT::Windows::Storage::Provider::InitCachedFileTargetEnum(exports);
  NodeRT::Windows::Storage::Provider::InitUIStatusEnum(exports);
  NodeRT::Windows::Storage::Provider::InitFileUpdateStatusEnum(exports);
  NodeRT::Windows::Storage::Provider::InitCachedFileOptionsEnum(exports);
  NodeRT::Windows::Storage::Provider::InitReadActivationModeEnum(exports);
  NodeRT::Windows::Storage::Provider::InitWriteActivationModeEnum(exports);
  NodeRT::Windows::Storage::Provider::InitCachedFileUpdaterUI(exports);
  NodeRT::Windows::Storage::Provider::InitFileUpdateRequestedEventArgs(exports);
  NodeRT::Windows::Storage::Provider::InitFileUpdateRequest(exports);
  NodeRT::Windows::Storage::Provider::InitFileUpdateRequestDeferral(exports);
  NodeRT::Windows::Storage::Provider::InitCachedFileUpdater(exports);

  NodeRT::Utils::RegisterNameSpace("Windows.Storage.Provider", exports);
}


NODE_MODULE(binding, init)